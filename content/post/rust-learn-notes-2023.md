---
title: "Rust学习笔记2023"
date: 2023-12-06
tags: ["rust"]
draft: false
---

## 基础

###  原生字符串 `r""`和`r##""##`的异同

在Rust中,`r""`和`r##""##`都是原生字符串字面量(raw string literals)。它们的主要区别是:

- `r""`是一个普通的原生字符串字面量,里面的内容会原封不动地作为字符串。
- `r##""##`是一个可嵌套的原生字符串字面量,可以包含未转义的引号`"`。

普通的原生字符串字面量`r""`:

```rust
let s = r"Hello, world!";
```

可嵌套的原生字符串字面量`r##""##`:

```rust
let s = r##"Hello, "world"!"##;
```

`r##""##`允许字符串内部包含未转义的引号,这在需要编写包含引号的字符串时很有用。

它们的共同点是都不对字符串内容进行转义处理。不同的是`r##""##`支持嵌套未转义的引号。

### 范围表达式中`..=`和`..`的区别

在Rust中,`..=`和`..`都是范围表达式,用于生成一个迭代器来遍历指定范围内的数值。

主要区别在于:

- `..=`表示一个闭区间,包含范围的起始和结束值。
- `..`表示一个开区间,包含范围的起始值但不包含结束值。

例如:

```rust
let a = 1..=3; 
// a iterates over 1, 2, 3

let b = 1..3;
// b iterates over 1, 2
```

`..=`常用于`for`循环中遍历一个闭区间:

```rust
for i in 1..=10 {
  println!("{}", i); 
} 
// prints 1 2 3 ... 10
```

而`..`用于需要跳过结束值的情况:

```rust
let arr = [1, 2, 3];

for i in 0..arr.len() {
  println!("{}", arr[i]);
}
// prints 1 2
```



也就是,`..=`包含结束值,`..`不包含结束值。选择哪个取决于迭代需求。

### 闭包和函数的差异

在Rust中,闭包和函数有以下几点主要区别:

1. 闭包可以捕获环境中的变量,函数不能。

```rust
fn main() {
  let x = 10;

  let closure = || println!("{}", x); // 闭包捕获了x

  fn function() {
    println!("{}", x); // 函数不能捕获x
  }
}
```

1. 闭包的类型是不确定的,函数的类型是固定的。

```rust
fn foo(x: i32) -> i32 {
  x + 1 
} // foo的类型是 fn(i32) -> i32

let closure = |x| x + 1; // closure的类型是不确定的
```

1. 闭包可以通过Fn/FnMut/FnOnce trait来实现调用,函数必须通过名称来调用。

```rust
let closure = |x| println!("{}", x);
closure(1); // 通过Fn trait调用

fn foo(x: i32) {
  println!("{}", x)  
}
foo(1); // 必须通过名称foo来调用
```

1. 闭包是在运行时捕获环境的,函数在编译时就确定了作用域。
2. 闭包一般用于回调或高阶函数参数,函数用于通用逻辑封装。

所以总结来说,闭包更灵活,适合需要保存状态或环境的场景;函数更结构化,适合封装通用逻辑。