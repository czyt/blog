[{"content":"摘自网络，测试可用\npublic class ScanerHook { public delegate void ScanerDelegate(ScanerCodes codes); public event ScanerDelegate ScanerEvent; //private const int WM_KEYDOWN = 0x100;//KEYDOWN //private const int WM_KEYUP = 0x101;//KEYUP //private const int WM_SYSKEYDOWN = 0x104;//SYSKEYDOWN //private const int WM_SYSKEYUP = 0x105;//SYSKEYUP //private static int HookProc(int nCode, Int32 wParam, IntPtr lParam); private int hKeyboardHook = 0;//声明键盘钩子处理的初始值 private ScanerCodes codes = new ScanerCodes();//13为键盘钩子 //定义成静态，这样不会抛出回收异常 private static HookProc hookproc; delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam); [DllImport(\u0026#34;user32.dll\u0026#34;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] //设置钩子 private static extern int SetWindowsHookEx(int idHook, HookProc lpfn, IntPtr hInstance, int threadId); [DllImport(\u0026#34;user32.dll\u0026#34;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] //卸载钩子 private static extern bool UnhookWindowsHookEx(int idHook); [DllImport(\u0026#34;user32.dll\u0026#34;, CharSet = CharSet.Auto, CallingConvention = CallingConvention.StdCall)] //继续下个钩子 private static extern int CallNextHookEx(int idHook, int nCode, Int32 wParam, IntPtr lParam); [DllImport(\u0026#34;user32\u0026#34;, EntryPoint = \u0026#34;GetKeyNameText\u0026#34;)] private static extern int GetKeyNameText(int IParam, StringBuilder lpBuffer, int nSize); [DllImport(\u0026#34;user32\u0026#34;, EntryPoint = \u0026#34;GetKeyboardState\u0026#34;)] //获取按键的状态 private static extern int GetKeyboardState(byte[] pbKeyState); [DllImport(\u0026#34;user32\u0026#34;, EntryPoint = \u0026#34;ToAscii\u0026#34;)] //ToAscii职能的转换指定的虚拟键码和键盘状态的相应字符或字符 private static extern bool ToAscii(int VirtualKey, int ScanCode, byte[] lpKeySate, ref uint lpChar, int uFlags); //int VirtualKey //[in] 指定虚拟关键代码进行翻译。 //int uScanCode, // [in] 指定的硬件扫描码的关键须翻译成英文。高阶位的这个值设定的关键，如果是（不压） //byte[] lpbKeyState, // [in] 指针，以256字节数组，包含当前键盘的状态。每个元素（字节）的数组包含状态的一个关键。如果高阶位的字节是一套，关键是下跌（按下）。在低比特，如/果设置表明，关键是对切换。在此功能，只有肘位的CAPS LOCK键是相关的。在切换状态的NUM个锁和滚动锁定键被忽略。 //byte[] lpwTransKey, // [out] 指针的缓冲区收到翻译字符或字符。 //uint fuState); // [in] Specifies whether a menu is active. This parameter must be 1 if a menu is active, or 0 otherwise. [DllImport(\u0026#34;kernel32.dll\u0026#34;)] //使用WINDOWS API函数代替获取当前实例的函数,防止钩子失效 public static extern IntPtr GetModuleHandle(string name); public ScanerHook() { } public bool Start() { if (hKeyboardHook == 0) { hookproc = new HookProc(KeyboardHookProc); //GetModuleHandle 函数 替代 Marshal.GetHINSTANCE //防止在 framework4.0中 注册钩子不成功 IntPtr modulePtr = GetModuleHandle(Process.GetCurrentProcess().MainModule.ModuleName); //WH_KEYBOARD_LL=13 //全局钩子 WH_KEYBOARD_LL // hKeyboardHook = SetWindowsHookEx(13, hookproc, Marshal.GetHINSTANCE(Assembly.GetExecutingAssembly().GetModules()[0]), 0); hKeyboardHook = SetWindowsHookEx(13, hookproc, modulePtr, 0); } return (hKeyboardHook != 0); } public bool Stop() { if (hKeyboardHook != 0) { bool retKeyboard = UnhookWindowsHookEx(hKeyboardHook); hKeyboardHook = 0; return retKeyboard; } return true; } private int KeyboardHookProc(int nCode, Int32 wParam, IntPtr lParam) { EventMsg msg = (EventMsg)Marshal.PtrToStructure(lParam, typeof(EventMsg)); codes.Add(msg); if (ScanerEvent != null \u0026amp;\u0026amp; msg.message == 13 \u0026amp;\u0026amp; msg.paramH \u0026gt; 0 \u0026amp;\u0026amp; !string.IsNullOrEmpty(codes.Result)) { ScanerEvent(codes); } return CallNextHookEx(hKeyboardHook, nCode, wParam, lParam); } public class ScanerCodes { private int ts = 100; // 指定输入间隔为300毫秒以内时为连续输入 private List\u0026lt;List\u0026lt;EventMsg\u0026gt;\u0026gt; _keys = new List\u0026lt;List\u0026lt;EventMsg\u0026gt;\u0026gt;(); private List\u0026lt;int\u0026gt; _keydown = new List\u0026lt;int\u0026gt;(); // 保存组合键状态 private List\u0026lt;string\u0026gt; _result = new List\u0026lt;string\u0026gt;(); // 返回结果集 private DateTime _last = DateTime.Now; private byte[] _state = new byte[256]; private string _key = string.Empty; private string _cur = string.Empty; public EventMsg Event { get { if (_keys.Count == 0) { return new EventMsg(); } else { return _keys[_keys.Count - 1][_keys[_keys.Count - 1].Count - 1]; } } } public List\u0026lt;int\u0026gt; KeyDowns { get { return _keydown; } } public DateTime LastInput { get { return _last; } } public byte[] KeyboardState { get { return _state; } } public int KeyDownCount { get { return _keydown.Count; } } public string Result { get { if (_result.Count \u0026gt; 0) { return _result[_result.Count - 1].Trim(); } else { return null; } } } public string CurrentKey { get { return _key; } } public string CurrentChar { get { return _cur; } } public bool isShift { get { return _keydown.Contains(160); } } public void Add(EventMsg msg) { #region 记录按键信息 // 首次按下按键 if (_keys.Count == 0) { _keys.Add(new List\u0026lt;EventMsg\u0026gt;()); _keys[0].Add(msg); _result.Add(string.Empty); } // 未释放其他按键时按下按键 else if (_keydown.Count \u0026gt; 0) { _keys[_keys.Count - 1].Add(msg); } // 单位时间内按下按键 else if ((DateTime.Now - _last).TotalMilliseconds \u0026lt; ts) { _keys[_keys.Count - 1].Add(msg); } // 从新记录输入内容 else { _keys.Add(new List\u0026lt;EventMsg\u0026gt;()); _keys[_keys.Count - 1].Add(msg); _result.Add(string.Empty); } #endregion _last = DateTime.Now; #region 获取键盘状态 // 记录正在按下的按键 if (msg.paramH == 0 \u0026amp;\u0026amp; !_keydown.Contains(msg.message)) { _keydown.Add(msg.message); } // 清除已松开的按键 if (msg.paramH \u0026gt; 0 \u0026amp;\u0026amp; _keydown.Contains(msg.message)) { _keydown.Remove(msg.message); } #endregion #region 计算按键信息 int v = msg.message \u0026amp; 0xff; int c = msg.paramL \u0026amp; 0xff; StringBuilder strKeyName = new StringBuilder(500); if (GetKeyNameText(c * 65536, strKeyName, 255) \u0026gt; 0) { _key = strKeyName.ToString().Trim(new char[] { \u0026#39; \u0026#39;, \u0026#39;\\0\u0026#39; }); GetKeyboardState(_state); if (_key.Length == 1 \u0026amp;\u0026amp; msg.paramH == 0)// \u0026amp;\u0026amp; msg.paramH == 0 { // 根据键盘状态和shift缓存判断输出字符 _cur = ShiftChar(_key, isShift, _state).ToString(); _result[_result.Count - 1] += _cur; } else if (_key.Length == 5 \u0026amp;\u0026amp; msg.paramH == 0 \u0026amp;\u0026amp; msg.paramL == 78 \u0026amp;\u0026amp; msg.message == 107)// \u0026amp;\u0026amp; msg.paramH == 0 { // 根据键盘状态和shift缓存判断输出字符 _cur = Convert.ToChar(\u0026#39;+\u0026#39;).ToString(); _result[_result.Count - 1] += _cur; } else { _cur = string.Empty; } } #endregion } private char ShiftChar(string k, bool isShiftDown, byte[] state) { bool capslock = state[0x14] == 1; bool numlock = state[0x90] == 1; bool scrolllock = state[0x91] == 1; bool shiftdown = state[0xa0] == 1; char chr = (capslock ? k.ToUpper() : k.ToLower()).ToCharArray()[0]; if (isShiftDown) { if (chr \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; chr \u0026lt;= \u0026#39;z\u0026#39;) { chr = (char)((int)chr - 32); } else if (chr \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; chr \u0026lt;= \u0026#39;Z\u0026#39;) { if (chr == \u0026#39;Z\u0026#39;) { string s = \u0026#34;\u0026#34;; } chr = (char)((int)chr + 32); } else { string s = \u0026#34;`1234567890-=[];\u0026#39;,./\u0026#34;; string u = \u0026#34;~!@#$%^\u0026amp;*()_+{}:\\\u0026#34;\u0026lt;\u0026gt;?\u0026#34;; if (s.IndexOf(chr) \u0026gt;= 0) { return (u.ToCharArray())[s.IndexOf(chr)]; } } } return chr; } } public struct EventMsg { public int message; public int paramL; public int paramH; public int Time; public int hwnd; } } 某些情况下，特别是使用类似像微软拼音之类的中文输入法时，扫码枪会出现字符被输入法截获，显示不是很友好，所以需要使用InputMethod.SetPreferredImeState(target, InputMethodState.Off)来关闭输入法，只能输入英文，待业务调用完成后再切换回来。target可以是业务的主界面窗口，也可以是foucus的输入框。\n","permalink":"https://czyt.tech/post/scanner-input-hook-via-csharp/","summary":"摘自网络，测试可用\npublic class ScanerHook { public delegate void ScanerDelegate(ScanerCodes codes); public event ScanerDelegate ScanerEvent; //private const int WM_KEYDOWN = 0x100;//KEYDOWN //private const int WM_KEYUP = 0x101;//KEYUP //private const int WM_SYSKEYDOWN = 0x104;//SYSKEYDOWN //private const int WM_SYSKEYUP = 0x105;//SYSKEYUP //private static int HookProc(int nCode, Int32 wParam, IntPtr lParam); private int hKeyboardHook = 0;//声明键盘钩子处理的初始值 private ScanerCodes codes = new ScanerCodes();//13为键盘钩子 //定义成静态，这样不会抛出回收异常 private static HookProc hookproc; delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam); [DllImport(\u0026#34;user32.","title":"C#扫码枪输入Hook"},{"content":"预备知识 需要安装的软件 protoc golang go 软件包 github.com/lyft/protoc-gen-star 插件调用步骤 protoc，PB编译器，使用一组标志（记录在protoc -h下）进行配置，并将一组文件作为参数交给它。在这种情况下，I标志可以被多次指定，是它在proto文件中用于导入依赖关系的查找路径。默认情况下，官方描述符protos已经被包含在内。\nmyplugin_out 告诉 protoc 使用 protoc-gen-myplugin protoc-plugin。这些插件会从系统的 PATH 环境变量中自动解析，或者可以用另一个标志明确指定。官方的protoc-plugins (例如，protoc-gen-python) 已经在protoc注册了。该标志的值是特定于特定插件的，但 :\u0026hellip;/generated 后缀除外。这个后缀表示protoc将把该包生成的文件放在哪个根目录下（相对于当前工作目录）。然而，这个生成的输出目录不会传播给 protoc-gen-myplugin，所以它需要在标志的左边重复。PG* 通过一个 output_path 参数支持这一点。\nprotoc 解析传入的 proto 文件，确保它们在语法上是正确的，并加载任何导入的依赖项。它将这些文件和依赖关系转换成描述符 (它们本身就是 PB 消息)，并创建一个 CodeGeneratorRequest (又是一个 PB)。protoc 将这个请求序列化，然后执行每个配置的 protoc-plugin，通过 stdin 发送有效载荷。\nprotoc-gen-myplugin 启动，接收请求的有效载荷，并将其解密。一个基于 PG* 的 protoc-plugin 有两个阶段。首先，PG* 对从 protoc 收到的 CodeGeneratorRequest 进行解密，并为每个文件和其包含的所有实体创建一个完全连接的抽象语法树 (AST)。为这个插件指定的任何参数也会被解析，以便以后使用。\n当这一步完成后，PG*就会执行任何注册的模块，把构建的AST交给它。模块可以被写成生成人工制品（例如，文件），或者只是对所提供的图进行某种形式的验证而没有任何其他副作用。模块在针对PB的操作方面提供了极大的灵活性。\n一旦所有的模块都被运行，PG*会将任何自定义的工件写入文件系统，或者将生成器特定的工件序列化为CodeGeneratorResponse并将数据发送到其stdout。这整个流程看起来像这样。\nfoo.proto → protoc → CodeGeneratorRequest → protoc-gen-myplugin → CodeGeneratorResponse → protoc → foo.pb.go 假设插件名称为diy,则需要编译程序为protoc-gen-diy，并将程序加入系统Path变量，通过下面的命令调用插件。\nprotoc -I . --diy_out=./gen/ xxxx.proto 使用protoc-gen-star包 模块 Modules PG*模块将被交付一个完整的AST，用于生成目标文件以及所有依赖项。然后，模块可以将文件添加到协议CodeGeneratorResponse或将文件作为组件直接写入磁盘。\nPG*提供了一个ModuleBase结构来简化开发模块。开箱即用，它满足Module的接口，只需要创建Name和Execute方法。ModuleBase最好用作包装模块实现的匿名嵌入字段。最小模块如下所示：\n// ReportModule creates a report of all the target messages generated by the // protoc run, writing the file into the /tmp directory. type reportModule struct { *pgs.ModuleBase } // New configures the module with an instance of ModuleBase func New() pgs.Module { return \u0026amp;reportModule{\u0026amp;pgs.ModuleBase{}} } // Name is the identifier used to identify the module. This value is // automatically attached to the BuildContext associated with the ModuleBase. func (m *reportModule) Name() string { return \u0026#34;reporter\u0026#34; } // Execute is passed the target files as well as its dependencies in the pkgs // map. The implementation should return a slice of Artifacts that represent // the files to be generated. In this case, \u0026#34;/tmp/report.txt\u0026#34; will be created // outside of the normal protoc flow. func (m *reportModule) Execute(targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact { buf := \u0026amp;bytes.Buffer{} for _, f := range targets { m.Push(f.Name().String()).Debug(\u0026#34;reporting\u0026#34;) fmt.Fprintf(buf, \u0026#34;--- %v ---\u0026#34;, f.Name()) for i, msg := range f.AllMessages() { fmt.Fprintf(buf, \u0026#34;%03d. %v\\n\u0026#34;, i, msg.Name()) } m.Pop() } m.OverwriteCustomFile( \u0026#34;/tmp/report.txt\u0026#34;, buf.String(), 0644, ) return m.Artifacts() } ModuleBase公开了PG* buildContext实例，该实例已经带有模块的名称。调用PUSH和POP允许将更多信息添加到错误和调试消息中。上面，在记录“报告”调试消息之前，将目标软件包中的每个文件都推到上下文上。\n该基础还提供了用于添加或覆盖ProtoC生成和自定义文件的辅助方法。上面的执行方法在 /tmp/report.txt上创建一个自定义文件，指定其应覆盖使用该名称的现有文件。如果它称为AddCustomFile并存在该文件，则不会生成文件（尽管会记录调试消息）。也存在添加生成器文件，附加和注入的类似方法。同样，诸如AddCustomTemplateFile之类的方法允许渲染模板。\n在执行所有模块后，返回的工件要么将其放入ProtoC的CodeGenerationResponse有效负载中，要么写入文件系统。出于测试的目的，文件系统已经被抽象化，以便可以通过文件系统initoption向PG* Generator提供自定义的文件（例如内存FS）。\n后期处理 Post Processing 模块生成的工件有时需要在写入磁盘或发送对protoc的响应之前进行一些变更。这可能包括针对Go源代码运行gofmt或向所有生成的源文件添加版权标题。为了简化PG*中的此任务，可以使用PostProcessor。最小的PostProcessor实现可能如下所示：\n// New returns a PostProcessor that adds a copyright comment to the top // of all generated files. func New(owner string) pgs.PostProcessor { return copyrightPostProcessor{owner} } type copyrightPostProcessor struct { owner string } // Match returns true only for Custom and Generated files (including templates). func (cpp copyrightPostProcessor) Match(a pgs.Artifact) bool { switch a := a.(type) { case pgs.GeneratorFile, pgs.GeneratorTemplateFile, pgs.CustomFile, pgs.CustomTemplateFile: return true default: return false } } // Process attaches the copyright header to the top of the input bytes func (cpp copyrightPostProcessor) Process(in []byte) (out []byte, err error) { cmt := fmt.Sprintf(\u0026#34;// Copyright © %d %s. All rights reserved\\n\u0026#34;, time.Now().Year(), cpp.owner) return append([]byte(cmt), in...), nil } copyrightPostProcessor结构通过实现Match和Process方法来满足PostProcess接口。在PG*接收到所有工件后，每个工件依次交给每个注册处理器的Match方法。在上述情况下，如果文件是目标Artifact类型的一部分，则返回true。如果返回true，则立即使用文件的呈现内容调用Process。这个方法改变输入，如果出现问题，将修改后的值返回out或错误。上面，通知是在输入之前的。\nPostProcessors在PG*注册，类似于模块：\ng := pgs.Init(pgs.IncludeGo()) g.RegisterModule(some.NewModule()) g.RegisterPostProcessor(copyright.New(\u0026#34;PG* Authors\u0026#34;)) Protocol Buffer AST 虽然protoc确保生成proto文件所需的所有依赖关系都以描述符的形式加载进来，但要由protoc-plugins来识别它们之间的关系。为了解决这个问题，PG* 使用构建一个所有装入插件的实体的抽象语法树（AST）。这个AST被提供给每个模块，以方便代码的生成。\nHierarchy 层次结构 由PG*收集器产生的层次结构是完全链接的，从顶级的包开始，一直到消息的每个单独的字段。AST可以用下面的数字图表示。\n一个包描述了在同一命名空间内加载的一组文件。正如预期的那样，一个文件代表一个单一的proto文件，它包含任何数量的Message、Enum或Service实体。一个Enum描述了一个基于整数的枚举类型，包含每个单独的EnumValue。一个服务描述了一组RPC方法，这些方法反过来又指代它们的输入和输出消息。\n一个消息可以包含其他嵌套的消息和Enum，以及它的每个字段。对于非标量类型，一个字段也可以引用其消息或枚举类型。作为一种实现联合类型的机制，一个Message也可以包含OneOf实体，这些实体引用它的一些字段。\n访问者模式 Visitor Pattern AST的结构可能是相当复杂且不可预测的。同样，模块通常仅与图中的实体的一个子集有关。为了将模块的算法与理解和遍历AST的结构，PG*实现了访问者模式以使两者解耦。实现此接口非常简单，可以大大简化代码生成。\nPG*提供了两个基本访问者结构，以简化开发实现。首先，nilvisitor返回一个实例，该实例可在所有实体类型中执行。当AST的某些分支对代码生成不感兴趣的时候，这很有用。例如，如果模块仅与服务有关，则可以将nilvisitor用作匿名字段，并且仅实现所需的接口方法：\n// ServiceVisitor logs out each Method\u0026#39;s name type serviceVisitor struct { pgs.Visitor pgs.DebuggerCommon } func New(d pgs.DebuggerCommon) pgs.Visitor { return serviceVistor{ Visitor: pgs.NilVisitor(), DebuggerCommon: d, } } // Passthrough Packages, Files, and Services. All other methods can be // ignored since Services can only live in Files and Files can only live in a // Package. func (v serviceVisitor) VisitPackage(pgs.Package) (pgs.Visitor, error) { return v, nil } func (v serviceVisitor) VisitFile(pgs.File) (pgs.Visitor, error) { return v, nil } func (v serviceVisitor) VisitService(pgs.Service) (pgs.Visitor, error) { return v, nil } // VisitMethod logs out ServiceName#MethodName for m. func (v serviceVisitor) VisitMethod(m pgs.Method) (pgs.Vistitor, error) { v.Logf(\u0026#34;%v#%v\u0026#34;, m.Service().Name(), m.Name()) return nil, nil } 如果需要访问深度嵌套的节点，则可以使用PassThroughVisitor。与Nilvisitor不同，顾名思义，此实现通过所有节点，而不是在第一个未实现接口方法上进行短路。将此类型设置为一个匿名字段可能更为复杂，但避免了显式地实现接口的每种方法：\ntype fieldVisitor struct { pgs.Visitor pgs.DebuggerCommon } func New(d pgs.DebuggerCommon) pgs.Visitor { v := \u0026amp;fieldVisitor{DebuggerCommon: d} v.Visitor = pgs.PassThroughVisitor(v) return v } func (v *fieldVisitor) VisitField(f pgs.Field) (pgs.Visitor, error) { v.Logf(\u0026#34;%v.%v\u0026#34;, f.Message().Name(), f.Name()) return nil, nil } 通过任何visitor遍历AST都很简单：\nv := visitor.New(d) err := pgs.Walk(v, pkg) 所有实体类型和包都可以传递到Walk中，如果需要，允许启动低于顶级包的访问者。\n构建上下文 Build Context 用PG* Generator注册的模块是用BuildContext的实例初始化的，该实例封装了与上下文有关的路径、调试和参数信息。\n输出路径 Output Paths BuildContext的OutputPath方法返回PG*插件的输出目标目录。该路径初始化值为.但指向执行ProtoC的执行目录。可以通过在标志中提供outper_path来覆盖此默认行为。\n输出路径可用于使用JoinPath(name ...string)创建工件的文件名，这实际上是filepath.Join(ctx.OutputPath(), name...)的别名。手动跟踪输出路径的相对目录可能很乏味，尤其是在名称是动态的情况下。相反，BuildContext可以通过PushDir和PopDir来管理它们。\nctx.OutputPath() // foo ctx.JoinPath(\u0026#34;fizz\u0026#34;, \u0026#34;buzz.go\u0026#34;) // foo/fizz/buzz.go ctx = ctx.PushDir(\u0026#34;bar/baz\u0026#34;) ctx.OutputPath() // foo/bar/baz ctx.JoinPath(\u0026#34;quux.go\u0026#34;) // foo/bar/baz/quux.go ctx = ctx.PopDir() ctx.OutputPath() // foo ModuleBase包装这些方法以突变其基本的BuildContexts。应该使用这些方法，而不是直接包含的BuildContext上的方法。\n调试 Debugging BuildContext公开了DebuggerCommon接口，该接口提供用于记录，错误检查和断言的实用程序。日志和格式化的LOGF打印消息到OS.Stderr，通常带有模块名称。debug和debugf的表现相同，但仅在通过debugmode或debugenv initoptions启用时打印。\nFail和Failf立即停止执行Protoc-Plugin，并导致ProtoC通过提供的消息失败。如果输入错误或表达式分别评估为false，则Checkerr和断言也会因提供的消息而失败。\n可以通过在buildContext上调用推送和弹出来提供其他上下文前缀。此行为类似于PushDir和PopDir，但仅影响日志消息。ModuleBase包裹这些方法以突变其基本的构建版本。应该使用这些方法，而不是直接包含的buildContext上的方法。\n参数 Parameters BuildContext还提供了从指定的ProtoC标志中对预处理参数的访问。PG*唯一指定的参数是“ output_path”，模块的buildContext利用该参数来指定其输出路径。\npg*允许通过MutateParams InitOption突变参数。通过在此处传递ParamMutator函数，可以在PGG工作流开始之前修改或验证这些KV键值对。\n特定语言的子包 Language-Specific Subpackages 虽然是用Go实现的，但PG力求在它能做的事情上与语言无关。因此，除了预先生成的基本描述符类型外，PG对protoc-gen-go（PGG）包没有依赖性。然而，每种语言的protoc-plugin所引入的许多细微差别是可以被概括的。例如，PGG包的命名、导入路径和输出路径是proto包名、go_package文件选项和传递给protoc的参数的复杂互动。虽然PG*的核心API不应该用许多特定语言的方法来重载，但可以提供子包，对参数和实体进行操作以得出适当的结果。\nPG*目前实现了pgsgo子包，为针对Go语言的插件提供这些工具。未来的子包计划支持各种语言。\n开始编写你的插件 一个简单的插件 延申 参考链接 使用protoc-gen-star 编写的插件 protoc-gen-gotag protoc-gen-validate protoc-gen-fuzz protoc-gen-mock 其他 Writing a protoc plugin with google.golang.org/protobuf https://github.com/favadi/protoc-go-inject-tag ","permalink":"https://czyt.tech/post/writing-a-protoc-plugin-using-protoc-gen-star/","summary":"预备知识 需要安装的软件 protoc golang go 软件包 github.com/lyft/protoc-gen-star 插件调用步骤 protoc，PB编译器，使用一组标志（记录在protoc -h下）进行配置，并将一组文件作为参数交给它。在这种情况下，I标志可以被多次指定，是它在proto文件中用于导入依赖关系的查找路径。默认情况下，官方描述符protos已经被包含在内。\nmyplugin_out 告诉 protoc 使用 protoc-gen-myplugin protoc-plugin。这些插件会从系统的 PATH 环境变量中自动解析，或者可以用另一个标志明确指定。官方的protoc-plugins (例如，protoc-gen-python) 已经在protoc注册了。该标志的值是特定于特定插件的，但 :\u0026hellip;/generated 后缀除外。这个后缀表示protoc将把该包生成的文件放在哪个根目录下（相对于当前工作目录）。然而，这个生成的输出目录不会传播给 protoc-gen-myplugin，所以它需要在标志的左边重复。PG* 通过一个 output_path 参数支持这一点。\nprotoc 解析传入的 proto 文件，确保它们在语法上是正确的，并加载任何导入的依赖项。它将这些文件和依赖关系转换成描述符 (它们本身就是 PB 消息)，并创建一个 CodeGeneratorRequest (又是一个 PB)。protoc 将这个请求序列化，然后执行每个配置的 protoc-plugin，通过 stdin 发送有效载荷。\nprotoc-gen-myplugin 启动，接收请求的有效载荷，并将其解密。一个基于 PG* 的 protoc-plugin 有两个阶段。首先，PG* 对从 protoc 收到的 CodeGeneratorRequest 进行解密，并为每个文件和其包含的所有实体创建一个完全连接的抽象语法树 (AST)。为这个插件指定的任何参数也会被解析，以便以后使用。\n当这一步完成后，PG*就会执行任何注册的模块，把构建的AST交给它。模块可以被写成生成人工制品（例如，文件），或者只是对所提供的图进行某种形式的验证而没有任何其他副作用。模块在针对PB的操作方面提供了极大的灵活性。\n一旦所有的模块都被运行，PG*会将任何自定义的工件写入文件系统，或者将生成器特定的工件序列化为CodeGeneratorResponse并将数据发送到其stdout。这整个流程看起来像这样。\nfoo.proto → protoc → CodeGeneratorRequest → protoc-gen-myplugin → CodeGeneratorResponse → protoc → foo.pb.go 假设插件名称为diy,则需要编译程序为protoc-gen-diy，并将程序加入系统Path变量，通过下面的命令调用插件。\nprotoc -I .","title":"使用protoc-gen-star编写protoc插件"},{"content":"dllImport的入口点问题 通过Dependencies查询Dll对应方法的EntryPoint\n然后在dllimport的attribute中显式申明EntryPoint\n[DllImport(\u0026#34;demo.dll\u0026#34;, SetLastError = true,EntryPoint =\u0026#34;??0DemoManager@EcgParser@Gfeit@@AEAA@XZ\u0026#34;)] public static extern IntPtr DemoManager(); 导入类方法的问题 最好的方式还是使用C++构造wrapper，然后通过windowsApi的方式调用Pinvoke\n参考链接 swig nuget\nswig\nC++/C# interoperability\nWorking with C++ Interface Classes from C#\nCall function in unmanaged DLL from C# and pass custom data types [Marshal]\nSWIG and C#\nExample for SWIG to wrap C++ library in .Net 6\n","permalink":"https://czyt.tech/post/csharp-dll-import-memo/","summary":"dllImport的入口点问题 通过Dependencies查询Dll对应方法的EntryPoint\n然后在dllimport的attribute中显式申明EntryPoint\n[DllImport(\u0026#34;demo.dll\u0026#34;, SetLastError = true,EntryPoint =\u0026#34;??0DemoManager@EcgParser@Gfeit@@AEAA@XZ\u0026#34;)] public static extern IntPtr DemoManager(); 导入类方法的问题 最好的方式还是使用C++构造wrapper，然后通过windowsApi的方式调用Pinvoke\n参考链接 swig nuget\nswig\nC++/C# interoperability\nWorking with C++ Interface Classes from C#\nCall function in unmanaged DLL from C# and pass custom data types [Marshal]\nSWIG and C#\nExample for SWIG to wrap C++ library in .Net 6","title":"C# dllimport 备忘录"},{"content":"源地址 tailscale仓库\n完整代码如下\n// Copyright (c) 2022 Tailscale Inc \u0026amp; AUTHORS All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package singleflight provides a duplicate function call suppression // mechanism. // // This is a Tailscale fork of Go\u0026#39;s singleflight package which has had several // homes in the past: // // - https://github.com/golang/go/commit/61d3b2db6292581fc07a3767ec23ec94ad6100d1 // - https://github.com/golang/groupcache/tree/master/singleflight // - https://pkg.go.dev/golang.org/x/sync/singleflight // // This fork adds generics. package singleflight // import \u0026#34;tailscale.com/util/singleflight\u0026#34; import ( \u0026#34;bytes\u0026#34; \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;runtime/debug\u0026#34; \u0026#34;sync\u0026#34; ) // errGoexit indicates the runtime.Goexit was called in // the user given function. var errGoexit = errors.New(\u0026#34;runtime.Goexit was called\u0026#34;) // A panicError is an arbitrary value recovered from a panic // with the stack trace during the execution of given function. type panicError struct { value interface{} stack []byte } // Error implements error interface. func (p *panicError) Error() string { return fmt.Sprintf(\u0026#34;%v\\n\\n%s\u0026#34;, p.value, p.stack) } func newPanicError(v interface{}) error { stack := debug.Stack() // The first line of the stack trace is of the form \u0026#34;goroutine N [status]:\u0026#34; // but by the time the panic reaches Do the goroutine may no longer exist // and its status will have changed. Trim out the misleading line. if line := bytes.IndexByte(stack[:], \u0026#39;\\n\u0026#39;); line \u0026gt;= 0 { stack = stack[line+1:] } return \u0026amp;panicError{value: v, stack: stack} } // call is an in-flight or completed singleflight.Do call type call[V any] struct { wg sync.WaitGroup // These fields are written once before the WaitGroup is done // and are only read after the WaitGroup is done. val V err error // forgotten indicates whether Forget was called with this call\u0026#39;s key // while the call was still in flight. forgotten bool // These fields are read and written with the singleflight // mutex held before the WaitGroup is done, and are read but // not written after the WaitGroup is done. dups int chans []chan\u0026lt;- Result[V] } // Group represents a class of work and forms a namespace in // which units of work can be executed with duplicate suppression. type Group[K comparable, V any] struct { mu sync.Mutex // protects m m map[K]*call[V] // lazily initialized } // Result holds the results of Do, so they can be passed // on a channel. type Result[V any] struct { Val V Err error Shared bool } // Do executes and returns the results of the given function, making // sure that only one execution is in-flight for a given key at a // time. If a duplicate comes in, the duplicate caller waits for the // original to complete and receives the same results. // The return value shared indicates whether v was given to multiple callers. func (g *Group[K, V]) Do(key K, fn func() (V, error)) (v V, err error, shared bool) { g.mu.Lock() if g.m == nil { g.m = make(map[K]*call[V]) } if c, ok := g.m[key]; ok { c.dups++ g.mu.Unlock() c.wg.Wait() if e, ok := c.err.(*panicError); ok { panic(e) } else if c.err == errGoexit { runtime.Goexit() } return c.val, c.err, true } c := new(call[V]) c.wg.Add(1) g.m[key] = c g.mu.Unlock() g.doCall(c, key, fn) return c.val, c.err, c.dups \u0026gt; 0 } // DoChan is like Do but returns a channel that will receive the // results when they are ready. // // The returned channel will not be closed. func (g *Group[K, V]) DoChan(key K, fn func() (V, error)) \u0026lt;-chan Result[V] { ch := make(chan Result[V], 1) g.mu.Lock() if g.m == nil { g.m = make(map[K]*call[V]) } if c, ok := g.m[key]; ok { c.dups++ c.chans = append(c.chans, ch) g.mu.Unlock() return ch } c := \u0026amp;call[V]{chans: []chan\u0026lt;- Result[V]{ch}} c.wg.Add(1) g.m[key] = c g.mu.Unlock() go g.doCall(c, key, fn) return ch } // doCall handles the single call for a key. func (g *Group[K, V]) doCall(c *call[V], key K, fn func() (V, error)) { normalReturn := false recovered := false // use double-defer to distinguish panic from runtime.Goexit, // more details see https://golang.org/cl/134395 defer func() { // the given function invoked runtime.Goexit if !normalReturn \u0026amp;\u0026amp; !recovered { c.err = errGoexit } c.wg.Done() g.mu.Lock() defer g.mu.Unlock() if !c.forgotten { delete(g.m, key) } if e, ok := c.err.(*panicError); ok { // In order to prevent the waiting channels from being blocked forever, // needs to ensure that this panic cannot be recovered. if len(c.chans) \u0026gt; 0 { go panic(e) select {} // Keep this goroutine around so that it will appear in the crash dump. } else { panic(e) } } else if c.err == errGoexit { // Already in the process of goexit, no need to call again } else { // Normal return for _, ch := range c.chans { ch \u0026lt;- Result[V]{c.val, c.err, c.dups \u0026gt; 0} } } }() func() { defer func() { if !normalReturn { // Ideally, we would wait to take a stack trace until we\u0026#39;ve determined // whether this is a panic or a runtime.Goexit. // // Unfortunately, the only way we can distinguish the two is to see // whether the recover stopped the goroutine from terminating, and by // the time we know that, the part of the stack trace relevant to the // panic has been discarded. if r := recover(); r != nil { c.err = newPanicError(r) } } }() c.val, c.err = fn() normalReturn = true }() if !normalReturn { recovered = true } } // Forget tells the singleflight to forget about a key. Future calls // to Do for this key will call the function rather than waiting for // an earlier call to complete. func (g *Group[K, V]) Forget(key K) { g.mu.Lock() if c, ok := g.m[key]; ok { c.forgotten = true } delete(g.m, key) g.mu.Unlock() } ","permalink":"https://czyt.tech/post/generic-singleflight-by-tailscale/","summary":"源地址 tailscale仓库\n完整代码如下\n// Copyright (c) 2022 Tailscale Inc \u0026amp; AUTHORS All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package singleflight provides a duplicate function call suppression // mechanism.","title":"tailscale的泛型SingleFlight"},{"content":"安装 系统信息\n使用命令安装 yay -S postgresql\n初始化及配置 启用数据库服务 sudo systemctl enable --now postgresql\n开启数据库服务 sudo systemctl start postgresql\n初始化数据 su - postgres -c \u0026quot;initdb --locale en_US.UTF-8 -D '/var/lib/postgres/data'\u0026quot;\n查询配置文件路径\nsu - postgres [postgres@homeserver ~]$ ls data [postgres@homeserver ~]$ psql psql (14.5) 输入 \u0026#34;help\u0026#34; 来获取帮助信息. postgres=# SHOW config_file; config_file ---------------------------------------- /var/lib/postgres/data/postgresql.conf (1 行记录) 修改监听 修改配置/var/lib/postgres/data/postgresql.conf 文件中的listen_addresses = '*'监听所有地址，重启服务sudo systemctl restart postgresql生效。\n允许远程访问 修改配置文件同级目录下的pg_hba.conf,添加一行\n# TYPE DATABASE USER CIDR-ADDRESS METHOD\rhost all all 0.0.0.0/0\tmd5 默认pg只允许本机通过密码认证登录，修改为上面内容后即可以对任意IP访问进行密码验证。\n修改默认密码 登录sudo -u postgres psql\n使用password修改\npostgres=# \\password postgres\rEnter new password: \u0026lt;new-password\u0026gt;\rpostgres=# \\q 或者使用sql语句 ALTER USER postgres PASSWORD '\u0026lt;new-password\u0026gt;';\n浓缩为一行 sudo -u postgres psql -c \u0026quot;ALTER USER postgres PASSWORD '\u0026lt;new-password\u0026gt;';\u0026quot;\n","permalink":"https://czyt.tech/post/install-postgresql-on-rasp3b/","summary":"安装 系统信息\n使用命令安装 yay -S postgresql\n初始化及配置 启用数据库服务 sudo systemctl enable --now postgresql\n开启数据库服务 sudo systemctl start postgresql\n初始化数据 su - postgres -c \u0026quot;initdb --locale en_US.UTF-8 -D '/var/lib/postgres/data'\u0026quot;\n查询配置文件路径\nsu - postgres [postgres@homeserver ~]$ ls data [postgres@homeserver ~]$ psql psql (14.5) 输入 \u0026#34;help\u0026#34; 来获取帮助信息. postgres=# SHOW config_file; config_file ---------------------------------------- /var/lib/postgres/data/postgresql.conf (1 行记录) 修改监听 修改配置/var/lib/postgres/data/postgresql.conf 文件中的listen_addresses = '*'监听所有地址，重启服务sudo systemctl restart postgresql生效。\n允许远程访问 修改配置文件同级目录下的pg_hba.conf,添加一行\n# TYPE DATABASE USER CIDR-ADDRESS METHOD\rhost all all 0.","title":"Rasp3b 安装Postgresql"},{"content":"环境准备 nuget包 Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Binder Microsoft.Extensions.Configuration.Json (当需要从Json文件添加记录时，安装此nuget包) Microsoft.Extensions.Configuration.EnvironmentVariables (当需要从环境变量添加记录时，安装此nuget包) C#开发环境 visual studio 2019 + visual Code 示例代码 // See https://aka.ms/new-console-template for more information using Microsoft.Extensions.Configuration; using Microsoft.Extensions.Configuration.Json; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); ConfigurationBuilder configurationBuilder = new ConfigurationBuilder(); IConfiguration c = configurationBuilder.AddJsonFile(\u0026#34;appsettings.json\u0026#34;).AddEnvironmentVariables().Build(); var k = c.GetRequiredSection(\u0026#34;Settings\u0026#34;).Get\u0026lt;Settings\u0026gt;().KeyOne; var n = 1; public class NestedSettings { public string Message { get; set; } = null!; } public class Settings { public int KeyOne { get; set; } public bool KeyTwo { get; set; } public NestedSettings KeyThree { get; set; } = null!; } JSON 文件 (appsettings.json.ps:配置文件属性建议按下面属性设置)\n{ \u0026#34;Settings\u0026#34;: { \u0026#34;KeyOne\u0026#34;: 1, \u0026#34;KeyTwo\u0026#34;: true, \u0026#34;KeyThree\u0026#34;: { \u0026#34;Message\u0026#34;: \u0026#34;Oh, that\u0026#39;s nice...\u0026#34; } } } 常见问题 如何自定义配置项目的Key 使用 [ConfigurationKeyName]属性进行设置，如下面的配置：\npublic class ApiConfig { [ConfigurationKeyName(\u0026#34;endpoint\u0026#34;)] public string Endpoint { get; set; } } 配置热重载 配置热重载可以使用ChangeToken.OnChange来实现，参考微软官方文档 下面是一个例子：\n// AddJsonFile(\u0026#34;appsettings.json\u0026#34;, false, true) 添加json时候设置重载(reloadOnChange) ChangeToken.OnChange( () =\u0026gt; GetReloadToken(), // listener to token change () =\u0026gt; { Thread.Sleep(250); // load config logic Load(); }); 参考 stackoverflow ","permalink":"https://czyt.tech/post/dotnet6-load-config-from-json/","summary":"环境准备 nuget包 Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Binder Microsoft.Extensions.Configuration.Json (当需要从Json文件添加记录时，安装此nuget包) Microsoft.Extensions.Configuration.EnvironmentVariables (当需要从环境变量添加记录时，安装此nuget包) C#开发环境 visual studio 2019 + visual Code 示例代码 // See https://aka.ms/new-console-template for more information using Microsoft.Extensions.Configuration; using Microsoft.Extensions.Configuration.Json; Console.WriteLine(\u0026#34;Hello, World!\u0026#34;); ConfigurationBuilder configurationBuilder = new ConfigurationBuilder(); IConfiguration c = configurationBuilder.AddJsonFile(\u0026#34;appsettings.json\u0026#34;).AddEnvironmentVariables().Build(); var k = c.GetRequiredSection(\u0026#34;Settings\u0026#34;).Get\u0026lt;Settings\u0026gt;().KeyOne; var n = 1; public class NestedSettings { public string Message { get; set; } = null!; } public class Settings { public int KeyOne { get; set; } public bool KeyTwo { get; set; } public NestedSettings KeyThree { get; set; } = null!","title":".NET6 从JSON获取配置"},{"content":"Windows XP时代 Xp时代提供的是通过注册表来自定义shell\n设置所有用户的shell 注册表键HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell\n设置当前用户的shell注册表键 HKEY_Current_User\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell\n注册表键值类型 REG_SZ\n值修改为你要自定义为shell的程序的完整路径。\n在windows10下使用该技巧可能会出现黑屏的现象，参考stackoverflow的回答\nSimply replacing the \u0026ldquo;explorer.exe\u0026rdquo; (HKLM\\SOFTWARE\\Microsoft\\Window NT\\Winlogon\\Shell) with a custom app location provided a black screen.\nA much simpler way, and it works great, was to create a BATCH script to call the custom app through elevated powershell\u0026hellip;\npowershell -nologo -noprofile -executionpolicy bypass -command \u0026#34;start-process -verb \u0026#39;runas\u0026#39; -filepath \u0026lt;full path of custom app executable\u0026gt;\u0026#34; By replacing \u0026ldquo;explorer.exe\u0026rdquo; with this batch script I was able to successfully create a kiosk style lockdown under Windows 10 PRO with a non-UWP app.\nWindows 10 时代 Windows 10 提供了Shell Launcher（展台模式），也可以实现替换shell的目的。详细的操作，请参考微软官网文档。但是只支持专业版、企业版和教育版。\n​ 在 Windows 客户端中可用的 Shell Launcher v1 中，只能将 Windows 桌面应用程序指定为替换 shell。在 Windows 10 版本 1809+ /Windows 11 中提供的 Shell Launcher v2 中，还可以将 UWP 应用指定为替换 shell。 若要在 Windows 10 版本 1809 中使用 Shell Launcher v2 ，需要安装 KB4551853 更新。\n实现更安全的展台体验，我们建议你对设备进行以下配置更改：\n若要实现更安全的展台体验，我们建议你对设备进行以下配置更改：\n将设备置于平板电脑模式\n如果你希望用户能够使用触摸（屏幕）键盘，请转到设置 \u0026gt; 系统 \u0026gt; 平板电脑模式，然后选中开。\n在登录屏幕上隐藏轻松使用功能。\n转到控制面板 \u0026gt; 轻松使用 \u0026gt; 轻松使用设置中心，并关闭所有辅助工具。\n禁用硬件电源按钮。\n转到电源选项 \u0026gt; 选择电源按钮的功能、将设置更改为不执行任何操作，然后保存更改。\n从登录屏幕中删除电源按钮。\n转到计算机配置 \u0026gt; Windows 设置 \u0026gt; 安全设置 \u0026gt; 本地策略 \u0026gt; 安全选项 \u0026gt; 关机: 允许系统在未登录的情况下关闭，然后选择已禁用。\n禁用相机。\n转到设置 \u0026gt; 隐私 \u0026gt; 相机，然后关闭允许应用使用我的相机。\n关闭锁屏界面上的应用通知。\n转到组策略编辑器 \u0026gt; 计算机配置 \u0026gt; 管理模板系统登录关闭锁屏界面上的应用通知。\n禁用可移动媒体。\n转到组策略编辑器 \u0026gt; 计算机配置 \u0026gt; 管理模板系统设备安装设备安装限制。 查看设备安装限制中提供的策略设置，以确保这些设置适用于你的情况。\n参考链接 Display custom legal notices \u0026amp; startup messages in Windows 10\nDifferent Shells for Different Users\nSet up a kiosk on Windows 10 Pro, Enterprise, or Education\n如何替换Windows的Shell\nHow to run an application as shell replacement on Windows 10 Enterprise\n","permalink":"https://czyt.tech/post/a-brief-talk-about-replace-windows-default-shell-with-wpf/","summary":"Windows XP时代 Xp时代提供的是通过注册表来自定义shell\n设置所有用户的shell 注册表键HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell\n设置当前用户的shell注册表键 HKEY_Current_User\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell\n注册表键值类型 REG_SZ\n值修改为你要自定义为shell的程序的完整路径。\n在windows10下使用该技巧可能会出现黑屏的现象，参考stackoverflow的回答\nSimply replacing the \u0026ldquo;explorer.exe\u0026rdquo; (HKLM\\SOFTWARE\\Microsoft\\Window NT\\Winlogon\\Shell) with a custom app location provided a black screen.\nA much simpler way, and it works great, was to create a BATCH script to call the custom app through elevated powershell\u0026hellip;\npowershell -nologo -noprofile -executionpolicy bypass -command \u0026#34;start-process -verb \u0026#39;runas\u0026#39; -filepath \u0026lt;full path of custom app executable\u0026gt;\u0026#34; By replacing \u0026ldquo;explorer.exe\u0026rdquo; with this batch script I was able to successfully create a kiosk style lockdown under Windows 10 PRO with a non-UWP app.","title":"浅谈windows默认Shell的替换"},{"content":"问题描述 使用go正常编译了Linux下的程序，放到服务器上报错\n./app: /lib64/libc.so.6: version `GLIBC_2.34\u0026#39; not found (required by ./app) 解决 Google了下，发现相同的Issue,于是通过go env检查本机golang运行环境，发现CGO默认启用而且程序也不涉及CGO相关的东西，于是设置CGO参数为关闭。然后编译程序\nCGO_ENABLED=\u0026quot;0\u0026quot; go build -v\n重新上传，运行OK.\n","permalink":"https://czyt.tech/post/golang-default-cgo-flags-caused-glibc-missing-error/","summary":"问题描述 使用go正常编译了Linux下的程序，放到服务器上报错\n./app: /lib64/libc.so.6: version `GLIBC_2.34\u0026#39; not found (required by ./app) 解决 Google了下，发现相同的Issue,于是通过go env检查本机golang运行环境，发现CGO默认启用而且程序也不涉及CGO相关的东西，于是设置CGO参数为关闭。然后编译程序\nCGO_ENABLED=\u0026quot;0\u0026quot; go build -v\n重新上传，运行OK.","title":"Golang 默认的CGO参数编译导致的GLIBC错误"},{"content":"安装步骤 查询系统版本 执行命令lsb_release -a返回下面的内容\nLSB Version:\t:core-4.1-amd64:core-4.1-noarch\rDistributor ID:\tAlibabaCloud\rDescription:\tAlibaba Cloud Linux release 3 (Soaring Falcon) Release:\t3\rCodename:\tSoaringFalcon 添加yum源 创建repo文件etc/yum.repos.d/mongodb.repo并输入下面的内容，这里安装的mongodb版本为6.0,其他版本请参考官网（配置偶数版本，奇数版不适合生产使用）。\n官网的配置文件如下：\n[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用这个配置文件是安装不了的，需要修改$releasever为相应的版本，Alibaba Cloud Linux 3修改为8 （设置一个releasever的环境变量也许也可以，没有验证。）即可。即下面的样子\n[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用命令 yum -y install mongodb-org 安装即可。另外阿里云也提供了国内的镜像源，上面的配置文件可以修改为下面的内容，也是等效的。\n[mongodb-org-6.0] name=MongoDB Repository baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 参考链接 如何在Alibaba Cloud Linux 3上安装MongoDB 5.0 ","permalink":"https://czyt.tech/post/install-mongodb-on-alibaba-cloud-linux/","summary":"安装步骤 查询系统版本 执行命令lsb_release -a返回下面的内容\nLSB Version:\t:core-4.1-amd64:core-4.1-noarch\rDistributor ID:\tAlibabaCloud\rDescription:\tAlibaba Cloud Linux release 3 (Soaring Falcon) Release:\t3\rCodename:\tSoaringFalcon 添加yum源 创建repo文件etc/yum.repos.d/mongodb.repo并输入下面的内容，这里安装的mongodb版本为6.0,其他版本请参考官网（配置偶数版本，奇数版不适合生产使用）。\n官网的配置文件如下：\n[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用这个配置文件是安装不了的，需要修改$releasever为相应的版本，Alibaba Cloud Linux 3修改为8 （设置一个releasever的环境变量也许也可以，没有验证。）即可。即下面的样子\n[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用命令 yum -y install mongodb-org 安装即可。另外阿里云也提供了国内的镜像源，上面的配置文件可以修改为下面的内容，也是等效的。\n[mongodb-org-6.0] name=MongoDB Repository baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 参考链接 如何在Alibaba Cloud Linux 3上安装MongoDB 5.0 ","title":"在Alibaba Cloud Linux上安装MongoDB"},{"content":"摘自互联网 原文\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func main() { var ( dnsResolverIP = \u0026#34;8.8.8.8:53\u0026#34; // Google DNS resolver. dnsResolverProto = \u0026#34;udp\u0026#34; // Protocol to use for the DNS resolver dnsResolverTimeoutMs = 5000 // Timeout (ms) for the DNS resolver (optional) ) dialer := \u0026amp;net.Dialer{ Resolver: \u0026amp;net.Resolver{ PreferGo: true, Dial: func(ctx context.Context, network, address string) (net.Conn, error) { d := net.Dialer{ Timeout: time.Duration(dnsResolverTimeoutMs) * time.Millisecond, } return d.DialContext(ctx, dnsResolverProto, dnsResolverIP) }, }, } dialContext := func(ctx context.Context, network, addr string) (net.Conn, error) { return dialer.DialContext(ctx, network, addr) } http.DefaultTransport.(*http.Transport).DialContext = dialContext httpClient := \u0026amp;http.Client{} // Testing the new HTTP client with the custom DNS resolver. resp, err := httpClient.Get(\u0026#34;https://www.violetnorth.com\u0026#34;) if err != nil { log.Fatalln(err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { log.Fatalln(err) } log.Println(string(body)) ","permalink":"https://czyt.tech/post/golang-http-use-custom-dns/","summary":"摘自互联网 原文\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;time\u0026#34; ) func main() { var ( dnsResolverIP = \u0026#34;8.8.8.8:53\u0026#34; // Google DNS resolver. dnsResolverProto = \u0026#34;udp\u0026#34; // Protocol to use for the DNS resolver dnsResolverTimeoutMs = 5000 // Timeout (ms) for the DNS resolver (optional) ) dialer := \u0026amp;net.Dialer{ Resolver: \u0026amp;net.Resolver{ PreferGo: true, Dial: func(ctx context.Context, network, address string) (net.Conn, error) { d := net.Dialer{ Timeout: time.Duration(dnsResolverTimeoutMs) * time.","title":"golang http客户端使用自定义dns"},{"content":"自定义接口返回内容 正常的响应序列化逻辑通过Response Encoder实现。\n错误的序列化逻辑通过ErrorEncoder实现。\n注意：自定义Encoder后，可能会遇到零值字段被忽略的情况，可以参考这个issue。具体的解决办法是\nproto定义返回内容，然后将生成的类型在encoder中使用。\n简单代码大致如下：\nproto定义\nimport \u0026#34;google/protobuf/any.proto\u0026#34;; // BaseResponse is the base response message BaseResponse{ int32 code = 1 [json_name = \u0026#34;code\u0026#34;]; google.protobuf.Any data = 2 [json_name = \u0026#34;data\u0026#34;]; } go代码\nfunc CustomResponseEncoder() http.ServerOption { return http.ResponseEncoder(func(w http.ResponseWriter, r *http.Request, i interface{}) error { reply := \u0026amp;v1.BaseResponse{ Code: 0, } if m, ok := i.(proto.Message); ok { payload, err := anypb.New(m) if err != nil { return err } reply.Data = payload } //reply := \u0026amp;Response{ //\tCode: 0, //\tData: i, //} codec := encoding.GetCodec(\u0026#34;json\u0026#34;) data, err := codec.Marshal(reply) if err != nil { return err } w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;) w.Write(data) return nil }) } 需要注意的是如果涉及enum但现有接口返回是int的情况，需要把官方的json codec拷贝出来在MarshalOptions添加一个选项\nMarshalOptions = protojson.MarshalOptions{ EmitUnpopulated: true, UseEnumNumbers: true, 然后通过下面的代码注册json的codec即可使返回的enum使用数值而不是字符串。\nimport \u0026#34;github.com/go-kratos/kratos/v2/encoding\u0026#34; func init() { encoding.RegisterCodec(codec{}) } 有个问题就是返回的json中会多出\u0026quot;@type\u0026quot;: \u0026quot;type.googleapis.comxxxxx\u0026quot;这样的一个字段。\n通过Context取得信息 Server端取JWT中的key数据\nfunc getPayloadFromCtx(ctx context.Context, partName string) (string, error) { if claims, ok := jwt.FromContext(ctx); ok { if m, ok := claims.(jwtV4.MapClaims); ok { if v, ok := m[partName].(string); ok { return v, nil } } } return \u0026#34;\u0026#34;, errors.New(\u0026#34;invalid Jwt\u0026#34;) } middleware中，还可以将context转换为http.Transport获取更多的信息。\nif tr, ok := transport.FromServerContext(ctx); ok { // 可以取header等信息 if hr, ok := tr.(*http.Transport); ok { // 可以取request等信息 } } 日志脱敏与过滤 需要对日志进行脱敏和过滤，使用 kratos的日志过滤\nh := NewHelper( NewFilter(logger, // 等级过滤 FilterLevel(log.LevelError), // 按key遮蔽 FilterKey(\u0026#34;username\u0026#34;), // 按value遮蔽 FilterValue(\u0026#34;hello\u0026#34;), // 自定义过滤函数 FilterFunc( func (level Level, keyvals ...interface{}) bool { if level == LevelWarn { return true } for i := 0; i \u0026lt; len(keyvals); i++ { if keyvals[i] == \u0026#34;password\u0026#34; { keyvals[i+1] = fuzzyStr } } return false } ), ), ) FilterFunc(f func(level Level, keyvals ...interface{}) bool) 使用自定义的函数来对日志进行处理，keyvals里为key和对应的value，按照奇偶进行读取即可 TODO:按奇偶进行读取的意思\n一个接口对应多个httpPath 下面是官网的文档中的一个例子（原文）：\nsyntax = \u0026#34;proto3\u0026#34;; package helloworld.v1; import \u0026#34;google/api/annotations.proto\u0026#34;; option go_package = \u0026#34;github.com/go-kratos/service-layout/api/helloworld/v1;v1\u0026#34;; option java_multiple_files = true; option java_package = \u0026#34;dev.kratos.api.helloworld.v1\u0026#34;; option java_outer_classname = \u0026#34;HelloWorldProtoV1\u0026#34;; // The greeting service definition. service Greeter { // Sends a greeting rpc SayHello (HelloRequest) returns (HelloReply) { option (google.api.http) = { // 定义一个 GET 接口，并且把 name 映射到 HelloRequest get: \u0026#34;/helloworld/{name}\u0026#34;, // 可以添加附加接口 additional_bindings { // 定义一个 POST 接口，并且把 body 映射到 HelloRequest post: \u0026#34;/v1/greeter/say_hello\u0026#34;, body: \u0026#34;*\u0026#34;, } }; } } // The request message containing the user\u0026#39;s name. message HelloRequest { string name = 1; } // The response message containing the greetings message HelloReply { string message = 1; } 支持文件上传 因为protobuf官方限制，并不能通过protobuf生成http服务，需要创建相关逻辑，参考example中的实现：\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/go-kratos/kratos/v2\u0026#34; \u0026#34;github.com/go-kratos/kratos/v2/transport/http\u0026#34; ) func uploadFile(ctx http.Context) error { req := ctx.Request() fileName := req.FormValue(\u0026#34;name\u0026#34;) file, handler, err := req.FormFile(\u0026#34;file\u0026#34;) if err != nil { return err } defer file.Close() f, err := os.OpenFile(handler.Filename, os.O_WRONLY|os.O_CREATE, 0o666) if err != nil { return err } defer f.Close() _, _ = io.Copy(f, file) return ctx.String(200, \u0026#34;File \u0026#34;+fileName+\u0026#34; Uploaded successfully\u0026#34;) } func main() { httpSrv := http.NewServer( http.Address(\u0026#34;:8000\u0026#34;), ) route := httpSrv.Route(\u0026#34;/\u0026#34;) route.POST(\u0026#34;/upload\u0026#34;, uploadFile) app := kratos.New( kratos.Name(\u0026#34;upload\u0026#34;), kratos.Server( httpSrv, ), ) if err := app.Run(); err != nil { log.Fatal(err) } } 参考 https://freshman.tech/file-upload-golang/\n静态文件托管 官方例子\npackage main import ( \u0026#34;embed\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;github.com/go-kratos/kratos/v2\u0026#34; transhttp \u0026#34;github.com/go-kratos/kratos/v2/transport/http\u0026#34; \u0026#34;github.com/gorilla/mux\u0026#34; ) //go:embed assets/* var f embed.FS func main() { router := mux.NewRouter() // example: /assets/index.html router.PathPrefix(\u0026#34;/assets\u0026#34;).Handler(http.FileServer(http.FS(f))) httpSrv := transhttp.NewServer(transhttp.Address(\u0026#34;:8000\u0026#34;)) httpSrv.HandlePrefix(\u0026#34;/\u0026#34;, router) app := kratos.New( kratos.Name(\u0026#34;static\u0026#34;), kratos.Server( httpSrv, ), ) if err := app.Run(); err != nil { log.Fatal(err) } } 自定义路由继承middleware 对于一些从proto不支持的场景，如文件上传等，就需要自定义路由，但是鉴权和认证可能是需要的，这些功能在kratos中是通过middleware来实现的。我们可以通过下面的方式来将middleware同样应用于自定义的路由。(代码未作优化，只是为了演示具体的实现)\nfunc NewHTTPServer(c *conf.Server, greeter *service.GreeterService, logger log.Logger) *http.Server { var opts = []http.ServerOption{ http.Middleware( recovery.Recovery(), nop.UserAgent(), ), } if c.Http.Network != \u0026#34;\u0026#34; { opts = append(opts, http.Network(c.Http.Network)) } if c.Http.Addr != \u0026#34;\u0026#34; { opts = append(opts, http.Address(c.Http.Addr)) } if c.Http.Timeout != nil { opts = append(opts, http.Timeout(c.Http.Timeout.AsDuration())) } srv := http.NewServer(opts...) // 自定义路由，添加一个echo的功能 route := srv.Route(\u0026#34;/\u0026#34;) route.GET(\u0026#34;/v1/echo/{requester}\u0026#34;, EchoHandler) v1.RegisterGreeterHTTPServer(srv, greeter) return srv } // 请求体定义 type echoRequest struct { Requester string `json:\u0026#34;requester\u0026#34;` } // 响应 type echoResponse struct { Resp string `json:\u0026#34;resp\u0026#34;` } // 消息处理实现逻辑 func echo(ctx context.Context, req *echoRequest) (*echoResponse, error) { return \u0026amp;echoResponse{Resp: fmt.Sprintf(\u0026#34;hello,%s\u0026#34;, req.Requester)}, nil } // middware处理 func EchoHandler(ctx http.Context) error { var in echoRequest if err := ctx.BindQuery(\u0026amp;in); err != nil { return err } if err := ctx.BindVars(\u0026amp;in); err != nil { return err } h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) { return echo(ctx, req.(*echoRequest)) }) resp, err := h(ctx, \u0026amp;in) if err != nil { return err } reply := resp.(*echoResponse) return ctx.Result(200, reply) } middleware代码如下\nfunc UserAgent() middleware.Middleware { return func(handler middleware.Handler) middleware.Handler { return func(ctx context.Context, req interface{}) (reply interface{}, err error) { if tr, ok := transport.FromServerContext(ctx); ok { userAgent:=tr.RequestHeader().Get(userAgent) if strings.EqualFold(userAgent,\u0026#34;kratos-nb\u0026#34;) { return nil, errors.New(403, \u0026#34;INVALID-UA\u0026#34;, \u0026#34;user agent is invalid\u0026#34;) } } return handler(ctx, req) } } } Service和Biz层的区分 Service 层：协议转换，比如grpc转http 和一些简单的validate。\nBiz层：具体的Biz业务，跟协议无关。\n集成实时的metric statsviz 官方网站说明\nVisualise Go program runtime metrics data in real time: heap, objects, goroutines, GC pauses, scheduler, etc. in your browser.\n实时可视化Go程序运行时度量数据：在浏览器中的堆、对象、goroutine、GC暂停、调度程序等。\n在服务的入口添加下面的代码\nimports( .... \u0026#34;github.com/arl/statsviz\u0026#34; .... ) func newApp(logger log.Logger, gs *grpc.Server, hs *http.Server) *kratos.App { statsviz.RegisterDefault() .... } 然后在服务监听地址(默认是http://localhost:8000)后面加上/debug/statsviz/访问即可。\n类似的还有：\nhttps://github.com/felixge/fgtrace\nfgtrace is an experimental profiler/tracer that is capturing wallclock timelines for each goroutine. It\u0026rsquo;s very similar to the Chrome profiler.\n⚠️ fgtrace may cause noticeable stop-the-world pauses in your applications. It is intended for dev and testing environments for now.\n服务端跨域配置 参考官方项目\nhttp.Filter(handlers.CORS( handlers.AllowedHeaders([]string{\u0026#34;X-Requested-With\u0026#34;, \u0026#34;Content-Type\u0026#34;, \u0026#34;Authorization\u0026#34;}),// 允许的header handlers.AllowedMethods([]string{\u0026#34;GET\u0026#34;, \u0026#34;POST\u0026#34;, \u0026#34;PUT\u0026#34;, \u0026#34;HEAD\u0026#34;, \u0026#34;OPTIONS\u0026#34;}),// 允许方法 handlers.AllowedOrigins([]string{\u0026#34;*\u0026#34;}),//允许的请求源 )), 需要引用包\u0026quot;github.com/gorilla/handlers\u0026quot;\n服务https监听开关 在conf.proto 上的Http配置添加下面的内容\nimport \u0026#34;google/protobuf/wrappers.proto\u0026#34;; message HTTP { string network = 1; string addr = 2; ....... google.protobuf.BoolValue use_tls_bind = 4; google.protobuf.StringValue server_cert_file = 5; google.protobuf.StringValue server_cert_key = 6; } 然后在http server的代码中添加配置的解析\nif c.Http.UseTlsBind != nil { if c.Http.UseTlsBind.Value { certFilePath := c.Http.ServerCertFile.Value certKeyPath := c.Http.ServerCertKey.Value if certFilePath != \u0026#34;\u0026#34; \u0026amp;\u0026amp; certKeyPath != \u0026#34;\u0026#34; { tlsConfig, err := LoadTLSConfig(certFilePath, certKeyPath) if err == nil { opts = append(opts, http.TLSConfig(tlsConfig)) } } } } .... // LoadTLSConfig 从文件加载tlsConfig func LoadTLSConfig(certFilePath string, certKeyFilePath string) (*tls.Config, error) { cer, err := tls.LoadX509KeyPair(certFilePath, certKeyFilePath) if err != nil { return nil, err } return \u0026amp;tls.Config{ Certificates: []tls.Certificate{cer}, }, nil } 集成Casbin Casbin官网 https://casbin.io\n参考代码 https://github.com/go-kratos/examples/tree/main/casbin\n需要补充的几点：\n因为kratos的url生成的是类似于\\api\\v1\\userInfo\\{userid}样式的，所以在policy中需要使用函数keyMatch3来进行policies的匹配，比如我的model.conf文件中就是这样(rbac with domain)\n[request_definition] r = sub, dom, obj, act [policy_definition] p = sub, dom, obj, act [role_definition] g = _, _, _ [policy_effect] e = some(where (p.eft == allow)) [matchers] m = g(r.sub, p.sub, r.dom) \u0026amp;\u0026amp; r.dom == p.dom \u0026amp;\u0026amp; (regexMatch(r.obj , p.obj) || keyMatch3(r.obj , p.obj)) \u0026amp;\u0026amp; r.act == p.act 官网贴出的casbin支持的函数有下面这些：\n函数 参数1 参数2 示例 keyMatch 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 * 模式下，例如 /alice_data/* keymatch_model.conf/keymatch_policy.csv keyGet 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 * 模式下，例如 /alice_data/* keyget_model.conf/keymatch_policy.csv keyMatch2 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 : 模式下，例如 /alice_data/:resource keymatch2_model.conf/keymatch2_policy.csv keyGet2 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 : 模式下，例如 /alice_data/:resource keyget_model.conf/keymatch_policy.csv keyMatch3 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 {} 模式下，例如 /alice_data/{resource} https://github.com/casbin/casbin/blob/277c1a2b85698272f764d71a94d2595a8d425915/util/builtin_operators_test.go#L171-L196 keyMatch4 一个URL 路径，例如 /alice_data/resource1 一个URL 路径或 {} 模式下，例如 /alice_data//{id}/book/{id} https://github.com/casbin/casbin/blob/277c1a2b85698272f764d71a94d2595a8d425915/util/builtin_operators_test.go#L208-L222 regexMatch 任意字符串 正则表达式模式 keymatch_model.conf/keymatch_policy.csv ipMatch 一个 IP 地址，例如 192.168.2.123 一个 IP 地址或一个 CIDR ，例如192.168.2.0/24 ipmatch_model.conf/ipmatch_policy.csv globMatch 类似路径的 /alice_data/resource1 一个全局模式，例如 /alice_data/* kratos支持除rbac之外的，还有其他的模型。如rabac with domain等等。参考官网。\n中间件中取得当前访问的url\nif header, ok := transport.FromServerContext(ctx); ok { // 断言成HTTP的Transport可以拿到特殊信息 if hr, ok := header.(*http.Transport); ok { su.Method = hr.Request().Method su.Path = hr.Request().RequestURI } } 参考 https://github.com/Permify/permify https://github.com/open-policy-agent/opa 复用proto 在业务中可能需要根据职责划分多个服务，这些服务可能部分proto结构是需要复用的。\nproto单独放在一个repo，使用protoc生成go文件并发布包（业务不敏感情况下，推荐）。\nproto放在项目api目录内，使用protoc生成go文件并通过go replace做go mod的替换。go mod发布建议发布proto的顶层目录，下面按版本进行管理，这样后面也较为容易维护。\nxxxx.tech/api v0.0.0 replace ( xxxx.tech/api v0.0.0 =\u0026gt; ./api/xxxx/api ) 系统初始化任务 逻辑抽象 初始化的逻辑，简单抽象为是否初始化判断和初始化，可以使用下面的流程图来表示\n接口简化为下面的代码\ntype processor interface { // IsInit 是否需要初始化 IsInit() bool // Apply 初始化数据 Apply(seeds []interface{}) error } 参数注入 kratos 3.5.3 添加了BeforeStart、 BeforeStop、 AfterStart、 AfterStop四个Option，我们可以通过这些来进行参数注入。\nhs := http.NewServer() gs := grpc.NewServer() app := New( Name(\u0026#34;kratos\u0026#34;), Version(\u0026#34;v1.0.0\u0026#34;), Server(hs, gs), BeforeStart(func(_ context.Context) error { t.Log(\u0026#34;BeforeStart...\u0026#34;) return nil }), BeforeStop(func(_ context.Context) error { t.Log(\u0026#34;BeforeStop...\u0026#34;) return nil }), AfterStart(func(_ context.Context) error { t.Log(\u0026#34;AfterStart...\u0026#34;) return nil }), AfterStop(func(_ context.Context) error { t.Log(\u0026#34;AfterStop...\u0026#34;) return nil }), Registrar(\u0026amp;mockRegistry{service: make(map[string]*registry.ServiceInstance)}), ) time.AfterFunc(time.Second, func() { _ = app.Stop() }) if err := app.Run(); err != nil { t.Fatal(err) } buf connect-go 安装相关工具\n$ go install github.com/bufbuild/buf/cmd/buf@latest $ go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest $ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest $ go install github.com/bufbuild/connect-go/cmd/protoc-gen-connect-go@latest 参考 三分钟小课堂 - 如何控制接口返回值 ","permalink":"https://czyt.tech/post/go-kratos-usage-memo/","summary":"自定义接口返回内容 正常的响应序列化逻辑通过Response Encoder实现。\n错误的序列化逻辑通过ErrorEncoder实现。\n注意：自定义Encoder后，可能会遇到零值字段被忽略的情况，可以参考这个issue。具体的解决办法是\nproto定义返回内容，然后将生成的类型在encoder中使用。\n简单代码大致如下：\nproto定义\nimport \u0026#34;google/protobuf/any.proto\u0026#34;; // BaseResponse is the base response message BaseResponse{ int32 code = 1 [json_name = \u0026#34;code\u0026#34;]; google.protobuf.Any data = 2 [json_name = \u0026#34;data\u0026#34;]; } go代码\nfunc CustomResponseEncoder() http.ServerOption { return http.ResponseEncoder(func(w http.ResponseWriter, r *http.Request, i interface{}) error { reply := \u0026amp;v1.BaseResponse{ Code: 0, } if m, ok := i.(proto.Message); ok { payload, err := anypb.New(m) if err != nil { return err } reply.","title":"go-kratos使用备忘"},{"content":"Oneof 如果您有许多字段的消息，并且最多可以同时设置一个字段，则可以使用Oneof功能来执行此行为并保存内存。一个字段就像常规字段一样，除了单一共享内存中的所有字段，最多可以同时设置一个字段。设置Oneof的任何成员都会自动清除所有其他成员。\n​\tGoogle protobuf 文档#Oneof\n示例proto 创建protoOneof.proto 的proto文件\nsyntax = \u0026#34;proto3\u0026#34;; package oneof_test; option go_package =\u0026#39;.;oneof\u0026#39;; message WeiboUser{ string user_id = 1; string user_nick = 2; } message DouyinUser{ string auth_token = 1; string nick_name = 2; } message User{ oneof user_source{ string weibo_url = 1; string douyin_url = 2; } oneof user_info{ WeiboUser weibo_user_info = 3; DouyinUser douyin_user_info = 4; } } 使用命令生成go代码\nprotoc --proto_path=. --go_out=paths=source_relative:./oneof ./protoOneof.proto 生成的protoOneof.pb.go代码如下：\n// Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.28.0 // protoc v3.21.3 // source: protoOneof.proto package oneof import ( protoreflect \u0026#34;google.golang.org/protobuf/reflect/protoreflect\u0026#34; protoimpl \u0026#34;google.golang.org/protobuf/runtime/protoimpl\u0026#34; reflect \u0026#34;reflect\u0026#34; sync \u0026#34;sync\u0026#34; ) const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) ) type WeiboUser struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields UserId string `protobuf:\u0026#34;bytes,1,opt,name=user_id,json=userId,proto3\u0026#34; json:\u0026#34;user_id,omitempty\u0026#34;` UserNick string `protobuf:\u0026#34;bytes,2,opt,name=user_nick,json=userNick,proto3\u0026#34; json:\u0026#34;user_nick,omitempty\u0026#34;` } func (x *WeiboUser) Reset() { *x = WeiboUser{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_protoOneof_proto_msgTypes[0] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *WeiboUser) String() string { return protoimpl.X.MessageStringOf(x) } func (*WeiboUser) ProtoMessage() {} func (x *WeiboUser) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_protoOneof_proto_msgTypes[0] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use WeiboUser.ProtoReflect.Descriptor instead. func (*WeiboUser) Descriptor() ([]byte, []int) { return file_protoOneof_proto_rawDescGZIP(), []int{0} } func (x *WeiboUser) GetUserId() string { if x != nil { return x.UserId } return \u0026#34;\u0026#34; } func (x *WeiboUser) GetUserNick() string { if x != nil { return x.UserNick } return \u0026#34;\u0026#34; } type DouyinUser struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields AuthToken string `protobuf:\u0026#34;bytes,1,opt,name=auth_token,json=authToken,proto3\u0026#34; json:\u0026#34;auth_token,omitempty\u0026#34;` NickName string `protobuf:\u0026#34;bytes,2,opt,name=nick_name,json=nickName,proto3\u0026#34; json:\u0026#34;nick_name,omitempty\u0026#34;` } func (x *DouyinUser) Reset() { *x = DouyinUser{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_protoOneof_proto_msgTypes[1] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *DouyinUser) String() string { return protoimpl.X.MessageStringOf(x) } func (*DouyinUser) ProtoMessage() {} func (x *DouyinUser) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_protoOneof_proto_msgTypes[1] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use DouyinUser.ProtoReflect.Descriptor instead. func (*DouyinUser) Descriptor() ([]byte, []int) { return file_protoOneof_proto_rawDescGZIP(), []int{1} } func (x *DouyinUser) GetAuthToken() string { if x != nil { return x.AuthToken } return \u0026#34;\u0026#34; } func (x *DouyinUser) GetNickName() string { if x != nil { return x.NickName } return \u0026#34;\u0026#34; } type User struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields // Types that are assignable to UserSource: //\t*User_WeiboUrl //\t*User_DouyinUrl UserSource isUser_UserSource `protobuf_oneof:\u0026#34;user_source\u0026#34;` // Types that are assignable to UserInfo: //\t*User_WeiboUserInfo //\t*User_DouyinUserInfo UserInfo isUser_UserInfo `protobuf_oneof:\u0026#34;user_info\u0026#34;` } func (x *User) Reset() { *x = User{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_protoOneof_proto_msgTypes[2] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *User) String() string { return protoimpl.X.MessageStringOf(x) } func (*User) ProtoMessage() {} func (x *User) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_protoOneof_proto_msgTypes[2] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use User.ProtoReflect.Descriptor instead. func (*User) Descriptor() ([]byte, []int) { return file_protoOneof_proto_rawDescGZIP(), []int{2} } func (m *User) GetUserSource() isUser_UserSource { if m != nil { return m.UserSource } return nil } func (x *User) GetWeiboUrl() string { if x, ok := x.GetUserSource().(*User_WeiboUrl); ok { return x.WeiboUrl } return \u0026#34;\u0026#34; } func (x *User) GetDouyinUrl() string { if x, ok := x.GetUserSource().(*User_DouyinUrl); ok { return x.DouyinUrl } return \u0026#34;\u0026#34; } func (m *User) GetUserInfo() isUser_UserInfo { if m != nil { return m.UserInfo } return nil } func (x *User) GetWeiboUserInfo() *WeiboUser { if x, ok := x.GetUserInfo().(*User_WeiboUserInfo); ok { return x.WeiboUserInfo } return nil } func (x *User) GetDouyinUserInfo() *DouyinUser { if x, ok := x.GetUserInfo().(*User_DouyinUserInfo); ok { return x.DouyinUserInfo } return nil } type isUser_UserSource interface { isUser_UserSource() } type User_WeiboUrl struct { WeiboUrl string `protobuf:\u0026#34;bytes,1,opt,name=weibo_url,json=weiboUrl,proto3,oneof\u0026#34;` } type User_DouyinUrl struct { DouyinUrl string `protobuf:\u0026#34;bytes,2,opt,name=douyin_url,json=douyinUrl,proto3,oneof\u0026#34;` } func (*User_WeiboUrl) isUser_UserSource() {} func (*User_DouyinUrl) isUser_UserSource() {} type isUser_UserInfo interface { isUser_UserInfo() } type User_WeiboUserInfo struct { WeiboUserInfo *WeiboUser `protobuf:\u0026#34;bytes,3,opt,name=weibo_user_info,json=weiboUserInfo,proto3,oneof\u0026#34;` } type User_DouyinUserInfo struct { DouyinUserInfo *DouyinUser `protobuf:\u0026#34;bytes,4,opt,name=douyin_user_info,json=douyinUserInfo,proto3,oneof\u0026#34;` } func (*User_WeiboUserInfo) isUser_UserInfo() {} func (*User_DouyinUserInfo) isUser_UserInfo() {} var File_protoOneof_proto protoreflect.FileDescriptor var file_protoOneof_proto_rawDesc = []byte{ 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x4f, 0x6e, 0x65, 0x6f, 0x66, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x22, 0x41, 0x0a, 0x09, 0x57, 0x65, 0x69, 0x62, 0x6f, 0x55, 0x73, 0x65, 0x72, 0x12, 0x17, 0x0a, 0x07, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x75, 0x73, 0x65, 0x72, 0x49, 0x64, 0x12, 0x1b, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6e, 0x69, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x4e, 0x69, 0x63, 0x6b, 0x22, 0x48, 0x0a, 0x0a, 0x44, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x0a, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x61, 0x75, 0x74, 0x68, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x1b, 0x0a, 0x09, 0x6e, 0x69, 0x63, 0x6b, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x6e, 0x69, 0x63, 0x6b, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0xe7, 0x01, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x1d, 0x0a, 0x09, 0x77, 0x65, 0x69, 0x62, 0x6f, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x08, 0x77, 0x65, 0x69, 0x62, 0x6f, 0x55, 0x72, 0x6c, 0x12, 0x1f, 0x0a, 0x0a, 0x64, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x09, 0x64, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x55, 0x72, 0x6c, 0x12, 0x3f, 0x0a, 0x0f, 0x77, 0x65, 0x69, 0x62, 0x6f, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x15, 0x2e, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x57, 0x65, 0x69, 0x62, 0x6f, 0x55, 0x73, 0x65, 0x72, 0x48, 0x01, 0x52, 0x0d, 0x77, 0x65, 0x69, 0x62, 0x6f, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x42, 0x0a, 0x10, 0x64, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x5f, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x44, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x48, 0x01, 0x52, 0x0e, 0x64, 0x6f, 0x75, 0x79, 0x69, 0x6e, 0x55, 0x73, 0x65, 0x72, 0x49, 0x6e, 0x66, 0x6f, 0x42, 0x0d, 0x0a, 0x0b, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x42, 0x0b, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x42, 0x09, 0x5a, 0x07, 0x2e, 0x3b, 0x6f, 0x6e, 0x65, 0x6f, 0x66, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33, } var ( file_protoOneof_proto_rawDescOnce sync.Once file_protoOneof_proto_rawDescData = file_protoOneof_proto_rawDesc ) func file_protoOneof_proto_rawDescGZIP() []byte { file_protoOneof_proto_rawDescOnce.Do(func() { file_protoOneof_proto_rawDescData = protoimpl.X.CompressGZIP(file_protoOneof_proto_rawDescData) }) return file_protoOneof_proto_rawDescData } var file_protoOneof_proto_msgTypes = make([]protoimpl.MessageInfo, 3) var file_protoOneof_proto_goTypes = []interface{}{ (*WeiboUser)(nil), // 0: oneof_test.WeiboUser (*DouyinUser)(nil), // 1: oneof_test.DouyinUser (*User)(nil), // 2: oneof_test.User } var file_protoOneof_proto_depIdxs = []int32{ 0, // 0: oneof_test.User.weibo_user_info:type_name -\u0026gt; oneof_test.WeiboUser 1, // 1: oneof_test.User.douyin_user_info:type_name -\u0026gt; oneof_test.DouyinUser 2, // [2:2] is the sub-list for method output_type 2, // [2:2] is the sub-list for method input_type 2, // [2:2] is the sub-list for extension type_name 2, // [2:2] is the sub-list for extension extendee 0, // [0:2] is the sub-list for field type_name } func init() { file_protoOneof_proto_init() } func file_protoOneof_proto_init() { if File_protoOneof_proto != nil { return } if !protoimpl.UnsafeEnabled { file_protoOneof_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*WeiboUser); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } file_protoOneof_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*DouyinUser); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } file_protoOneof_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*User); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } } file_protoOneof_proto_msgTypes[2].OneofWrappers = []interface{}{ (*User_WeiboUrl)(nil), (*User_DouyinUrl)(nil), (*User_WeiboUserInfo)(nil), (*User_DouyinUserInfo)(nil), } type x struct{} out := protoimpl.TypeBuilder{ File: protoimpl.DescBuilder{ GoPackagePath: reflect.TypeOf(x{}).PkgPath(), RawDescriptor: file_protoOneof_proto_rawDesc, NumEnums: 0, NumMessages: 3, NumExtensions: 0, NumServices: 0, }, GoTypes: file_protoOneof_proto_goTypes, DependencyIndexes: file_protoOneof_proto_depIdxs, MessageInfos: file_protoOneof_proto_msgTypes, }.Build() File_protoOneof_proto = out.File file_protoOneof_proto_rawDesc = nil file_protoOneof_proto_goTypes = nil file_protoOneof_proto_depIdxs = nil } 测试代码：\nuser := User{ UserSource: \u0026amp;User_WeiboUrl{WeiboUrl: \u0026#34;https://weibo.com\u0026#34;}, UserInfo: \u0026amp;User_WeiboUserInfo{ WeiboUserInfo: \u0026amp;WeiboUser{ UserId: \u0026#34;66666\u0026#34;, UserNick: \u0026#34;czyt\u0026#34;, }, }, } // set user source will overwrite the value before user.UserSource = \u0026amp;User_DouyinUrl{DouyinUrl: \u0026#34;https://douyin.com\u0026#34;} marshal, err := json.Marshal(user) if err != nil { log.Fatalln(err) } log.Println(string(marshal)) FieldMask 使用FieldMask 需要引用google/protobuf/field_mask.proto。参考Google的文档。\nFieldMask 是一个 protobuf 消息，包含一个名为 paths 的字段，用于指定用于指定读取操作返回或更新操作修改的字段。空的FieldMask默认应用到全部字段。\nmessage FieldMask { repeated string paths = 1; } 示例proto 定义一个proto\nimport \u0026#34;google/protobuf/field_mask.proto\u0026#34;; // 更新用户请求 message UpdateUserReq{ string id = 1; User payload = 2; optional google.protobuf.FieldMask update_mask = 3; } 生成消息体\n// 更新用户请求 type UpdateUserReq struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Id string `protobuf:\u0026#34;bytes,1,opt,name=id,proto3\u0026#34; json:\u0026#34;id,omitempty\u0026#34;` Payload *User `protobuf:\u0026#34;bytes,2,opt,name=payload,proto3\u0026#34; json:\u0026#34;payload,omitempty\u0026#34;` UpdateMask *fieldmaskpb.FieldMask `protobuf:\u0026#34;bytes,3,opt,name=update_mask,json=updateMask,proto3,oneof\u0026#34; json:\u0026#34;update_mask,omitempty\u0026#34;` } func (x *UpdateUserReq) Reset() { *x = UpdateUserReq{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_v1_user_reqresp_proto_msgTypes[4] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *UpdateUserReq) String() string { return protoimpl.X.MessageStringOf(x) } func (*UpdateUserReq) ProtoMessage() {} func (x *UpdateUserReq) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_v1_user_reqresp_proto_msgTypes[4] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use UpdateUserReq.ProtoReflect.Descriptor instead. func (*UpdateUserReq) Descriptor() ([]byte, []int) { return file_v1_user_reqresp_proto_rawDescGZIP(), []int{4} } func (x *UpdateUserReq) GetId() string { if x != nil { return x.Id } return \u0026#34;\u0026#34; } func (x *UpdateUserReq) GetPayload() *User { if x != nil { return x.Payload } return nil } func (x *UpdateUserReq) GetUpdateMask() *fieldmaskpb.FieldMask { if x != nil { return x.UpdateMask } return nil } 使用\nfor _, v := range req.UpdateMask.GetPaths() { log.Info(\u0026#34;v: \u0026#34;, v) } 更多API，参考 https://pkg.go.dev/google.golang.org/protobuf/types/known/fieldmaskpb\nHttp中使用的注意事项 参考 issue：https://github.com/golang/protobuf/issues/1273\nField masks have special syntax in the JSON encoding: https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#json-encoding-of-field-masks\nThanks, it looks grammar has changed. In gateway(v1) can be used as flow: bug fix\n\u0026#34;update_mask\u0026#34;: { \u0026#34;paths\u0026#34;: [ \u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34; ] } ```bug fix but in gateway(v2) need to update the field format ```json \u0026#34;update_mask\u0026#34;: \u0026#34;hello,world\u0026#34; Json Mapping protobuf 3 的int64``fixed64 uint64类型在json序列化时会被转换为string。 Proto3支持JSON中的规范编码，从而更容易在系统之间共享数据。在下表中以类型为基础描述编码。如果在JSON编码的数据中缺少一个值，或者其值为null，则将其解释为解析为协议缓冲区的适当默认值。如果一个字段在协议缓冲区中具有默认值，则默认情况下将在JSON编码的数据中省略它以节省空间。实现可以提供在JSON编码输出中发射具有默认值的字段的选项。\nproto3 JSON JSON example Notes message object {\u0026quot;fooBar\u0026quot;: v, \u0026quot;g\u0026quot;: null, …} Generates JSON objects. Message field names are mapped to lowerCamelCase and become JSON object keys. If the json_name field option is specified, the specified value will be used as the key instead. Parsers accept both the lowerCamelCase name (or the one specified by the json_name option) and the original proto field name. null is an accepted value for all field types and treated as the default value of the corresponding field type. enum string \u0026quot;FOO_BAR\u0026quot; The name of the enum value as specified in proto is used. Parsers accept both enum names and integer values. map\u0026lt;K,V\u0026gt; object {\u0026quot;k\u0026quot;: v, …} All keys are converted to strings. repeated V array [v, …] null is accepted as the empty list []. bool true, false true, false string string \u0026quot;Hello World!\u0026quot; bytes base64 string \u0026quot;YWJjMTIzIT8kKiYoKSctPUB+\u0026quot; JSON value will be the data encoded as a string using standard base64 encoding with paddings. Either standard or URL-safe base64 encoding with/without paddings are accepted. int32, fixed32, uint32 number 1, -10, 0 JSON value will be a decimal number. Either numbers or strings are accepted. int64, fixed64, uint64 string \u0026quot;1\u0026quot;, \u0026quot;-10\u0026quot; JSON value will be a decimal string. Either numbers or strings are accepted. float, double number 1.1, -10.0, 0, \u0026quot;NaN\u0026quot;, \u0026quot;Infinity\u0026quot; JSON value will be a number or one of the special string values \u0026ldquo;NaN\u0026rdquo;, \u0026ldquo;Infinity\u0026rdquo;, and \u0026ldquo;-Infinity\u0026rdquo;. Either numbers or strings are accepted. Exponent notation is also accepted. -0 is considered equivalent to 0. Any object {\u0026quot;@type\u0026quot;: \u0026quot;url\u0026quot;, \u0026quot;f\u0026quot;: v, … } If the Any contains a value that has a special JSON mapping, it will be converted as follows: {\u0026quot;@type\u0026quot;: xxx, \u0026quot;value\u0026quot;: yyy}. Otherwise, the value will be converted into a JSON object, and the \u0026quot;@type\u0026quot; field will be inserted to indicate the actual data type. Timestamp string \u0026quot;1972-01-01T10:00:20.021Z\u0026quot; Uses RFC 3339, where generated output will always be Z-normalized and uses 0, 3, 6 or 9 fractional digits. Offsets other than \u0026ldquo;Z\u0026rdquo; are also accepted. Duration string \u0026quot;1.000340012s\u0026quot;, \u0026quot;1s\u0026quot; Generated output always contains 0, 3, 6, or 9 fractional digits, depending on required precision, followed by the suffix \u0026ldquo;s\u0026rdquo;. Accepted are any fractional digits (also none) as long as they fit into nano-seconds precision and the suffix \u0026ldquo;s\u0026rdquo; is required. Struct object { … } Any JSON object. See struct.proto. Wrapper types various types 2, \u0026quot;2\u0026quot;, \u0026quot;foo\u0026quot;, true, \u0026quot;true\u0026quot;, null, 0, … Wrappers use the same representation in JSON as the wrapped primitive type, except that null is allowed and preserved during data conversion and transfer. FieldMask string \u0026quot;f.fooBar,h\u0026quot; See field_mask.proto. ListValue array [foo, bar, …] Value value Any JSON value. Check google.protobuf.Value for details. NullValue null JSON null Empty object {} An empty JSON object 参考 https://developers.google.com/protocol-buffers/docs/proto3#json\nprotobuf 自定义Go字段的json Tag 官方文档 说明\nA proto3 JSON implementation may provide the following options:\nEmit fields with default values: Fields with default values are omitted by default in proto3 JSON output. An implementation may provide an option to override this behavior and output fields with their default values. Ignore unknown fields: Proto3 JSON parser should reject unknown fields by default but may provide an option to ignore unknown fields in parsing. Use proto field name instead of lowerCamelCase name: By default proto3 JSON printer should convert the field name to lowerCamelCase and use that as the JSON name. An implementation may provide an option to use proto field name as the JSON name instead. Proto3 JSON parsers are required to accept both the converted lowerCamelCase name and the proto field name. Emit enum values as integers instead of strings: The name of an enum value is used by default in JSON output. An option may be provided to use the numeric value of the enum value instead. proto\nmessage Blog { int64 id = 1 [json_name = \u0026#34;uid\u0026#34;]; string titleName = 2; string author_name = 3[json_name = \u0026#34;author_name\u0026#34;]; string img = 4; int64 CountNum = 5; } 生成go文件\ntype Blog struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Id int64 `protobuf:\u0026#34;varint,1,opt,name=id,json=uid,proto3\u0026#34; json:\u0026#34;id,omitempty\u0026#34;` TitleName string `protobuf:\u0026#34;bytes,2,opt,name=titleName,proto3\u0026#34; json:\u0026#34;titleName,omitempty\u0026#34;` AuthorName string `protobuf:\u0026#34;bytes,3,opt,name=author_name,json=author_name,proto3\u0026#34; json:\u0026#34;author_name,omitempty\u0026#34;` Img string `protobuf:\u0026#34;bytes,4,opt,name=img,proto3\u0026#34; json:\u0026#34;img,omitempty\u0026#34;` CountNum int64 `protobuf:\u0026#34;varint,5,opt,name=CountNum,proto3\u0026#34; json:\u0026#34;CountNum,omitempty\u0026#34;` } goland的实时模板如下,方便快速使用\n[json_name = \u0026#34;$FIELD_NAME$\u0026#34;$END$] 设置参考下图 参考 protocol buffers官方文档 https://github.com/mennanov/fieldmask-utils Netflix实用API设计：Protobuf FieldMask实践 part1 part2 go-kratos HTTP方法支持以及FieldMask的使用简介 Protobuf and Go: Handling Oneof Field type google api design: update protobuf中使用oneof、WrapValue和FieldMask Protocol Buffers V3中文语法指南 ","permalink":"https://czyt.tech/post/protobuf-golang-litle-notes/","summary":"Oneof 如果您有许多字段的消息，并且最多可以同时设置一个字段，则可以使用Oneof功能来执行此行为并保存内存。一个字段就像常规字段一样，除了单一共享内存中的所有字段，最多可以同时设置一个字段。设置Oneof的任何成员都会自动清除所有其他成员。\n​\tGoogle protobuf 文档#Oneof\n示例proto 创建protoOneof.proto 的proto文件\nsyntax = \u0026#34;proto3\u0026#34;; package oneof_test; option go_package =\u0026#39;.;oneof\u0026#39;; message WeiboUser{ string user_id = 1; string user_nick = 2; } message DouyinUser{ string auth_token = 1; string nick_name = 2; } message User{ oneof user_source{ string weibo_url = 1; string douyin_url = 2; } oneof user_info{ WeiboUser weibo_user_info = 3; DouyinUser douyin_user_info = 4; } } 使用命令生成go代码\nprotoc --proto_path=. --go_out=paths=source_relative:./oneof ./protoOneof.proto 生成的protoOneof.pb.go代码如下：","title":"Protobuf golang小札"},{"content":"使用gotests可以很方便的生成表驱动测试代码，表驱动测试的具体内容，请参考go官方的wiki。下面是具体的使用方法。\n安装 使用下面命令进行安装\ngo install github.com/cweill/gotests/gotests@latest 如果是go1.16之前的版本，可以使用命令 go get -u github.com/cweill/gotests/...来进行安装。\n使用 gotests支持的参数如下：\nUsage of C:\\Users\\czyt\\go\\bin\\gotests.exe:\r-all\rgenerate tests for all functions and methods\r-excl string\rregexp. generate tests for functions and methods that don\u0026#39;t match. Takes precedence over -only, -exported, and -all\r-exported\rgenerate tests for exported functions and methods. Takes precedence over -only and -all\r-i print test inputs in error messages\r-nosubtests\rdisable generating tests using the Go 1.7 subtests feature\r-only string\rregexp. generate tests for functions and methods that match only. Takes precedence over -all\r-parallel\renable generating parallel subtests\r-template string\roptional. Specify custom test code templates, e.g. testify. This can also be set via environment variable GOTESTS_TEMPLATE\r-template_dir string\roptional. Path to a directory containing custom test code templates. Takes precedence over -template. This can also be set via environment variable GOTESTS_TEMPLATE_DIR\r-template_params string\rread external parameters to template by json with stdin\r-template_params_file string\rread external parameters to template by json with file\r-w write output to (test) files instead of stdout 小试牛刀 新建一个go文件，命名为greeter.go\npackage greeter import \u0026#34;fmt\u0026#34; func Greeter(user string) string { return fmt.Sprintf(\u0026#34;您好啊！%s\u0026#34;,user) } 使用gotests -all -w greeter.go 生成测试文件greeter_test.go，文件内容如下：\npackage greeter import \u0026#34;testing\u0026#34; func TestGreeter(t *testing.T) { type args struct { user string } tests := []struct { name string args args want string }{ // TODO: Add test cases. } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := Greeter(tt.args.user); got != tt.want { t.Errorf(\u0026#34;Greeter() = %v, want %v\u0026#34;, got, tt.want) } }) } } ","permalink":"https://czyt.tech/post/use-gotests-to-generate-table-driven-tests/","summary":"使用gotests可以很方便的生成表驱动测试代码，表驱动测试的具体内容，请参考go官方的wiki。下面是具体的使用方法。\n安装 使用下面命令进行安装\ngo install github.com/cweill/gotests/gotests@latest 如果是go1.16之前的版本，可以使用命令 go get -u github.com/cweill/gotests/...来进行安装。\n使用 gotests支持的参数如下：\nUsage of C:\\Users\\czyt\\go\\bin\\gotests.exe:\r-all\rgenerate tests for all functions and methods\r-excl string\rregexp. generate tests for functions and methods that don\u0026#39;t match. Takes precedence over -only, -exported, and -all\r-exported\rgenerate tests for exported functions and methods. Takes precedence over -only and -all\r-i print test inputs in error messages\r-nosubtests\rdisable generating tests using the Go 1.","title":"使用gotests生成表驱动测试"},{"content":"最近要使用ETCD，脚本根据官方GitHub脚本修改而来\n#!/usr/bin/bash ETCD_VER=v3.5.4 # choose either URL GOOGLE_URL=https://storage.googleapis.com/etcd GITHUB_URL=https://fastgit.czyt.tech/https://github.com/etcd-io/etcd/releases/download ARCH=linux-arm64 DOWNLOAD_URL=${GITHUB_URL} INSTALL_DIR=/opt/etcd rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz rm -rf ${INSTALL_DIR} \u0026amp;\u0026amp; mkdir -p ${INSTALL_DIR} curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-${ARCH}.tar.gz -o /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz tar xzvf /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz -C ${INSTALL_DIR} --strip-components=1 rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz ${INSTALL_DIR}/etcd --version ${INSTALL_DIR}/etcdctl version ${INSTALL_DIR}/etcdutl version 其中的ARCH请根据实际情况修改。\n参考 https://etcd.io/docs/v3.5/demo/ ","permalink":"https://czyt.tech/post/etcd-install-script/","summary":"最近要使用ETCD，脚本根据官方GitHub脚本修改而来\n#!/usr/bin/bash ETCD_VER=v3.5.4 # choose either URL GOOGLE_URL=https://storage.googleapis.com/etcd GITHUB_URL=https://fastgit.czyt.tech/https://github.com/etcd-io/etcd/releases/download ARCH=linux-arm64 DOWNLOAD_URL=${GITHUB_URL} INSTALL_DIR=/opt/etcd rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz rm -rf ${INSTALL_DIR} \u0026amp;\u0026amp; mkdir -p ${INSTALL_DIR} curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-${ARCH}.tar.gz -o /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz tar xzvf /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz -C ${INSTALL_DIR} --strip-components=1 rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz ${INSTALL_DIR}/etcd --version ${INSTALL_DIR}/etcdctl version ${INSTALL_DIR}/etcdutl version 其中的ARCH请根据实际情况修改。\n参考 https://etcd.io/docs/v3.5/demo/ ","title":"ETCD一键安装脚本"},{"content":"安装 库的说明\nExpr package provides an engine that can compile and evaluate expressions. An expression is a one-liner that returns a value (mostly, but not limited to, booleans). It is designed for simplicity, speed and safety.\nThe purpose of the package is to allow users to use expressions inside configuration for more complex logic. It is a perfect candidate for the foundation of a business rule engine.\n安装\ngo get -u /github.com/antonmedv/expr 如果是gomod模式，则需要定义为\ngithub.com/antonmedv/expr latest 基础使用 表达式计算 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) func main() { env := map[string]interface{}{ \u0026#34;foo\u0026#34;: 1, \u0026#34;bar\u0026#34;: 2, } out, err := expr.Eval(\u0026#34;foo + bar\u0026#34;, env) if err != nil { panic(err) } fmt.Print(out) } 代码片段编译执行 传入基本类型\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) func main() { env := map[string]interface{}{ \u0026#34;greet\u0026#34;: \u0026#34;Hello, %v!\u0026#34;, \u0026#34;names\u0026#34;: []string{\u0026#34;world\u0026#34;, \u0026#34;you\u0026#34;}, \u0026#34;sprintf\u0026#34;: fmt.Sprintf, // You can pass any functions. } code := `sprintf(greet, names[0])` // Compile code into bytecode. This step can be done once and program may be reused. // Specify environment for type check. program, err := expr.Compile(code, expr.Env(env)) if err != nil { panic(err) } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } 传入自定义结构体\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) type Env struct { Tweets []Tweet } // Methods defined on such struct will be functions. func (Env) Format(t time.Time) string { return t.Format(time.RFC822) } type Tweet struct { Text string Date time.Time } func main() { code := `map(filter(Tweets, {len(.Text) \u0026gt; 0}), {.Text + Format(.Date)})` // We can use an empty instance of the struct as an environment. program, err := expr.Compile(code, expr.Env(Env{})) if err != nil { panic(err) } env := Env{ Tweets: []Tweet{{\u0026#34;Oh My God!\u0026#34;, time.Now()}, {\u0026#34;How you doin?\u0026#34;, time.Now()}, {\u0026#34;Could I be wearing any more clothes?\u0026#34;, time.Now()}}, } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } 自定义函数 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) func main() { env := map[string]interface{}{ \u0026#34;foo\u0026#34;: 1, \u0026#34;double\u0026#34;: func(i int) int { return i * 2 }, } out, err := expr.Eval(\u0026#34;double(foo)\u0026#34;, env) if err != nil { panic(err) } fmt.Print(out) } 注入对象方法 对象方法必须是导出的\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) type Env struct { Tweets []Tweet } // Methods defined on such struct will be functions. func (Env) Format(t time.Time) string { return t.Format(time.RFC822) } type Tweet struct { Text string Date time.Time } func main() { code := `map(filter(Tweets, {len(.Text) \u0026gt; 0}), {.Text + Format(.Date)})` // We can use an empty instance of the struct as an environment. program, err := expr.Compile(code, expr.Env(Env{})) if err != nil { panic(err) } env := Env{ Tweets: []Tweet{{\u0026#34;Oh My God!\u0026#34;, time.Now()}, {\u0026#34;How you doin?\u0026#34;, time.Now()}, {\u0026#34;Could I be wearing any more clothes?\u0026#34;, time.Now()}}, } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } Fast functions Fast functions(快速函数)可以不使用反射进行调用，这将提高性能，但丢失了参数的类型。只要函数或方法的签名为下面的一种，那么就可以作为Fast functions使用。\nfunc(...interface{}) interface{} func(...interface{}) (interface{}, error) 示例\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) type Env map[string]interface{} func (Env) FastMethod(...interface{}) interface{} { return \u0026#34;Hello, \u0026#34; } func main() { env := Env{ \u0026#34;fast_func\u0026#34;: func(...interface{}) interface{} { return \u0026#34;world\u0026#34; }, } out, err := expr.Eval(\u0026#34;FastMethod() + fast_func()\u0026#34;, env) if err != nil { panic(err) } fmt.Print(out) } 错误返回 如果函数或方法返回非nil的error，那么这个错误将返回给其对应的调用者。\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) func main() { env := map[string]interface{}{ \u0026#34;foo\u0026#34;: -1, \u0026#34;double\u0026#34;: func(i int) (int, error) { if i \u0026lt; 0 { return 0, errors.New(\u0026#34;value cannot be less than zero\u0026#34;) } return i * 2, nil }, } out, err := expr.Eval(\u0026#34;double(foo)\u0026#34;, env) // This `err` will be the one returned from `double` function. // err.Error() == \u0026#34;value cannot be less than zero\u0026#34; if err != nil { panic(err) } fmt.Print(out) } 高阶使用 Operator Override(运算符覆盖) 例如表达式Now().Sub(CreatedAt) 用来计算已经创建了多长时间，你可能想改造成下面这个样子\nNow() - CreatedAt 可以使用expr.Operator来实现运算符覆盖：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; ) func main() { code := `(Now() - CreatedAt).Hours() / 24 / 365` // We can define options before compiling. options := []expr.Option{ expr.Env(Env{}), expr.Operator(\u0026#34;-\u0026#34;, \u0026#34;Sub\u0026#34;), // Override `-` with function `Sub`. } program, err := expr.Compile(code, options...) if err != nil { panic(err) } env := Env{ CreatedAt: time.Date(1987, time.November, 24, 20, 0, 0, 0, time.UTC), } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type Env struct { datetime CreatedAt time.Time } // Functions may be defined on embedded structs as well. type datetime struct{} func (datetime) Now() time.Time { return time.Now() } func (datetime) Sub(a, b time.Time) time.Duration { return a.Sub(b) } Visitor ast包提供了ast.Visitor接口和ast.Walk方法，你可以使用他们来浏览编译程序的ast树。例如，您想要获取所有的变量名。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; \u0026#34;github.com/antonmedv/expr/parser\u0026#34; ) type visitor struct { identifiers []string } func (v *visitor) Enter(node *ast.Node) {} func (v *visitor) Exit(node *ast.Node) { if n, ok := (*node).(*ast.IdentifierNode); ok { v.identifiers = append(v.identifiers, n.Value) } } func main() { tree, err := parser.Parse(\u0026#34;foo + bar\u0026#34;) if err != nil { panic(err) } visitor := \u0026amp;visitor{} ast.Walk(\u0026amp;tree.Node, visitor) fmt.Printf(\u0026#34;%v\u0026#34;, visitor.identifiers) // outputs [foo bar] } Patch 在将 AST 编译为 expr.Compile 函数中的字节码之前，可以应用已实现的访问者。\nprogram, err := expr.Compile(code, expr.Patch(\u0026amp;visitor{})) 这对于您想扩展 Expr 语言的功能的某些边缘情况很有用。 在下一个示例中，我们将用 list[len(list)-1] 替换表达式 list[-1]。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; ) func main() { env := map[string]interface{}{ \u0026#34;list\u0026#34;: []int{1, 2, 3}, } code := `list[-1]` // will output 3 program, err := expr.Compile(code, expr.Env(env), expr.Patch(\u0026amp;patcher{})) if err != nil { panic(err) } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type patcher struct{} func (p *patcher) Enter(_ *ast.Node) {} func (p *patcher) Exit(node *ast.Node) { n, ok := (*node).(*ast.IndexNode) if !ok { return } unary, ok := n.Index.(*ast.UnaryNode) if !ok { return } if unary.Operator == \u0026#34;-\u0026#34; { ast.Patch(\u0026amp;n.Index, \u0026amp;ast.BinaryNode{ Operator: \u0026#34;-\u0026#34;, Left: \u0026amp;ast.BuiltinNode{Name: \u0026#34;len\u0026#34;, Arguments: []ast.Node{n.Node}}, Right: unary.Node, }) } } 对于类型信息也同样奏效。 下面是一个例子将所有的 fmt.Stringer 接口都自动转换为字符串类型的例子。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; ) func main() { code := `Price == \u0026#34;$100\u0026#34;` program, err := expr.Compile(code, expr.Env(Env{}), expr.Patch(\u0026amp;stringerPatcher{})) if err != nil { panic(err) } env := Env{100_00} output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type Env struct { Price Price } type Price int func (p Price) String() string { return fmt.Sprintf(\u0026#34;$%v\u0026#34;, int(p)/100) } var stringer = reflect.TypeOf((*fmt.Stringer)(nil)).Elem() type stringerPatcher struct{} func (p *stringerPatcher) Enter(_ *ast.Node) {} func (p *stringerPatcher) Exit(node *ast.Node) { t := (*node).Type() if t == nil { return } if t.Implements(stringer) { ast.Patch(node, \u0026amp;ast.MethodNode{ Node: *node, Method: \u0026#34;String\u0026#34;, }) } } 性能 Expr 有一堆优化，可以在编译阶段产生更优化的程序。\nIn array value in [\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] 如果 expr 在数组中找到 in 或 not in 表达式，它将被转换为：\nvalue in {\u0026#34;foo\u0026#34;: true, \u0026#34;bar\u0026#34;: true, \u0026#34;baz\u0026#34;: true} Constant folding 具有常量的算术表达式在编译步骤中计算并替换为结果。\n-(2-5)**3-2/(+4-3)+-2 将被编译为单个数字:\n23 所以在表达式中使用一些算术来提高可读性是安全的:\npercentage \u0026gt; 0.3 * 100 因为它将被简化为:\npercentage \u0026gt; 30 In range user.Age in 18..32 将替换为二元运算符:\n18 \u0026lt;= user.Age \u0026amp;\u0026amp; user.Age \u0026lt;= 32 not in 运算符也可以使用.\nConst range 1..10_000 在编译阶段计算的范围，用预先分配的切片来补充。\nConst expr 如果某个函数用 expr.ConstExpr 标记为常量表达式。当所有参数都是常量时，它将被调用结果替换。\nexpr.ConstExpt(\u0026#34;fib\u0026#34;)\rfib(42) 将在编译步骤中替换为 fib(42) 的结果。 运行时无需计算。\nReuse VM 可以在程序的重新运行之间重用虚拟机。 这会稍微提高性能（从 4% 到 40%，具体取决于程序）。\npackage main\rimport (\r\u0026#34;fmt\u0026#34;\r\u0026#34;github.com/antonmedv/expr\u0026#34;\r\u0026#34;github.com/antonmedv/expr/vm\u0026#34;\r)\rfunc main() {\renv := map[string]interface{}{\r\u0026#34;foo\u0026#34;: 1,\r\u0026#34;bar\u0026#34;: 2,\r}\rprogram, err := expr.Compile(\u0026#34;foo + bar\u0026#34;, expr.Env(env))\rif err != nil {\rpanic(err)\r}\r// Reuse this vm instance between runs\rv := vm.VM{}\rout, err := v.Run(program, env)\rif err != nil {\rpanic(err)\r}\rfmt.Print(out)\r} Reduced use of reflect 要从结构中获取字段，从映射中获取值，通过索引获取 expr 使用反射包。 Envs 可以实现 vm.Fetcher 接口，避免使用反射：\ntype Fetcher interface {\rFetch(interface{}) interface{}\r} 当您需要获取字段时，将使用该方法代替反射函数。 如果未找到该字段，则 Fetch 必须返回 nil。 要为您的类型生成 Fetch，请使用 Exprgen。\n语言参考 Expr 包使用特定的语法。 在本文档中，您可以找到所有支持的语法。\n支持的类型 包支持下面的数据类型:\nstrings - 使用单引号或双引号包裹 (e.g. \u0026quot;hello\u0026quot;, 'hello') numbers - e.g. 103, 2.5, .5 arrays - e.g. [1, 2, 3] maps - e.g. {foo: \u0026quot;bar\u0026quot;} booleans - true 和false nil - nil 数字分隔符 整数文字可能包含数字分隔符，以允许数字分组为更清晰的形式进行显示。\n例子：\n10_000_000_000 访问公共属性 可以使用 . 语法访问结构上的公共属性。 如果将数组传递给表达式，请使用 [] 语法访问数组键。\nfoo.Array[0].Value 函数和方法 可以使用 () 调用函数。 . 也可用于调用结构上的方法。\nprice.String() 支持的运算符 本包带支持下面的运算符：\n算数运算符 + (addition) - (subtraction) * (multiplication) / (division) % (modulus) ** (pow) Example:\nlife + universe + everything 比较运算符 == (equal) != (not equal) \u0026lt; (less than) \u0026gt; (greater than) \u0026lt;= (less than or equal to) \u0026gt;= (greater than or equal to) 逻辑运算符 not or ! and or \u0026amp;\u0026amp; or or || Example:\nlife \u0026lt; universe || life \u0026lt; everything 字符串运算符 + (concatenation) matches (regex match) contains (string contains) startsWith (has prefix) endsWith (has suffix) 要测试字符串是否not匹配正则表达式，请结合使用逻辑 not 运算符和 matches 运算符：\nnot (\u0026#34;foo\u0026#34; matches \u0026#34;^b.+\u0026#34;) 您必须使用括号，因为一元运算符 not 优先于二元运算符 matches。\n例子：\n\u0026#39;Arthur\u0026#39; + \u0026#39; \u0026#39; + \u0026#39;Dent\u0026#39; 结果为 Arthur Dent.\n成员操作符 in (包含) not in (不包含) 例子:\nuser.Group in [\u0026#34;human_resources\u0026#34;, \u0026#34;marketing\u0026#34;]\r\u0026#34;foo\u0026#34; in {foo: 1, bar: 2} 数字操作符 .. (range) 例子:\nuser.Age in 18..45 range区间是全开的，也就是范围也包括在内:\n1..3 == [1, 2, 3] 三元运算符 foo ? 'yes' : 'no' 例子:\nuser.Age \u0026gt; 30 ? \u0026#34;mature\u0026#34; : \u0026#34;immature\u0026#34; 内置函数 len (length of array, map or string) all (will return true if all element satisfies the predicate) none (will return true if all element does NOT satisfies the predicate) any (will return true if any element satisfies the predicate) one (will return true if exactly ONE element satisfies the predicate) filter (filter array by the predicate) map (map all items with the closure) count (returns number of elements what satisfies the predicate) 例子:\n确保所有推文少于 280 个字符。\nall(Tweets, {.Size \u0026lt; 280}) 确保只有一位获胜者。\none(Participants, {.Winner}) 闭包 {...} (closure) 只有内置函数才允许闭包。 要访问当前项目，请使用 # 符号。\nmap(0..9, {# / 2}) 如果数组的项是 struct，则可以使用省略的 # 符号访问 struct 的字段（#.Value 变为 .Value）。\nfilter(Tweets, {len(.Value) \u0026gt; 280}) 切片 array[:] (slice) 切片可以处理数组或字符串。\n例子:\n变量array 为[1,2,3,4,5].\narray[1:5] == [2,3,4] array[3:] == [4,5] array[:4] == [1,2,3] array[:] == array 更多的例子 方法的替换 方法及参数全部替换 下面的例子实现了将方法及方法的参数进行替换\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; ) type customEnv struct { } func (c *customEnv) SayHi(u string) error { log.Println(\u0026#34;Hi\u0026#34;, u) return nil } func (c *customEnv) SayBye(u string) error { log.Println(\u0026#34;bye\u0026#34;, u) return nil } func main() { env := \u0026amp;customEnv{} code := `SayHi(\u0026#34;czyt\u0026#34;)` // will output 3 program, err := expr.Compile(code, expr.Env(env), expr.Patch(\u0026amp;customerPatcher{})) if err != nil { panic(err) } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type customerPatcher struct{} func (p *customerPatcher) Enter(node *ast.Node) { log.Println(\u0026#34;enter\u0026#34;) } func (p *customerPatcher) Exit(node *ast.Node) { log.Println(\u0026#34;Exit\u0026#34;) f, ok := (*node).(*ast.FunctionNode) if !ok { return } if f.Name == \u0026#34;SayHi\u0026#34; { f.Name = \u0026#34;SayBye\u0026#34; f.Arguments = []ast.Node{\u0026amp;ast.StringNode{Value: \u0026#34;jay zhou\u0026#34;}} } } 从方法名称取参数并执行 下面的例子从传入的方法名中取参数值并替换执行：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; ) type customEnv struct { } func (c *customEnv) Run(user ...string) error { log.Println(user, \u0026#34;run At\u0026#34;, time.Now()) return nil } func main() { env := \u0026amp;customEnv{} code := `Run_czyt()` program, err := expr.Compile(code, expr.Env(env), expr.Patch(\u0026amp;customerPatcher{})) if err != nil { panic(err) } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type customerPatcher struct{} func (p *customerPatcher) Enter(node *ast.Node) { log.Println(\u0026#34;enter\u0026#34;) } func (p *customerPatcher) Exit(node *ast.Node) { log.Println(\u0026#34;Exit\u0026#34;) f, ok := (*node).(*ast.FunctionNode) if !ok { return } fn := strings.Split(f.Name, \u0026#34;_\u0026#34;) ast.Patch(node, \u0026amp;ast.FunctionNode{ Name: fn[0], Arguments: []ast.Node{ \u0026amp;ast.StringNode{Value: fn[1]}, }, }) } 使用三元运算按条件执行 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;github.com/antonmedv/expr\u0026#34; \u0026#34;github.com/antonmedv/expr/ast\u0026#34; ) type customEnv struct { Temperature float64 } func (c *customEnv) Ready() error { log.Println(\u0026#34;Ready to GO!😊\u0026#34;) return nil } func (c *customEnv) UnReady() error { log.Println(\u0026#34;not Ready to GO!😂\u0026#34;) return nil } func main() { env := \u0026amp;customEnv{Temperature: 32} code := `Temperature\u0026lt;30?Ready():UnReady()` program, err := expr.Compile(code, expr.Env(env), expr.Patch(\u0026amp;customerPatcher{})) if err != nil { panic(err) } output, err := expr.Run(program, env) if err != nil { panic(err) } fmt.Print(output) } type customerPatcher struct{} func (p *customerPatcher) Enter(node *ast.Node) { log.Println(\u0026#34;enter\u0026#34;) } func (p *customerPatcher) Exit(node *ast.Node) { log.Println(\u0026#34;Exit\u0026#34;) } 参考 类似的库\nhttps://github.com/Knetic/govaluate https://github.com/seborama/gal ","permalink":"https://czyt.tech/post/golang-expr-uncompleted-reference/","summary":"安装 库的说明\nExpr package provides an engine that can compile and evaluate expressions. An expression is a one-liner that returns a value (mostly, but not limited to, booleans). It is designed for simplicity, speed and safety.\nThe purpose of the package is to allow users to use expressions inside configuration for more complex logic. It is a perfect candidate for the foundation of a business rule engine.\n安装\ngo get -u /github.","title":"Golang Expr不完全指南"},{"content":"ANTLR 4 图书 The definitive ANTLR 4 reference (2014) 英文版下载 中文版下载 文章 使用ANTLR和Go实现DSL入门 手把手教你使用ANTLR和Go实现一门DSL语言part1 part2part3part4part5 Parsing with ANTLR 4 and Go 实例代码 bilibili gengine link go-zero link grule-rule-engine Others 图书 Writing A Compiler In Go Writing an Interpreter in Go µGo语言实现——从头开发一个迷你Go语言编译器 文章 Build your own DSL with Go \u0026amp; HCL\nHow to Write Syntax Tree-Based Domain-Specific Languages in Go\nHandwritten Parsers \u0026amp; Lexers in Go\ngoyacc实战\nTiDB SQL Parser 的实现\nGopherCon 2018 - How to Write a Parser in Go\n实例代码 expr hof Go Parser Tutorial ","permalink":"https://czyt.tech/post/golang-dsl-reference/","summary":"ANTLR 4 图书 The definitive ANTLR 4 reference (2014) 英文版下载 中文版下载 文章 使用ANTLR和Go实现DSL入门 手把手教你使用ANTLR和Go实现一门DSL语言part1 part2part3part4part5 Parsing with ANTLR 4 and Go 实例代码 bilibili gengine link go-zero link grule-rule-engine Others 图书 Writing A Compiler In Go Writing an Interpreter in Go µGo语言实现——从头开发一个迷你Go语言编译器 文章 Build your own DSL with Go \u0026amp; HCL\nHow to Write Syntax Tree-Based Domain-Specific Languages in Go\nHandwritten Parsers \u0026amp; Lexers in Go\ngoyacc实战\nTiDB SQL Parser 的实现","title":"Golang DSL参考"},{"content":" Vue - The Complete Guide (incl. Router \u0026amp; Composition API) The Vue.js 3 Masterclass TypeScript Friendly Vue 3 Vue.js Fundamentals ","permalink":"https://czyt.tech/post/vue-related-resource/","summary":" Vue - The Complete Guide (incl. Router \u0026amp; Composition API) The Vue.js 3 Masterclass TypeScript Friendly Vue 3 Vue.js Fundamentals ","title":"Vue 相关资源"},{"content":"介绍 // Pipe creates a synchronous in-memory pipe. // It can be used to connect code expecting an io.Reader // with code expecting an io.Writer. // // Reads and Writes on the pipe are matched one to one // except when multiple Reads are needed to consume a single Write. // That is, each Write to the PipeWriter blocks until it has satisfied // one or more Reads from the PipeReader that fully consume // the written data. // The data is copied directly from the Write to the corresponding // Read (or Reads); there is no internal buffering. // // It is safe to call Read and Write in parallel with each other or with Close. // Parallel calls to Read and parallel calls to Write are also safe: // the individual calls will be gated sequentially.\n源码位置github\n使用例子 下面代码原链接为 https://luckymrwang.github.io/2020/12/17/Examples-For-Using-io-Pipe-in-Go/ 定义\npr, pw := io.Pipe() Example 1: JSON to HTTP Request pr, pw := io.Pipe() go func() { // close the writer, so the reader knows there\u0026#39;s no more data defer pw.Close() // write json data to the PipeReader through the PipeWriter if err := json.NewEncoder(pw).Encode(\u0026amp;PayLoad{Content: \u0026#34;Hello Pipe!\u0026#34;}); err != nil { log.Fatal(err) } }() // JSON from the PipeWriter lands in the PipeReader // ...and we send it off... if _, err := http.Post(\u0026#34;http://example.com\u0026#34;, \u0026#34;application/json\u0026#34;, pr); err != nil { log.Fatal(err) } Example 2: Split up Data with TeeReader pr, pw := io.Pipe() // we need to wait for everything to be done wg := sync.WaitGroup{} wg.Add(2) // we get some file as input f, err := os.Open(\u0026#34;./fruit.txt\u0026#34;) if err != nil { log.Fatal(err) } // TeeReader gets the data from the file and also writes it to the PipeWriter tr := io.TeeReader(f, pw) go func() { defer wg.Done() defer pw.Close() // get data from the TeeReader, which feeds the PipeReader through the PipeWriter _, err := http.Post(\u0026#34;https://example.com\u0026#34;, \u0026#34;text/html\u0026#34;, tr) if err != nil { log.Fatal(err) } }() go func() { defer wg.Done() // read from the PipeReader to stdout if _, err := io.Copy(os.Stdout, pr); err != nil { log.Fatal(err) } }() wg.Wait() Example 3: Piping the output of Shell commands pr, pw := io.Pipe() defer pw.Close() // tell the command to write to our pipe cmd := exec.Command(\u0026#34;cat\u0026#34;, \u0026#34;fruit.txt\u0026#34;) cmd.Stdout = pw go func() { defer pr.Close() // copy the data written to the PipeReader via the cmd to stdout if _, err := io.Copy(os.Stdout, pr); err != nil { log.Fatal(err) } }() // run the command, which writes all output to the PipeWriter // which then ends up in the PipeReader if err := cmd.Run(); err != nil { log.Fatal(err) } Example 4: Piping the output of Http response package main import ( \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os/exec\u0026#34; ) var ( BUF_LEN = 1024 ) func handler(w http.ResponseWriter, r *http.Request) { cmd := exec.Command(\u0026#34;./build.sh\u0026#34;) pipeReader, pipeWriter := io.Pipe() cmd.Stdout = pipeWriter cmd.Stderr = pipeWriter go writeCmdOutput(w, pipeReader) cmd.Run() pipeWriter.Close() } func writeCmdOutput(res http.ResponseWriter, pipeReader *io.PipeReader) { buffer := make([]byte, BUF_LEN) for { n, err := pipeReader.Read(buffer) if err != nil { pipeReader.Close() break } data := buffer[0:n] res.Write(data) if f, ok := res.(http.Flusher); ok { f.Flush() } //reset buffer for i := 0; i \u0026lt; n; i++ { buffer[i] = 0 } } } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } Example 4+: Piping the output of Http response package main import ( \u0026#34;io\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os/exec\u0026#34; ) func handler(w http.ResponseWriter, r *http.Request) { cmd := exec.Command(\u0026#34;ls\u0026#34;) pipeReader, pipeWriter := io.Pipe() cmd.Stdout = pipeWriter cmd.Stderr = pipeWriter go io.Copy(w, pipeReader) cmd.Run() pipeWriter.Close() } func main() { http.HandleFunc(\u0026#34;/\u0026#34;, handler) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } 参考 https://zetcode.com/golang/pipe/ https://medium.com/learning-the-go-programming-language/streaming-io-in-go-d93507931185 https://www.jianshu.com/p/aa207155ca7d https://www.ohyee.cc/post/note_go_io_pipe https://golang.hotexamples.com/examples/io/-/Pipe/golang-pipe-function-examples.html ","permalink":"https://czyt.tech/post/golang-io-pipe-usage/","summary":"介绍 // Pipe creates a synchronous in-memory pipe. // It can be used to connect code expecting an io.Reader // with code expecting an io.Writer. // // Reads and Writes on the pipe are matched one to one // except when multiple Reads are needed to consume a single Write. // That is, each Write to the PipeWriter blocks until it has satisfied // one or more Reads from the PipeReader that fully consume // the written data.","title":"Golang io.Pipe 使用"},{"content":"​ go embed 是go 1.16 开始添加的特性，允许嵌入文件及文件夹，在Go程序中进行使用。官方还为此添加了embed.FS的对象。下面将常用的使用场景进行简单列举：\n嵌入单个文件 官方的例子\n嵌入文件并绑定到字符串变量 import _ \u0026#34;embed\u0026#34; //go:embed hello.txt var s string print(s) 嵌入文件并绑定到字节变量 import _ \u0026#34;embed\u0026#34; //go:embed hello.txt var b []byte print(string(b)) 嵌入文件并绑定到文件对象 import \u0026#34;embed\u0026#34; //go:embed hello.txt var f embed.FS data, _ := f.ReadFile(\u0026#34;hello.txt\u0026#34;) print(string(data)) 嵌入目录 嵌入时，可以在多行或者一行输入要嵌入的文件和文件夹。\npackage server import \u0026#34;embed\u0026#34; // content holds our static web server content. //go:embed image/* template/* //go:embed html/index.html var content embed.FS 在匹配文件夹时，embed会嵌入包括子目录下的所有除.和_开头的文件（递归），所以上面的代码大致等价于下面的代码：\n// content is our static web server content. //go:embed image template html/index.html var content embed.FS 区别在于 image/* 会嵌入image/.tempfile 而image 则不会嵌入. 也不会嵌入image/dir/.tempfile.如果要实现跟上面代码一样的效果，即也嵌入image/.tempfile和image/dir/.tempfile这样的文件，那么应该使用下面的这段代码:\n// content is our static web server content. //go:embed all:image all:template html/index.html var content embed.FS 下面是一个在网络服务器中使用Embed来嵌入静态页面的例子：\nhttp.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, http.FileServer(http.FS(content)))) template.ParseFS(content, \u0026#34;*.tmpl\u0026#34;) 参考 官方文档:https://pkg.go.dev/embed 鸟窝Go embed简明教程 ","permalink":"https://czyt.tech/post/go-embed-usage-note/","summary":"​ go embed 是go 1.16 开始添加的特性，允许嵌入文件及文件夹，在Go程序中进行使用。官方还为此添加了embed.FS的对象。下面将常用的使用场景进行简单列举：\n嵌入单个文件 官方的例子\n嵌入文件并绑定到字符串变量 import _ \u0026#34;embed\u0026#34; //go:embed hello.txt var s string print(s) 嵌入文件并绑定到字节变量 import _ \u0026#34;embed\u0026#34; //go:embed hello.txt var b []byte print(string(b)) 嵌入文件并绑定到文件对象 import \u0026#34;embed\u0026#34; //go:embed hello.txt var f embed.FS data, _ := f.ReadFile(\u0026#34;hello.txt\u0026#34;) print(string(data)) 嵌入目录 嵌入时，可以在多行或者一行输入要嵌入的文件和文件夹。\npackage server import \u0026#34;embed\u0026#34; // content holds our static web server content. //go:embed image/* template/* //go:embed html/index.html var content embed.FS 在匹配文件夹时，embed会嵌入包括子目录下的所有除.和_开头的文件（递归），所以上面的代码大致等价于下面的代码：\n// content is our static web server content.","title":"go embed 使用小记"},{"content":"Windows下GIT的几个小技巧 记住git密码 使用下面命令可以设置记住git密码，但推荐使用ssh进行操作。\ngit config credential.helper store 设置换行符转换 在windows下开发时，迁出的代码是CRLF会导致编译的sh脚本不能正确执行:\ngit config --global core.autocrlf false Git推送到多个服务器 要实现一次push到多个远程仓库 本机git仓库A https://aaaaa.git 要同步push的远程git仓库B https://bbbbb.git\n通过git remote add添加 先使用git remote -v查看远程仓库的情况 ,然后添加一个git仓库\ngit remote add b https://bbbbb.git 再次查看远程仓库情况，如果需要push，则需要push两次\n通过git remote set-url 添加 如果按上面添加过remote分支，需要先git remote rm b,使用下面命令添加即可。\ngit remote set-url --add a https://bbbbb.git 查看远程仓库情况，看看是否已经是两个push地址了 。这个只需push一次就行了\n修改配置文件 打开 .git/config 找到 [remote \u0026ldquo;github\u0026rdquo;]，添加对应的 url 即可，效果如下。这种方法其实和方法二是一样的。\n[remote \u0026#34;a\u0026#34;] url = https://aaaaa.git fetch = +refs/heads/*:refs/remotes/a/* url = https://bbbbb.git 参考链接\n● 一个项目push到多个远程Git仓库 https://segmentfault.com/a/1190000011294144\n让你的 GitHub 公共仓库保持更新 当你派生了一个 GitHub 仓库之后，你的仓库（即你的“派生”）会独立于原仓库而独立。 特别地，当原仓库有新的提交时，GitHub 会通知你：\nThis branch is 5 commits behind progit:master. （本分支落后 progit:master 5 个提交。） 但你的 GitHub 仓库不会被 GitHub 自动更新，这件事必须由你自己来做。还好，这事儿很简单。\n第一种方法无需配置。例如，若你从 https://github.com/progit/progit2.git 派生了项目， 你可以像这样更新你的 master 分支：\n$ git checkout master (1) $ git pull https://github.com/progit/progit2.git (2) $ git push origin master (3) 如果在另一个分支上，就切换到 master 从 https://github.com/progit/progit2.git 抓取更改后合并到 master 将 master 分支推送到 origin 这虽然可行，但每次都要输入从哪个 URL 抓取有点麻烦。你可以稍微设置一下来自动完成它：\n$ git remote add progit https://github.com/progit/progit2.git (1) $ git branch --set-upstream-to=progit/master master (2) $ git config --local remote.pushDefault origin (3) 添加源仓库并取一个名字，这里叫它 progit 将 master 分支设置为从 progit 远端抓取 将默认推送仓库设置为 origin 搞定之后，工作流程为更加简单：\n$ git checkout master (1) $ git pull (2) $ git push (3) 如果在另一个分支上，就切换到 master 从 progit 抓取更改后合并到 master 将 master 分支推送到 origin 这种方法可能很有用，但也不是没有缺点。如果你向 master 提交，再从 progit 中拉取，然后推送到 origin，Git 会很乐意安静地为您完成这项工作，但不会警告你——所有这些操作在以上设置下都是有效的。 所以你必须注意永远不要直接提交到 master，因为该分支实际上属于上游仓库。\n核武器级选项：filter-branch 有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\nCaution git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 git-filter-repo，它是一个 Python 脚本，相比大多数使用 filter-branch 的应用来说，它做得要更好。它的文档和源码可访问 https://github.com/newren/git-filter-repo 获取。 从每一个提交中移除一个文件 这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n$ git filter-branch --tree-filter \u0026#39;rm -f passwords.txt\u0026#39; HEAD Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21) Ref \u0026#39;refs/heads/master\u0026#39; was rewritten --tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\n最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n使一个子目录做为新的根目录 假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n$ git filter-branch --subdirectory-filter trunk HEAD Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12) Ref \u0026#39;refs/heads/master\u0026#39; was rewritten 现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\n全局修改邮箱地址 另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n$ git filter-branch --commit-filter \u0026#39; if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;schacon@localhost\u0026#34; ]; then GIT_AUTHOR_NAME=\u0026#34;Scott Chacon\u0026#34;; GIT_AUTHOR_EMAIL=\u0026#34;schacon@example.com\u0026#34;; git commit-tree \u0026#34;$@\u0026#34;; else git commit-tree \u0026#34;$@\u0026#34;; fi\u0026#39; HEAD 这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。\n参考链接 Git常见的命令集合 ","permalink":"https://czyt.tech/post/git-tricks/","summary":"Windows下GIT的几个小技巧 记住git密码 使用下面命令可以设置记住git密码，但推荐使用ssh进行操作。\ngit config credential.helper store 设置换行符转换 在windows下开发时，迁出的代码是CRLF会导致编译的sh脚本不能正确执行:\ngit config --global core.autocrlf false Git推送到多个服务器 要实现一次push到多个远程仓库 本机git仓库A https://aaaaa.git 要同步push的远程git仓库B https://bbbbb.git\n通过git remote add添加 先使用git remote -v查看远程仓库的情况 ,然后添加一个git仓库\ngit remote add b https://bbbbb.git 再次查看远程仓库情况，如果需要push，则需要push两次\n通过git remote set-url 添加 如果按上面添加过remote分支，需要先git remote rm b,使用下面命令添加即可。\ngit remote set-url --add a https://bbbbb.git 查看远程仓库情况，看看是否已经是两个push地址了 。这个只需push一次就行了\n修改配置文件 打开 .git/config 找到 [remote \u0026ldquo;github\u0026rdquo;]，添加对应的 url 即可，效果如下。这种方法其实和方法二是一样的。\n[remote \u0026#34;a\u0026#34;] url = https://aaaaa.git fetch = +refs/heads/*:refs/remotes/a/* url = https://bbbbb.git 参考链接\n● 一个项目push到多个远程Git仓库 https://segmentfault.","title":"Git小技巧"},{"content":"目的 实现nocopy的目的在于，golang在进行参数传递时，都是传递副本的方式。但是某些情况，我们是需要进行传递对象的引用的（特别是一些指针对象，可能会导致多个指针的副本的操作造成程序陷入恐慌），为了杜绝调用者的复制，只能指针传递全局唯一对象。那么就可以通过添加nocopy来实现对go vet参数支持的no copy 检查。\n实现 golang里面最常用的sync.WaitGroup就是通过nocopy实现的。参考定义\n// A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema. state1 [3]uint32 } 再看下nocopy的定义,必须实现 sync.Locker 接口\n// noCopy may be embedded into structs which must not be copied // after the first use. // // See https://golang.org/issues/8005#issuecomment-190753527 // for details. type noCopy struct{} // Lock is a no-op used by -copylocks checker from `go vet`. func (*noCopy) Lock() {} func (*noCopy) Unlock() {} ","permalink":"https://czyt.tech/post/golang-nocopy-check/","summary":"目的 实现nocopy的目的在于，golang在进行参数传递时，都是传递副本的方式。但是某些情况，我们是需要进行传递对象的引用的（特别是一些指针对象，可能会导致多个指针的副本的操作造成程序陷入恐慌），为了杜绝调用者的复制，只能指针传递全局唯一对象。那么就可以通过添加nocopy来实现对go vet参数支持的no copy 检查。\n实现 golang里面最常用的sync.WaitGroup就是通过nocopy实现的。参考定义\n// A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema.","title":"Golang nocopy check"},{"content":"参考sdk定义\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) // wechat pay 用户付款码条形码规则：18位纯数字，以10、11、12、13、14、15开头 // alipay 支付授权码，25~30开头的长度为16~24位的数字，实际字符串长度以开发者获取的付款码长度为准 func main() { // wechat regwechat:=regexp.MustCompile(\u0026#34;^(1[0-5])\\\\d{16}$\u0026#34;) matchwechat := regwechat.MatchString(\u0026#34;154658833119096245\u0026#34;) fmt.Println(matchwechat) // alipay regalipay:=regexp.MustCompile(\u0026#34;^(2[5-9]|30)\\\\d{14,22}$\u0026#34;) matchalipay := regalipay.MatchString(\u0026#34;307573774583867517336\u0026#34;) fmt.Println(matchalipay) } 参考\n微信\n支付宝\n","permalink":"https://czyt.tech/post/golang-check-wechat-alipay-authcode-via-regxp/","summary":"参考sdk定义\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;regexp\u0026#34; ) // wechat pay 用户付款码条形码规则：18位纯数字，以10、11、12、13、14、15开头 // alipay 支付授权码，25~30开头的长度为16~24位的数字，实际字符串长度以开发者获取的付款码长度为准 func main() { // wechat regwechat:=regexp.MustCompile(\u0026#34;^(1[0-5])\\\\d{16}$\u0026#34;) matchwechat := regwechat.MatchString(\u0026#34;154658833119096245\u0026#34;) fmt.Println(matchwechat) // alipay regalipay:=regexp.MustCompile(\u0026#34;^(2[5-9]|30)\\\\d{14,22}$\u0026#34;) matchalipay := regalipay.MatchString(\u0026#34;307573774583867517336\u0026#34;) fmt.Println(matchalipay) } 参考\n微信\n支付宝","title":"golang正则校验支付宝微信支付授权码"},{"content":"事故起因 我们公司的应用程序部署目录有个bin目录，手误，删除的时候输入的是/bin\n事故现象 ● SSH 不能登陆进来了 ● ls、chmod等常用命令都不能使用了 ● wget 还能用\n事故解决 通过查找谷歌，发现有个perl带有提权的功能,简单来说就是\nperl -e \u0026#34;chmod 0777, \u0026#39;/bin/ls\u0026#39;\u0026#34; 通过这个方式可以对指定的文件进行权限的修改。于是从另外的机器上打包了一个/bin目录，放到网上，wget 下载到本地wget bin.tar.gz\n​ 本机开外网ssh转发，scp 拷贝tar文件到目录，执行\nperl -e \u0026#34;chmod 0777, \u0026#39;./tar\u0026#39;\u0026#34; ,再使用tar进行文件解压./tar xvzf bin.tar.gz -C /,然后再给chmod执行文件赋予执行权限\nperl -e \u0026#34;chmod 0777, \u0026#39;/bin/chmod\u0026#39;\u0026#34; 然后再通过chmod 执行 chmod -R +x /bin/给/bin目录下的可执行程序文件授予执行权限。至此，完成事故修复。\n参考连接 ● https://perldoc.perl.org/functions/chmod.html\n","permalink":"https://czyt.tech/post/perl-privilege-escalation-in-linux/","summary":"事故起因 我们公司的应用程序部署目录有个bin目录，手误，删除的时候输入的是/bin\n事故现象 ● SSH 不能登陆进来了 ● ls、chmod等常用命令都不能使用了 ● wget 还能用\n事故解决 通过查找谷歌，发现有个perl带有提权的功能,简单来说就是\nperl -e \u0026#34;chmod 0777, \u0026#39;/bin/ls\u0026#39;\u0026#34; 通过这个方式可以对指定的文件进行权限的修改。于是从另外的机器上打包了一个/bin目录，放到网上，wget 下载到本地wget bin.tar.gz\n​ 本机开外网ssh转发，scp 拷贝tar文件到目录，执行\nperl -e \u0026#34;chmod 0777, \u0026#39;./tar\u0026#39;\u0026#34; ,再使用tar进行文件解压./tar xvzf bin.tar.gz -C /,然后再给chmod执行文件赋予执行权限\nperl -e \u0026#34;chmod 0777, \u0026#39;/bin/chmod\u0026#39;\u0026#34; 然后再通过chmod 执行 chmod -R +x /bin/给/bin目录下的可执行程序文件授予执行权限。至此，完成事故修复。\n参考连接 ● https://perldoc.perl.org/functions/chmod.html","title":"Linux环境下Perl提权"},{"content":"整理一个列表，持续更新。\n理论 ebf官网 B站视频 eBPF 和 Go，超能力组合 实践 Tracing Go Functions with eBPF part1 part2 Getting Started with eBPF and Go Linux中基于eBPF的恶意利用与检测机制 如何用eBPF分析Golang应用 使用BPF, 将Go网络程序的吞吐提升8倍 使用ebpf跟踪rpcx微服务 BPF MAP机制 一种通用数据结构，可以存储不同类型数据的通用数据结构 Andrii Nakryiko 抽象数据容器(abstract data container) bpf系统调用的说明 《使用C语言从头开发一个Hello World级别的eBPF程序》 《Linux Observability with BPF》 《揭秘BPF map前生今世》 bpf系统调用说明 官方bpf map参考手册 bpftool参考手册 《Building BPF applications with libbpf-bootstrap》 https://github.com/DavadDi/bpf_study golang 包 https://github.com/cilium/ebpf ","permalink":"https://czyt.tech/post/ebpf-golang-reference/","summary":"整理一个列表，持续更新。\n理论 ebf官网 B站视频 eBPF 和 Go，超能力组合 实践 Tracing Go Functions with eBPF part1 part2 Getting Started with eBPF and Go Linux中基于eBPF的恶意利用与检测机制 如何用eBPF分析Golang应用 使用BPF, 将Go网络程序的吞吐提升8倍 使用ebpf跟踪rpcx微服务 BPF MAP机制 一种通用数据结构，可以存储不同类型数据的通用数据结构 Andrii Nakryiko 抽象数据容器(abstract data container) bpf系统调用的说明 《使用C语言从头开发一个Hello World级别的eBPF程序》 《Linux Observability with BPF》 《揭秘BPF map前生今世》 bpf系统调用说明 官方bpf map参考手册 bpftool参考手册 《Building BPF applications with libbpf-bootstrap》 https://github.com/DavadDi/bpf_study golang 包 https://github.com/cilium/ebpf ","title":"ebpf Golang参考"},{"content":"电子书 编写和优化Go代码 Go Optimizations 101 https://github.com/dgryski/go-perfbook https://github.com/DataDog/go-profiler-notes https://github.com/bobstrecansky/HighPerformanceWithGo/ Go package https://github.com/aclements/go-perf 文章 官方博客 Profiling Go Programs\nhttps://sumercip.com/posts/inside-the-go-cpu-profiler/\nHow to Write Benchmarks in Go : https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go\nDebugging performance issues in Go programs : https://github.com/golang/go/wiki/Performance\nGo execution tracer : https://blog.gopheracademy.com/advent-2017/go-execution-tracer/ (see also the The tracer design doc link)\nA whirlwind tour of Go’s runtime environment variables (see godebug) : https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables\nbenchstat : https://godoc.org/golang.org/x/perf/cmd/benchstat\npyroscope: 一个简单易用的持续剖析平台\nVSCODE可视化调试Go程序\nJetbrains官方Goland代码调试文档\nhttps://github.com/cch123/perf_workshop_2021\nGO高性能编程精华\nGo 语言中各式各样的优化手段\nGo 中简单的内存节省技巧\n性能监控系统 pyroscope gov ","permalink":"https://czyt.tech/post/golang-perf-reference/","summary":"电子书 编写和优化Go代码 Go Optimizations 101 https://github.com/dgryski/go-perfbook https://github.com/DataDog/go-profiler-notes https://github.com/bobstrecansky/HighPerformanceWithGo/ Go package https://github.com/aclements/go-perf 文章 官方博客 Profiling Go Programs\nhttps://sumercip.com/posts/inside-the-go-cpu-profiler/\nHow to Write Benchmarks in Go : https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go\nDebugging performance issues in Go programs : https://github.com/golang/go/wiki/Performance\nGo execution tracer : https://blog.gopheracademy.com/advent-2017/go-execution-tracer/ (see also the The tracer design doc link)\nA whirlwind tour of Go’s runtime environment variables (see godebug) : https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables\nbenchstat : https://godoc.org/golang.org/x/perf/cmd/benchstat\npyroscope: 一个简单易用的持续剖析平台\nVSCODE可视化调试Go程序\nJetbrains官方Goland代码调试文档\nhttps://github.com/cch123/perf_workshop_2021\nGO高性能编程精华\nGo 语言中各式各样的优化手段\nGo 中简单的内存节省技巧","title":"Go性能优化参考"},{"content":"Cap\u0026rsquo;n proto 号称是比protobuff更快的proto语言。官网截图\nCap’n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think Protocol Buffers, except faster. In fact, in benchmarks, Cap’n Proto is INFINITY TIMES faster than Protocol Buffers.\n协议特性\nCap’n Proto’s RPC protocol has the following notable features. Since the protocol is complicated, the feature set has been divided into numbered “levels”, so that implementations may declare which features they have covered by advertising a level number.\nLevel 1: Object references and promise pipelining, as described above. Level 2: Persistent capabilities. You may request to “save” a capability, receiving a persistent token which can be used to “restore” it in the future (on a new connection). Not all capabilities can be saved; the host app must implement support for it. Building this into the protocol makes it possible for a Cap’n-Proto-based data store to transparently save structures containing capabilities without knowledge of the particular capability types or the application built on them, as well as potentially enabling more powerful analysis and visualization of stored data. Level 3: Three-way interactions. A network of Cap’n Proto vats (nodes) can pass object references to each other and automatically form direct connections as needed. For instance, if Alice (on machine A) sends Bob (on machine B) a reference to Carol (on machine C), then machine B will form a new connection to machine C so that Bob can call Carol directly without proxying through machine A. Level 4: Reference equality / joining. If you receive a set of capabilities from different parties which should all point to the same underlying objects, you can verify securely that they in fact do. This is subtle, but enables many security patterns that rely on one party being able to verify that two or more other parties agree on something (imagine a digital escrow agent). See E’s page on equality. 目前GO只支持Level 1的特性，Level3的RPC特性已经在安排。\n下面整理其在Windows环境下的编译环境搭建步骤。\n编译器 下载Windows32的编译包 (可能不是最新，可以从官网安装介绍 获取最新)。将 capnp.exe, capnpc-c++.exe, 和capnpc-capnp.exe加入系统环境变量，推荐解压到%GOPATH%.\n然后安装GO的proto生成工具\ngo install capnproto.org/go/capnp/v3/capnpc-go@latest Annotations 包 目前Cap\u0026rsquo;n proto 的 Annotations是放入到代码仓库的，因为新版Go默认是启用了GOMODULE的，所以，需要按下面操作将仓库拉取到%GOPATH%.\ngo env -w GO111MODULE=off go get -u capnproto.org/go/capnp/v3/ go env -w GO111MODULE=on 编译验证 一般模型 books.capnp文件\nusing Go = import \u0026#34;/go.capnp\u0026#34;; @0x85d3acc39d94e0f8; $Go.package(\u0026#34;books\u0026#34;); $Go.import(\u0026#34;foo/books\u0026#34;); struct Book { title @0 :Text; # Title of the book. pageCount @1 :Int32; # Number of pages in the book. } 编译\ncapnp compile -I %GOPATH%/src/capnproto.org/go/capnp/std -ogo:.. .\\books.capnp 生成文件books.capnp.go\n// Code generated by capnpc-go. DO NOT EDIT. package books import ( capnp \u0026#34;capnproto.org/go/capnp/v3\u0026#34; text \u0026#34;capnproto.org/go/capnp/v3/encoding/text\u0026#34; schemas \u0026#34;capnproto.org/go/capnp/v3/schemas\u0026#34; ) type Book struct{ capnp.Struct } // Book_TypeID is the unique identifier for the type Book. const Book_TypeID = 0x8100cc88d7d4d47c func NewBook(s *capnp.Segment) (Book, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}) return Book{st}, err } func NewRootBook(s *capnp.Segment) (Book, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}) return Book{st}, err } func ReadRootBook(msg *capnp.Message) (Book, error) { root, err := msg.Root() return Book{root.Struct()}, err } func (s Book) String() string { str, _ := text.Marshal(0x8100cc88d7d4d47c, s.Struct) return str } func (s Book) Title() (string, error) { p, err := s.Struct.Ptr(0) return p.Text(), err } func (s Book) HasTitle() bool { return s.Struct.HasPtr(0) } func (s Book) TitleBytes() ([]byte, error) { p, err := s.Struct.Ptr(0) return p.TextBytes(), err } func (s Book) SetTitle(v string) error { return s.Struct.SetText(0, v) } func (s Book) PageCount() int32 { return int32(s.Struct.Uint32(0)) } func (s Book) SetPageCount(v int32) { s.Struct.SetUint32(0, uint32(v)) } // Book_List is a list of Book. type Book_List = capnp.StructList[Book] // NewBook creates a new list of Book. func NewBook_List(s *capnp.Segment, sz int32) (Book_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 1}, sz) return capnp.StructList[Book]{List: l}, err } // Book_Future is a wrapper for a Book promised by a client call. type Book_Future struct{ *capnp.Future } func (p Book_Future) Struct() (Book, error) { s, err := p.Future.Struct() return Book{s}, err } const schema_85d3acc39d94e0f8 = \u0026#34;x\\xda\\x12Ht`1\\xe4\\xdd\\xcf\\xc8\\xc0\\x14(\\xc2\\xca\u0026#34; + \u0026#34;\\xb6\\xbf\\xe6\\xca\\x95\\xeb\\x1dg\\x1a\\x03y\\x18\\x19\\xff\\xffx\u0026#34; + \u0026#34;0e\\xee\\xe15\\x97[\\x19X\\x19\\xd9\\x19\\x18\\x04\\x8fv\u0026#34; + \u0026#34;\\x09\\x9e\\x05\\xd1\u0026#39;\\xcb\\x19t\\xff\u0026#39;\\xe5\\xe7g\\x17\\xeb%\u0026#34; + \u0026#34;\u0026#39;2\\x16\\xe4\\x15X9\\xe5\\xe7g30\\x0402\\x06\u0026#34; + \u0026#34;r0\\xb300\\xb0020\\x08j\\x1a10\\x04\\xaa\u0026#34; + \u0026#34;03\\x06\\x1a0122\\x8a0\\x82\\xc4t\\x83\\x18\\x18\u0026#34; + \u0026#34;\\x02u\\x98\\x19\\x03-\\x98\\x18\\xe5K2KrR\\x19y\u0026#34; + \u0026#34;\\x18\\x98\\x18y\\x18\\x18\\xff\\x17$\\xa6\\xa7:\\xe7\\x97\\xe61\u0026#34; + \u0026#34;0\\x960\\xb2001\\xb200\\x02\\x02\\x00\\x00\\xff\\xff\u0026#34; + \u0026#34;N\\xd3$\\xbc\u0026#34; func init() { schemas.Register(schema_85d3acc39d94e0f8, 0x8100cc88d7d4d47c) } 序列化与反序列化参考官方GitHub https://github.com/capnproto/go-capnproto2/wiki/Getting-Started\n服务 定义接口 hash.capnp\nusing Go = import \u0026#34;/go.capnp\u0026#34;; @0xdb8274f9144abc7e; $Go.package(\u0026#34;hashes\u0026#34;); $Go.import(\u0026#34;foo/hashes\u0026#34;); interface HashFactory { newSha1 @0 () -\u0026gt; (hash :Hash); } interface Hash { write @0 (data :Data) -\u0026gt; (); sum @1 () -\u0026gt; (hash :Data); } 编译\ncapnp compile -I %GOPATH%/src/capnproto.org/go/capnp/std -ogo:.. .\\hash.capnp 生成的GO文件内容\n// Code generated by capnpc-go. DO NOT EDIT. package hashes import ( capnp \u0026#34;capnproto.org/go/capnp/v3\u0026#34; text \u0026#34;capnproto.org/go/capnp/v3/encoding/text\u0026#34; schemas \u0026#34;capnproto.org/go/capnp/v3/schemas\u0026#34; server \u0026#34;capnproto.org/go/capnp/v3/server\u0026#34; context \u0026#34;context\u0026#34; ) type HashFactory struct{ Client *capnp.Client } // HashFactory_TypeID is the unique identifier for the type HashFactory. const HashFactory_TypeID = 0xaead580f97fddabc func (c HashFactory) NewSha1(ctx context.Context, params func(HashFactory_newSha1_Params) error) (HashFactory_newSha1_Results_Future, capnp.ReleaseFunc) { s := capnp.Send{ Method: capnp.Method{ InterfaceID: 0xaead580f97fddabc, MethodID: 0, InterfaceName: \u0026#34;remote.capnp:HashFactory\u0026#34;, MethodName: \u0026#34;newSha1\u0026#34;, }, } if params != nil { s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0} s.PlaceArgs = func(s capnp.Struct) error { return params(HashFactory_newSha1_Params{Struct: s}) } } ans, release := c.Client.SendCall(ctx, s) return HashFactory_newSha1_Results_Future{Future: ans.Future()}, release } func (c HashFactory) AddRef() HashFactory { return HashFactory{ Client: c.Client.AddRef(), } } func (c HashFactory) Release() { c.Client.Release() } // A HashFactory_Server is a HashFactory with a local implementation. type HashFactory_Server interface { NewSha1(context.Context, HashFactory_newSha1) error } // HashFactory_NewServer creates a new Server from an implementation of HashFactory_Server. func HashFactory_NewServer(s HashFactory_Server, policy *server.Policy) *server.Server { c, _ := s.(server.Shutdowner) return server.New(HashFactory_Methods(nil, s), s, c, policy) } // HashFactory_ServerToClient creates a new Client from an implementation of HashFactory_Server. // The caller is responsible for calling Release on the returned Client. func HashFactory_ServerToClient(s HashFactory_Server, policy *server.Policy) HashFactory { return HashFactory{Client: capnp.NewClient(HashFactory_NewServer(s, policy))} } // HashFactory_Methods appends Methods to a slice that invoke the methods on s. // This can be used to create a more complicated Server. func HashFactory_Methods(methods []server.Method, s HashFactory_Server) []server.Method { if cap(methods) == 0 { methods = make([]server.Method, 0, 1) } methods = append(methods, server.Method{ Method: capnp.Method{ InterfaceID: 0xaead580f97fddabc, MethodID: 0, InterfaceName: \u0026#34;remote.capnp:HashFactory\u0026#34;, MethodName: \u0026#34;newSha1\u0026#34;, }, Impl: func(ctx context.Context, call *server.Call) error { return s.NewSha1(ctx, HashFactory_newSha1{call}) }, }) return methods } // HashFactory_newSha1 holds the state for a server call to HashFactory.newSha1. // See server.Call for documentation. type HashFactory_newSha1 struct { *server.Call } // Args returns the call\u0026#39;s arguments. func (c HashFactory_newSha1) Args() HashFactory_newSha1_Params { return HashFactory_newSha1_Params{Struct: c.Call.Args()} } // AllocResults allocates the results struct. func (c HashFactory_newSha1) AllocResults() (HashFactory_newSha1_Results, error) { r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return HashFactory_newSha1_Results{Struct: r}, err } type HashFactory_newSha1_Params struct{ capnp.Struct } // HashFactory_newSha1_Params_TypeID is the unique identifier for the type HashFactory_newSha1_Params. const HashFactory_newSha1_Params_TypeID = 0x92b20ad1a58ca0ca func NewHashFactory_newSha1_Params(s *capnp.Segment) (HashFactory_newSha1_Params, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return HashFactory_newSha1_Params{st}, err } func NewRootHashFactory_newSha1_Params(s *capnp.Segment) (HashFactory_newSha1_Params, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return HashFactory_newSha1_Params{st}, err } func ReadRootHashFactory_newSha1_Params(msg *capnp.Message) (HashFactory_newSha1_Params, error) { root, err := msg.Root() return HashFactory_newSha1_Params{root.Struct()}, err } func (s HashFactory_newSha1_Params) String() string { str, _ := text.Marshal(0x92b20ad1a58ca0ca, s.Struct) return str } // HashFactory_newSha1_Params_List is a list of HashFactory_newSha1_Params. type HashFactory_newSha1_Params_List = capnp.StructList[HashFactory_newSha1_Params] // NewHashFactory_newSha1_Params creates a new list of HashFactory_newSha1_Params. func NewHashFactory_newSha1_Params_List(s *capnp.Segment, sz int32) (HashFactory_newSha1_Params_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz) return capnp.StructList[HashFactory_newSha1_Params]{List: l}, err } // HashFactory_newSha1_Params_Future is a wrapper for a HashFactory_newSha1_Params promised by a client call. type HashFactory_newSha1_Params_Future struct{ *capnp.Future } func (p HashFactory_newSha1_Params_Future) Struct() (HashFactory_newSha1_Params, error) { s, err := p.Future.Struct() return HashFactory_newSha1_Params{s}, err } type HashFactory_newSha1_Results struct{ capnp.Struct } // HashFactory_newSha1_Results_TypeID is the unique identifier for the type HashFactory_newSha1_Results. const HashFactory_newSha1_Results_TypeID = 0xea3e50f7663f7bdf func NewHashFactory_newSha1_Results(s *capnp.Segment) (HashFactory_newSha1_Results, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return HashFactory_newSha1_Results{st}, err } func NewRootHashFactory_newSha1_Results(s *capnp.Segment) (HashFactory_newSha1_Results, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return HashFactory_newSha1_Results{st}, err } func ReadRootHashFactory_newSha1_Results(msg *capnp.Message) (HashFactory_newSha1_Results, error) { root, err := msg.Root() return HashFactory_newSha1_Results{root.Struct()}, err } func (s HashFactory_newSha1_Results) String() string { str, _ := text.Marshal(0xea3e50f7663f7bdf, s.Struct) return str } func (s HashFactory_newSha1_Results) Hash() Hash { p, _ := s.Struct.Ptr(0) return Hash{Client: p.Interface().Client()} } func (s HashFactory_newSha1_Results) HasHash() bool { return s.Struct.HasPtr(0) } func (s HashFactory_newSha1_Results) SetHash(v Hash) error { if !v.Client.IsValid() { return s.Struct.SetPtr(0, capnp.Ptr{}) } seg := s.Segment() in := capnp.NewInterface(seg, seg.Message().AddCap(v.Client)) return s.Struct.SetPtr(0, in.ToPtr()) } // HashFactory_newSha1_Results_List is a list of HashFactory_newSha1_Results. type HashFactory_newSha1_Results_List = capnp.StructList[HashFactory_newSha1_Results] // NewHashFactory_newSha1_Results creates a new list of HashFactory_newSha1_Results. func NewHashFactory_newSha1_Results_List(s *capnp.Segment, sz int32) (HashFactory_newSha1_Results_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz) return capnp.StructList[HashFactory_newSha1_Results]{List: l}, err } // HashFactory_newSha1_Results_Future is a wrapper for a HashFactory_newSha1_Results promised by a client call. type HashFactory_newSha1_Results_Future struct{ *capnp.Future } func (p HashFactory_newSha1_Results_Future) Struct() (HashFactory_newSha1_Results, error) { s, err := p.Future.Struct() return HashFactory_newSha1_Results{s}, err } func (p HashFactory_newSha1_Results_Future) Hash() Hash { return Hash{Client: p.Future.Field(0, nil).Client()} } type Hash struct{ Client *capnp.Client } // Hash_TypeID is the unique identifier for the type Hash. const Hash_TypeID = 0xf29f97dd675a9431 func (c Hash) Write(ctx context.Context, params func(Hash_write_Params) error) (Hash_write_Results_Future, capnp.ReleaseFunc) { s := capnp.Send{ Method: capnp.Method{ InterfaceID: 0xf29f97dd675a9431, MethodID: 0, InterfaceName: \u0026#34;remote.capnp:Hash\u0026#34;, MethodName: \u0026#34;write\u0026#34;, }, } if params != nil { s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1} s.PlaceArgs = func(s capnp.Struct) error { return params(Hash_write_Params{Struct: s}) } } ans, release := c.Client.SendCall(ctx, s) return Hash_write_Results_Future{Future: ans.Future()}, release } func (c Hash) Sum(ctx context.Context, params func(Hash_sum_Params) error) (Hash_sum_Results_Future, capnp.ReleaseFunc) { s := capnp.Send{ Method: capnp.Method{ InterfaceID: 0xf29f97dd675a9431, MethodID: 1, InterfaceName: \u0026#34;remote.capnp:Hash\u0026#34;, MethodName: \u0026#34;sum\u0026#34;, }, } if params != nil { s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0} s.PlaceArgs = func(s capnp.Struct) error { return params(Hash_sum_Params{Struct: s}) } } ans, release := c.Client.SendCall(ctx, s) return Hash_sum_Results_Future{Future: ans.Future()}, release } func (c Hash) AddRef() Hash { return Hash{ Client: c.Client.AddRef(), } } func (c Hash) Release() { c.Client.Release() } // A Hash_Server is a Hash with a local implementation. type Hash_Server interface { Write(context.Context, Hash_write) error Sum(context.Context, Hash_sum) error } // Hash_NewServer creates a new Server from an implementation of Hash_Server. func Hash_NewServer(s Hash_Server, policy *server.Policy) *server.Server { c, _ := s.(server.Shutdowner) return server.New(Hash_Methods(nil, s), s, c, policy) } // Hash_ServerToClient creates a new Client from an implementation of Hash_Server. // The caller is responsible for calling Release on the returned Client. func Hash_ServerToClient(s Hash_Server, policy *server.Policy) Hash { return Hash{Client: capnp.NewClient(Hash_NewServer(s, policy))} } // Hash_Methods appends Methods to a slice that invoke the methods on s. // This can be used to create a more complicated Server. func Hash_Methods(methods []server.Method, s Hash_Server) []server.Method { if cap(methods) == 0 { methods = make([]server.Method, 0, 2) } methods = append(methods, server.Method{ Method: capnp.Method{ InterfaceID: 0xf29f97dd675a9431, MethodID: 0, InterfaceName: \u0026#34;remote.capnp:Hash\u0026#34;, MethodName: \u0026#34;write\u0026#34;, }, Impl: func(ctx context.Context, call *server.Call) error { return s.Write(ctx, Hash_write{call}) }, }) methods = append(methods, server.Method{ Method: capnp.Method{ InterfaceID: 0xf29f97dd675a9431, MethodID: 1, InterfaceName: \u0026#34;remote.capnp:Hash\u0026#34;, MethodName: \u0026#34;sum\u0026#34;, }, Impl: func(ctx context.Context, call *server.Call) error { return s.Sum(ctx, Hash_sum{call}) }, }) return methods } // Hash_write holds the state for a server call to Hash.write. // See server.Call for documentation. type Hash_write struct { *server.Call } // Args returns the call\u0026#39;s arguments. func (c Hash_write) Args() Hash_write_Params { return Hash_write_Params{Struct: c.Call.Args()} } // AllocResults allocates the results struct. func (c Hash_write) AllocResults() (Hash_write_Results, error) { r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return Hash_write_Results{Struct: r}, err } // Hash_sum holds the state for a server call to Hash.sum. // See server.Call for documentation. type Hash_sum struct { *server.Call } // Args returns the call\u0026#39;s arguments. func (c Hash_sum) Args() Hash_sum_Params { return Hash_sum_Params{Struct: c.Call.Args()} } // AllocResults allocates the results struct. func (c Hash_sum) AllocResults() (Hash_sum_Results, error) { r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return Hash_sum_Results{Struct: r}, err } type Hash_write_Params struct{ capnp.Struct } // Hash_write_Params_TypeID is the unique identifier for the type Hash_write_Params. const Hash_write_Params_TypeID = 0xdffe94ae546cdee3 func NewHash_write_Params(s *capnp.Segment) (Hash_write_Params, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return Hash_write_Params{st}, err } func NewRootHash_write_Params(s *capnp.Segment) (Hash_write_Params, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return Hash_write_Params{st}, err } func ReadRootHash_write_Params(msg *capnp.Message) (Hash_write_Params, error) { root, err := msg.Root() return Hash_write_Params{root.Struct()}, err } func (s Hash_write_Params) String() string { str, _ := text.Marshal(0xdffe94ae546cdee3, s.Struct) return str } func (s Hash_write_Params) Data() ([]byte, error) { p, err := s.Struct.Ptr(0) return []byte(p.Data()), err } func (s Hash_write_Params) HasData() bool { return s.Struct.HasPtr(0) } func (s Hash_write_Params) SetData(v []byte) error { return s.Struct.SetData(0, v) } // Hash_write_Params_List is a list of Hash_write_Params. type Hash_write_Params_List = capnp.StructList[Hash_write_Params] // NewHash_write_Params creates a new list of Hash_write_Params. func NewHash_write_Params_List(s *capnp.Segment, sz int32) (Hash_write_Params_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz) return capnp.StructList[Hash_write_Params]{List: l}, err } // Hash_write_Params_Future is a wrapper for a Hash_write_Params promised by a client call. type Hash_write_Params_Future struct{ *capnp.Future } func (p Hash_write_Params_Future) Struct() (Hash_write_Params, error) { s, err := p.Future.Struct() return Hash_write_Params{s}, err } type Hash_write_Results struct{ capnp.Struct } // Hash_write_Results_TypeID is the unique identifier for the type Hash_write_Results. const Hash_write_Results_TypeID = 0x80ac741ec7fb8f65 func NewHash_write_Results(s *capnp.Segment) (Hash_write_Results, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return Hash_write_Results{st}, err } func NewRootHash_write_Results(s *capnp.Segment) (Hash_write_Results, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return Hash_write_Results{st}, err } func ReadRootHash_write_Results(msg *capnp.Message) (Hash_write_Results, error) { root, err := msg.Root() return Hash_write_Results{root.Struct()}, err } func (s Hash_write_Results) String() string { str, _ := text.Marshal(0x80ac741ec7fb8f65, s.Struct) return str } // Hash_write_Results_List is a list of Hash_write_Results. type Hash_write_Results_List = capnp.StructList[Hash_write_Results] // NewHash_write_Results creates a new list of Hash_write_Results. func NewHash_write_Results_List(s *capnp.Segment, sz int32) (Hash_write_Results_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz) return capnp.StructList[Hash_write_Results]{List: l}, err } // Hash_write_Results_Future is a wrapper for a Hash_write_Results promised by a client call. type Hash_write_Results_Future struct{ *capnp.Future } func (p Hash_write_Results_Future) Struct() (Hash_write_Results, error) { s, err := p.Future.Struct() return Hash_write_Results{s}, err } type Hash_sum_Params struct{ capnp.Struct } // Hash_sum_Params_TypeID is the unique identifier for the type Hash_sum_Params. const Hash_sum_Params_TypeID = 0xe74bb2d0190cf89c func NewHash_sum_Params(s *capnp.Segment) (Hash_sum_Params, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return Hash_sum_Params{st}, err } func NewRootHash_sum_Params(s *capnp.Segment) (Hash_sum_Params, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}) return Hash_sum_Params{st}, err } func ReadRootHash_sum_Params(msg *capnp.Message) (Hash_sum_Params, error) { root, err := msg.Root() return Hash_sum_Params{root.Struct()}, err } func (s Hash_sum_Params) String() string { str, _ := text.Marshal(0xe74bb2d0190cf89c, s.Struct) return str } // Hash_sum_Params_List is a list of Hash_sum_Params. type Hash_sum_Params_List = capnp.StructList[Hash_sum_Params] // NewHash_sum_Params creates a new list of Hash_sum_Params. func NewHash_sum_Params_List(s *capnp.Segment, sz int32) (Hash_sum_Params_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz) return capnp.StructList[Hash_sum_Params]{List: l}, err } // Hash_sum_Params_Future is a wrapper for a Hash_sum_Params promised by a client call. type Hash_sum_Params_Future struct{ *capnp.Future } func (p Hash_sum_Params_Future) Struct() (Hash_sum_Params, error) { s, err := p.Future.Struct() return Hash_sum_Params{s}, err } type Hash_sum_Results struct{ capnp.Struct } // Hash_sum_Results_TypeID is the unique identifier for the type Hash_sum_Results. const Hash_sum_Results_TypeID = 0xd093963b95a4e107 func NewHash_sum_Results(s *capnp.Segment) (Hash_sum_Results, error) { st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return Hash_sum_Results{st}, err } func NewRootHash_sum_Results(s *capnp.Segment) (Hash_sum_Results, error) { st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}) return Hash_sum_Results{st}, err } func ReadRootHash_sum_Results(msg *capnp.Message) (Hash_sum_Results, error) { root, err := msg.Root() return Hash_sum_Results{root.Struct()}, err } func (s Hash_sum_Results) String() string { str, _ := text.Marshal(0xd093963b95a4e107, s.Struct) return str } func (s Hash_sum_Results) Hash() ([]byte, error) { p, err := s.Struct.Ptr(0) return []byte(p.Data()), err } func (s Hash_sum_Results) HasHash() bool { return s.Struct.HasPtr(0) } func (s Hash_sum_Results) SetHash(v []byte) error { return s.Struct.SetData(0, v) } // Hash_sum_Results_List is a list of Hash_sum_Results. type Hash_sum_Results_List = capnp.StructList[Hash_sum_Results] // NewHash_sum_Results creates a new list of Hash_sum_Results. func NewHash_sum_Results_List(s *capnp.Segment, sz int32) (Hash_sum_Results_List, error) { l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz) return capnp.StructList[Hash_sum_Results]{List: l}, err } // Hash_sum_Results_Future is a wrapper for a Hash_sum_Results promised by a client call. type Hash_sum_Results_Future struct{ *capnp.Future } func (p Hash_sum_Results_Future) Struct() (Hash_sum_Results, error) { s, err := p.Future.Struct() return Hash_sum_Results{s}, err } const schema_db8274f9144abc7e = \u0026#34;x\\xda|\\x92?h\\x14A\\x18\\xc5\\xdf\\x9b\\x9bu\\xe3\\x9f\u0026#34; + \u0026#34;\\xe5\\x18\u0026#39;\\x16\\xd7\\x18\\x91\\x0b\\x82\\xc8\\xe1\\x19,T\\xf4\\x8e\u0026#34; + \u0026#34;\\x14*\\xb1\\xd9\\x8d\\x16b7\\xc4\\xd5\\x15rI\\xb8\\xdd#\u0026#34; + \u0026#34;\\x88\\xa0b#\\x82 \\xc4h\\x1aA\\x0b\\xed4E\\xea\\xb4\u0026#34; + \u0026#34;\\\u0026#34;\\x04\\x84\\xa4U\\xce\\x10,\\x84\\x94\\x01\\xd1(\\xba\\xb2{\u0026#34; + \u0026#34;\\xeem@/\\xdd\\xc2\\x9b\\xef}\\xbf\\xef\\xed;\\xc0\\xba\\xac\u0026#34; + \u0026#34;:\\x87$\\x84w\\xd4\\xda\\x11\\xfb\\x8f~\\xbe\\xdb\\x1f\\xbd\\xbe\u0026#34; + \u0026#34;\\x0b\\xb5\\x97\\x80\\xb4\\x81\\xa1M\\x0aB\\xc6K/\\x1e\\xbeZ\u0026#34; + \u0026#34;\\xd9\\xb50\\x03U\\xca\\x946\\x87\\x13e\\xf1\\xc3\\xaf\\xb9\\xe2\u0026#34; + \u0026#34;\\xe57\\xf3PN!\\xbe\\xbd8\\xd2\\xbf\\x19\\xdd\\xfb\\x08P\u0026#34; + \u0026#34;\\xbf\\xe5\\x92^\\xa1\\x0d\\xe8\\xf7\u0026lt;\\xa7\\xbf\u0026amp;_\\xb1\\xbd\\xf6\u0026#34; + \u0026#34;\\xf2\\xc9\\xa9\\xa7\\x8f\\x97;\\x0b\\xacTms\\x03\\xd4k\\xac\u0026#34; + \u0026#34;\\x81\\xf1\\xe7O\\xe3\\x97\\xe6g\\x7f\\xafn\\xd5)~\\x80\\xda\u0026#34; + \u0026#34;\\x12\\x89\\xfe\\xec\\xfb\\x9e\\xd2\\xf2\\xc2\\x85/9\\xa0\\x1e\\x14\\xeb\u0026#34; + \u0026#34;\\x90\\xf1\\xea\\xad\\xda\\xb5o\\xee\\x99\\xf5\\x0e_:8\\xb4S\u0026#34; + \u0026#34;\\x8c\\x10\\xd4\\xfb\\xd2\\xc9\\xea\\xec\\x95\\xeb\\xed\\xb9\\xe7\\x1b\\xff`\u0026#34; + \u0026#34;\\x1e\\x173\\xfa\\xb4H\\x9cN\\x88\\xfb\\xfa\\x81\\xb0q$n\u0026#34; + \u0026#34;\\xfa\\x8d\\xc9\\xc8\\xaf\\x8c\\xed6S\\x13S\u0026#39;\\xcf\\x9b0\\xa8\u0026#34; + \u0026#34;L7oD~y\\xd4\\x0f[\\xe3Q\\x88\\xecAW?\u0026#34; + \u0026#34;k\\xc6\\xa2\\xc9\\xe6\\xcd\\xca\\x84?}10\\xd5\\xb2k\\x9a\u0026#34; + \u0026#34;\\xa6\\xd1\\xfb\\x1d\\xe0\\x92\\x9e,X@7Zf7(5\u0026#34; + \u0026#34;\\x0c\\xa1,\\xfb\\xce_\\xb3:]\\xb2\\xcb$r\\xa6\\xb0\\xd5\u0026#34; + \u0026#34;(\\x8f\\xfa\\x03)\\x92\u0026#39;\\x0b\\x12\\x90\\x04\\x94s\\x18\\xf0\\xfa\u0026#34; + \u0026#34;\\x0a\\xf4\\xfa\\x05\\x8b\\x81\\x09\\x03:\\x10t\\xf0_\\x8f\\xce]\u0026#34; + \u0026#34;\\xb5\\x0eo/\\x93\\xab\u0026amp;2\\xdb\\x99$ \\xae)\u0026amp;\\x16\u0026#34; + \u0026#34;]Y\\xf6\\xcc\u0026amp;\\x0b\\x11\\xdb2\\xab\\xfc\\x97\\x81T[\\x16\u0026#34; + \u0026#34;3sf\\x90\\xa4\\xd8\\x97\\xa6\\x985\\x87Y\\x87U\\xf5\\x18\u0026#34; + \u0026#34;\\x84\\x1a\\xb4\\x99\\xb7\\x86Y\\xfdT\\xe9 \\x84r\\xec\\x81\\xf4\u0026#34; + \u0026#34;\\xfa:\\xed\\xb0\\xd5HS\\xfe\\x13\\x00\\x00\\xff\\xff\\xcf\\xa2\\xe6\u0026#34; + \u0026#34;\\xb3\u0026#34; func init() { schemas.Register(schema_db8274f9144abc7e, 0x80ac741ec7fb8f65, 0x92b20ad1a58ca0ca, 0xaead580f97fddabc, 0xd093963b95a4e107, 0xdffe94ae546cdee3, 0xe74bb2d0190cf89c, 0xea3e50f7663f7bdf, 0xf29f97dd675a9431) } 客户端调用\nfunc client(ctx context.Context, rwc io.ReadWriteCloser) error { // Create a connection that we can use to get the HashFactory. conn := rpc.NewConn(rpc.NewStreamTransport(rwc), nil) // nil sets default options defer conn.Close() // Get the \u0026#34;bootstrap\u0026#34; interface. This is the capability set with // rpc.MainInterface on the remote side. hf := hashes.HashFactory{Client: conn.Bootstrap(ctx)} // Now we can call methods on hf, and they will be sent over c. // The NewSha1 method does not have any parameters we can set, so we // pass a nil function. f, free := hf.NewSha1(ctx, nil) defer free() // \u0026#39;NewSha1\u0026#39; returns a future, which allows us to pipeline calls to // returned values before they are actually delivered. Here, we issue // calls to an as-of-yet-unresolved Sha1 instance. s := f.Hash() // s refers to a remote Hash. Method calls are delivered in order. f, free = s.Write(ctx, func(p hashes.Hash_write_Params) error { return p.SetData([]byte(\u0026#34;Hello, \u0026#34;)) }) defer free() f, free = s.Write(ctx, func(p hashes.Hash_write_Params) error { return p.SetData([]byte(\u0026#34;World!\u0026#34;)) }) defer free() // Get the sum, waiting for the result. f, free = s.Sum(ctx, nil) defer free() result, err := f.Struct() if err != nil { return err } // Display the result. sha1Val, err := result.Hash() if err != nil { return err } fmt.Printf(\u0026#34;sha1: %x\\n\u0026#34;, sha1Val) return nil } func main() { ctx := context.Background() c1, c2 := net.Pipe() go serveHash(ctx, c1) client(ctx, c2) } 参考链接 Capn Proto语言参考 Cloudflared https://github.com/inkeliz/karmem ","permalink":"https://czyt.tech/post/capn-proto-setup-in-windows/","summary":"Cap\u0026rsquo;n proto 号称是比protobuff更快的proto语言。官网截图\nCap’n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think Protocol Buffers, except faster. In fact, in benchmarks, Cap’n Proto is INFINITY TIMES faster than Protocol Buffers.\n协议特性\nCap’n Proto’s RPC protocol has the following notable features. Since the protocol is complicated, the feature set has been divided into numbered “levels”, so that implementations may declare which features they have covered by advertising a level number.","title":"Cap'n Proto Windows环境设置"},{"content":"Go是一门强类型的语言，在大多数情况下，申明一个变量、函数、struct都是直截了当的。在大多数情况下，这些都是够用的，但有时你想在程序运行中来动态扩展程序的信息，也许你想把文件或网络请求中的数据映射到一个变量中;也许你想建立一个能处理不同类型的工具(虽然Go1.18有了泛型)。在这些情况下，你需要使用反射。反射使你有能力在运行时检查、修改和创建变量、函数和结构的能力。\n反射的核心 图片转自 Go 语言设计与实现\n反射的三大核心是*Types, Kinds, Values,下面将围绕这三个方面来进行讲解。\n我们先定义一个struct对象。\ntype User struct { Name\tstring Age int } 类型Types 通过反射获取类型\nu := User{ Name: \u0026#34;czyt\u0026#34;, Age: 18, } uptr := \u0026amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Name()) // 打印 User log.Println(otptr.Name()) // 打印 空 通过调用Name()方法返回类型的名称，某些类型，如切片或指针，没有名称，此方法返回一个空字符串。\n种类Kinds Kind通过调用Kind()得来。\nu := User{ Name: \u0026#34;czyt\u0026#34;, Age: 18, } uptr := \u0026amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Kind()) // 输出 struct log.Println(otptr.Kind()) // 输出 ptr Kind() 返回的是kind类型的枚举。\ntype Kind uint const ( Invalid Kind = iota Bool Int Int8 Int16 Int32 Int64 Uint Uint8 Uint16 Uint32 Uint64 Uintptr Float32 Float64 Complex64 Complex128 Array Chan Func Interface Map Pointer Slice String Struct UnsafePointer ) kind 和 type 之间的区别可能很难理解，但可以这样想。如果你定义了一个名为 User的结构体，那么种类是struct，类型是 User.\n使用反射时需要注意的一件事：反射包中的所有内容都假定您知道自己在做什么，如果使用不正确，许多函数和方法调用都会出现panic。例如，如果您调用 reflect.Type 上的方法，该方法与与当前类型不同的类型相关联，您的代码将panic。请务必记得使用你的反射类型来知道哪些方法会起作用，哪些会panic。\n如果您的变量是指针、映射、切片、通道或数组，您可以使用 varType.Elem() 找出包含的类型。\n如果您的变量是一个结构，您可以使用反射来获取结构中的字段数，并取回包含在反射.StructField 结构中的每个字段的结构。reflect.StructField 为您提供字段上的名称、顺序、类型和结构标记。\n值Values 除了检查变量的类型之外，您还可以使用反射来读取、设置或创建值。首先，您需要使用 refVal := reflect.ValueOf(var) 为您的变量创建一个 reflect.Value 实例。如果您希望能够使用反射来修改值，则必须使用 refPtrVal := reflect.ValueOf(\u0026amp;var)获取指向变量的指针。如果你不这样做，你可以使用反射读取值，但你不能修改它。\n一旦有了 reflect.Value，就可以使用 Type() 方法获取变量的 reflect.Type。\n如果你想修改一个值，记住它必须是一个指针，你必须先取消引用指针。您使用 refPtrVal.Elem().Set(newRefVal) 进行更改，传递给 Set() 的值也必须是 reflect.Value。\n如果你想创建一个新值，你可以使用函数调用 newPtrVal := reflect.New(varType)，传入一个 reflect.Type。这将返回一个指针值，然后您可以对其进行修改。如上所述使用 Elem().Set()。\n最后，您可以通过调用 Interface() 方法返回到普通变量。该方法返回一个 interface{} 类型的值。如果您创建了一个指针以便可以修改值，则需要使用 Elem().Interface() 取消引用反射指针。在这两种情况下，您都需要将空接口转换为实际类型才能使用它。\ntype Foo struct { A int `tag1:\u0026#34;First Tag\u0026#34; tag2:\u0026#34;Second Tag\u0026#34;` B string } func main() { greeting := \u0026#34;hello\u0026#34; f := Foo{A: 10, B: \u0026#34;Salutations\u0026#34;} gVal := reflect.ValueOf(greeting) // not a pointer so all we can do is read it fmt.Println(gVal.Interface()) gpVal := reflect.ValueOf(\u0026amp;greeting) // it’s a pointer, so we can change it, and it changes the underlying variable gpVal.Elem().SetString(\u0026#34;goodbye\u0026#34;) fmt.Println(greeting) fType := reflect.TypeOf(f) fVal := reflect.New(fType) fVal.Elem().Field(0).SetInt(20) fVal.Elem().Field(1).SetString(\u0026#34;Greetings\u0026#34;) f2 := fVal.Elem().Interface().(Foo) fmt.Printf(\u0026#34;%+v, %d, %s\\n\u0026#34;, f2, f2.A, f2.B) } reflect.Value 和 reflect.Type 都提供了 Elem() 方法。\n其中reflect.Value.Elem() 会返回interface对象v指向的值或指针。当v的类型不是interface或者指针时，程序会panic，当v为该类型的零值时该函数会返回nil\nreflect.Type.Elem() 返回该类型元素的类型。当类型是Array, Chan, Map, Ptr, Slice之外的类型时，程序会panic。\n示例 基础示例 动态调用struct方法 获取方法信息\nfunc main() { // 声明一个 Person 接口，并用 Hero 作为接收器 var person Person = \u0026amp;Hero{} // 获取接口Person的类型对象 typeOfPerson := reflect.TypeOf(person) // 打印Person的方法类型和名称 for i := 0 ; i \u0026lt; typeOfPerson.NumMethod(); i++{ fmt.Printf(\u0026#34;method is %s, type is %s, kind is %s.\\n\u0026#34;, typeOfPerson.Method(i).Name, typeOfPerson.Method(i).Type, typeOfPerson.Method(i).Type.Kind()) } method, _ := typeOfPerson.MethodByName(\u0026#34;Run\u0026#34;) fmt.Printf(\u0026#34;method is %s, type is %s, kind is %s.\\n\u0026#34;, method.Name, method.Type, method.Type.Kind()) } 动态调用\ntype M struct{} type In struct{} type Out struct{} func (m *M) Example(in In) Out { return Out{} } func main() { v := reflect.ValueOf(\u0026amp;M{}) m := v.MethodByName(\u0026#34;Example\u0026#34;) in := m.Type().In(0) out := m.Type().Out(0) fmt.Println(in, out) inVal := reflect.New(in).Elem() // 可以将 inVal 转为interface后进行赋值之类的操作…… rtn := m.Call([]reflect.Value{inVal}) fmt.Println(rtn[0]) } 不通过Make创建slice、Map 除了创建内置和用户定义类型的实例外，您还可以使用反射来创建通常需要 make 函数的实例。您可以使用 reflect.MakeSlice、reflect.MakeMap 和 reflect.MakeChan 函数制作切片、贴图或通道。在所有情况下，您都提供了一个reflect.Type并取回了一个可以使用反射操作的 reflect.Value，或者您可以分配回一个标准变量。\nfunc main() { // declaring these vars, so I can make a reflect.Type intSlice := make([]int, 0) mapStringInt := make(map[string]int) // here are the reflect.Types sliceType := reflect.TypeOf(intSlice) mapType := reflect.TypeOf(mapStringInt) // and here are the new values that we are making intSliceReflect := reflect.MakeSlice(sliceType, 0, 0) mapReflect := reflect.MakeMap(mapType) // and here we are using them v := 10 rv := reflect.ValueOf(v) intSliceReflect = reflect.Append(intSliceReflect, rv) intSlice2 := intSliceReflect.Interface().([]int) fmt.Println(intSlice2) k := \u0026#34;hello\u0026#34; rk := reflect.ValueOf(k) mapReflect.SetMapIndex(rk, rv) mapStringInt2 := mapReflect.Interface().(map[string]int) fmt.Println(mapStringInt2) } 检查struct是否实现接口 例如下面的定义\ntype shape interface { getNumSides() int getArea() int } type square struct { len int } func (s square) getNumSides() int { return 4 } 常规做法 可以使用var _ shape = (*square)(nil)来进行判断，但是某些情况下我们需要使用反射来实现，具体代码如下：\nfunc IsShaperImpl(checkTarget interface{}) bool { c := reflect.TypeOf(checkTarget) modelType := reflect.TypeOf((*shape)(nil)).Elem() return c.Implements(modelType) } fmt.Println(IsShaperImpl(\u0026amp;square{})) // 打印 false 通过Field offset修改struct字段值 type B_struct struct { B_int int B_string string B_slice []string B_map map[int]string } type A_struct struct { A_int int A_float float32 A_bool bool A_BPtr *B_struct A_Bean B_struct } // 在64位机器中，int占8个字节，float64占8个字节， //bool占1个字节，指针ptr占8个字节，string的底层是stringheader占用16个字节 //slice的底层结构是sliceheader,map底层结构未知，但是占用8个字节 //在结构体中会进行字节对齐 //比如在bool后面跟一个ptr，bool就会对齐为8个字节 fmt.Println(\u0026#34;total size of A:\u0026#34;, reflect.TypeOf(A_struct{}).Size()) fmt.Println(\u0026#34;total size of B:\u0026#34;, reflect.TypeOf(B_struct{}).Size()) var type_A = reflect.TypeOf(A_struct{}) var type_B = reflect.TypeOf(B_struct{}) var A_bean = A_struct{} var start_ptr = uintptr(unsafe.Pointer(\u0026amp;A_bean)) // 设置A的第一个int型成员变量 *((*int)(unsafe.Pointer(start_ptr + type_A.Field(0).Offset))) = 100 fmt.Println(\u0026#34;after set int of A: \u0026#34;, A_bean) // 设置A的第二个float32成员变量 *((*float32)(unsafe.Pointer(start_ptr + type_A.Field(1).Offset))) = 55.5 fmt.Println(\u0026#34;after set float32 of A: \u0026#34;, A_bean) // 设置A的第三个bool变量 *((*bool)(unsafe.Pointer(start_ptr + type_A.Field(2).Offset))) = true fmt.Println(\u0026#34;after set bool of A:\u0026#34;, A_bean) // 设置A的第四个ptr变量 var first_B = \u0026amp;B_struct{B_int: 1024, B_string: \u0026#34;hello\u0026#34;, B_slice: []string{\u0026#34;lalla\u0026#34;, \u0026#34;biubiu\u0026#34;}, B_map: map[int]string{1: \u0026#34;this is a one\u0026#34;, 2: \u0026#34;this is a two\u0026#34;}} *((**B_struct)(unsafe.Pointer(start_ptr + type_A.Field(3).Offset))) = first_B fmt.Println(\u0026#34;after set A_BPtr of A:\u0026#34;, A_bean, \u0026#34;and A_bean.A_BPtr:\u0026#34;, A_bean.A_BPtr) // A的第五个变量是一个B_struct结构体变量，所以可以继续通过偏移来设置 //A的第五个变量中的第一个int变量 *((*int)(unsafe.Pointer(start_ptr + type_A.Field(4).Offset + type_B.Field(0).Offset))) = 2048 fmt.Println(\u0026#34;after set B_int of A_Bbean of A:\u0026#34;, A_bean) // A的第五个变量中的第二个string变量 *((*string)(unsafe.Pointer(start_ptr + type_A.Field(4).Offset + type_B.Field(1).Offset))) = \u0026#34;world\u0026#34; fmt.Println(\u0026#34;after set B_string of A_Bbean of A:\u0026#34;, A_bean) // A的第五个变量中的第三个slice变量 *((*[]string)(unsafe.Pointer(start_ptr + type_A.Field(4).Offset + type_B.Field(2).Offset))) = []string{\u0026#34;hehe\u0026#34;, \u0026#34;heihei\u0026#34;} fmt.Println(\u0026#34;after set B_slice of A_Bbean of A:\u0026#34;, A_bean) // A的第六个变量中的第三个slice变量 *((*map[int]string)(unsafe.Pointer(start_ptr + type_A.Field(4).Offset + type_B.Field(3).Offset))) = map[int]string{3: \u0026#34;this is three\u0026#34;, 4: \u0026#34;this is four\u0026#34;,} fmt.Println(\u0026#34;after set B_map of A_Bbean of A:\u0026#34;, A_bean) 创建函数 反射不只是让你创造新的地方来存储数据。您可以使用反射来使用 reflect.MakeFunc 函数创建新函数。这个函数需要我们想要创建的函数的 reflect.Type 和一个闭包，它的输入参数是 []reflect.Value 类型，其输出参数也是 []reflect.Value 类型。这是一个简单的示例，它为传递给它的任何函数创建一个计时包装器：\nfunc MakeTimedFunction(f interface{}) interface{} { rf := reflect.TypeOf(f) if rf.Kind() != reflect.Func { panic(\u0026#34;expects a function\u0026#34;) } vf := reflect.ValueOf(f) wrapperF := reflect.MakeFunc(rf, func(in []reflect.Value) []reflect.Value { start := time.Now() out := vf.Call(in) end := time.Now() fmt.Printf(\u0026#34;calling %s took %v\\n\u0026#34;, runtime.FuncForPC(vf.Pointer()).Name(), end.Sub(start)) return out }) return wrapperF.Interface() } func timeMe() { fmt.Println(\u0026#34;starting\u0026#34;) time.Sleep(1 * time.Second) fmt.Println(\u0026#34;ending\u0026#34;) } func timeMeToo(a int) int { fmt.Println(\u0026#34;starting\u0026#34;) time.Sleep(time.Duration(a) * time.Second) result := a * 2 fmt.Println(\u0026#34;ending\u0026#34;) return result } func main() { timed := MakeTimedFunction(timeMe).(func()) timed() timedToo := MakeTimedFunction(timeMeToo).(func(int) int) fmt.Println(timedToo(2)) } 动态创建struct 在 Go 中使用反射还可以做一件事。您可以在运行时通过将一部分 reflect.StructField 实例传递给 reflect.StructOf 函数来创建全新的结构。这个有点奇怪；我们正在创建一个新类型，但我们没有它的名称，所以你不能真正把它变成一个“正常”的变量。您可以创建一个新实例并使用Interface() 将值放入 interface{} 类型的变量中，但是如果要在其上设置任何值，则需要使用反射。\nfunc MakeStruct(vals ...interface{}) interface{} { var sfs []reflect.StructField for k, v := range vals { t := reflect.TypeOf(v) sf := reflect.StructField{ Name: fmt.Sprintf(\u0026#34;F%d\u0026#34;, (k + 1)), Type: t, } sfs = append(sfs, sf) } st := reflect.StructOf(sfs) so := reflect.New(st) return so.Interface() } func main() { s := MakeStruct(0, \u0026#34;\u0026#34;, []int{}) // this returned a pointer to a struct with 3 fields: // an int, a string, and a slice of ints // but you can’t actually use any of these fields // directly in the code; you have to reflect them sr := reflect.ValueOf(s) // getting and setting the int field fmt.Println(sr.Elem().Field(0).Interface()) sr.Elem().Field(0).SetInt(20) fmt.Println(sr.Elem().Field(0).Interface()) // getting and setting the string field fmt.Println(sr.Elem().Field(1).Interface()) sr.Elem().Field(1).SetString(\u0026#34;reflect me\u0026#34;) fmt.Println(sr.Elem().Field(1).Interface()) // getting and setting the []int field fmt.Println(sr.Elem().Field(2).Interface()) v := []int{1, 2, 3} rv := reflect.ValueOf(v) sr.Elem().Field(2).Set(rv) fmt.Println(sr.Elem().Field(2).Interface()) } 进阶应用 动态创建通道 发送通道\nvar k = reflect.TypeOf(0) fmt.Println(reflect.ChanOf(reflect.SendDir, k)) // 输出 chan\u0026lt;- int 接收通道\nta := reflect.ArrayOf(5, reflect.TypeOf(123)) tc := reflect.ChanOf(reflect.RecvDir, ta) fmt.Println(tc) // 输出 \u0026lt;-chan [5]int 一个复杂点的例子 参考\npackage main import ( \u0026#34;reflect\u0026#34; \u0026#34;strings\u0026#34; ) func makeChannel(t reflect.Type, chanDir reflect.ChanDir, buffer int) reflect.Value { ctype := reflect.ChanOf(chanDir, t) return reflect.MakeChan(ctype, buffer) } type T interface{} type Query struct { input reflect.Value } func (q *Query) Apply(f T) *Query { value := reflect.ValueOf(f) if value.Kind() != reflect.Func { panic(\u0026#34;Apply() parameter must be a function\u0026#34;) } rtype := value.Type().Out(0) output := makeChannel(rtype, reflect.BothDir, 0) go func() { var elem reflect.Value for ok := true; ok; { if elem, ok = q.input.Recv(); ok { result := value.Call([]reflect.Value{elem}) output.Send(result[0]) } } output.Close() }() return \u0026amp;Query{output} } func From(array T) *Query { value := reflect.ValueOf(array) if value.Kind() != reflect.Slice { panic(\u0026#34;From() parameter must be a slice\u0026#34;) } etype := value.Type().Elem() output := makeChannel(etype, reflect.BothDir, 0) go func() { for i := 0; i != value.Len(); i++ { output.Send(value.Index(i)) } output.Close() }() return \u0026amp;Query{output} } func (q *Query) Items() \u0026lt;-chan T { output := make(chan T) go func() { for ok := true; ok; { var elem reflect.Value if elem, ok = q.input.Recv(); ok { output \u0026lt;- elem.Interface() } } close(output) }() return output } func (q *Query) StringItems() \u0026lt;-chan string { output := make(chan string) go func() { for elem := range q.Items() { output \u0026lt;- elem.(string) } close(output) }() return output } func main() { t := []int{0, 1, 2} m := map[int]string{0: \u0026#34;zero\u0026#34;, 1: \u0026#34;one\u0026#34;, 2: \u0026#34;two\u0026#34;} for elem := range From(t).Apply(func(x int) string { return m[x] }).Apply(strings.ToUpper).StringItems() { println(elem) } } 动态创建通道SelectCase 摘自极客时间专栏《Go语言并发编程实战》的一段代码：\nfunc main() { var ch1 = make(chan int, 10) var ch2 = make(chan int, 10) // 创建SelectCase var cases = createCases(ch1, ch2) // 执行10次select for i := 0; i \u0026lt; 10; i++ { chosen, recv, ok := reflect.Select(cases) if recv.IsValid() { // recv case fmt.Println(\u0026#34;recv:\u0026#34;, cases[chosen].Dir, recv, ok) } else { // send case fmt.Println(\u0026#34;send:\u0026#34;, cases[chosen].Dir, ok) } } } func createCases(chs ...chan int) []reflect.SelectCase { var cases []reflect.SelectCase // 创建recv case for _, ch := range chs { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(ch), }) } // 创建send case for i, ch := range chs { v := reflect.ValueOf(i) cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectSend, Chan: reflect.ValueOf(ch), Send: v, }) } return cases } 参考文档 Reflections in Go Go语言反射的实现原理 ","permalink":"https://czyt.tech/post/golang-reflect-reference/","summary":"Go是一门强类型的语言，在大多数情况下，申明一个变量、函数、struct都是直截了当的。在大多数情况下，这些都是够用的，但有时你想在程序运行中来动态扩展程序的信息，也许你想把文件或网络请求中的数据映射到一个变量中;也许你想建立一个能处理不同类型的工具(虽然Go1.18有了泛型)。在这些情况下，你需要使用反射。反射使你有能力在运行时检查、修改和创建变量、函数和结构的能力。\n反射的核心 图片转自 Go 语言设计与实现\n反射的三大核心是*Types, Kinds, Values,下面将围绕这三个方面来进行讲解。\n我们先定义一个struct对象。\ntype User struct { Name\tstring Age int } 类型Types 通过反射获取类型\nu := User{ Name: \u0026#34;czyt\u0026#34;, Age: 18, } uptr := \u0026amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Name()) // 打印 User log.Println(otptr.Name()) // 打印 空 通过调用Name()方法返回类型的名称，某些类型，如切片或指针，没有名称，此方法返回一个空字符串。\n种类Kinds Kind通过调用Kind()得来。\nu := User{ Name: \u0026#34;czyt\u0026#34;, Age: 18, } uptr := \u0026amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Kind()) // 输出 struct log.Println(otptr.Kind()) // 输出 ptr Kind() 返回的是kind类型的枚举。","title":"Golang反射使用指南"},{"content":"(本文大部分内容根据官方文档翻译而来)\n环境准备 golang 1.10+ mongodb mgm 模型定义 定义 定义模型\ntype Book struct { // DefaultModel adds _id, created_at and updated_at fields to the Model mgm.DefaultModel `bson:\u0026#34;,inline\u0026#34;` Name string `json:\u0026#34;name\u0026#34; bson:\u0026#34;name\u0026#34;` Pages int `json:\u0026#34;pages\u0026#34; bson:\u0026#34;pages\u0026#34;` } func NewBook(name string, pages int) *Book { return \u0026amp;Book{ Name: name, Pages: pages, } } mgm 在创建表时会自动检测Model生成的Collection名称\nbook:=Book{} // Print your model collection name. collName := mgm.CollName(\u0026amp;book) fmt.Println(collName) // 打印: books 如果要自定义生成Collection的名称。需要实现CollectionNameGetter接口。\nfunc (model *Book) CollectionName() string { return \u0026#34;my_books\u0026#34; } // mgm return \u0026#34;my_books\u0026#34; collection coll:=mgm.Coll(\u0026amp;Book{}) struct Tags ​ 不知您是否注意到模型定义的struct tags。struct tags修改 Go 驱动程序的默认编组和解组行为 ，这是附加到 struct 字段的可选元数据片段。struct 标记最常见的用途是指定 BSON 文档中与 struct 字段对应的字段名称。下表描述了mongoDB 的 Go 驱动程序中的常见结构标记：\n结构标签 描述 omitempty 如果将字段设置为对应于字段类型的零值，则不会对字段进行编组。 minsize 如果字段类型是 int64、uint、uint32 或 uint64 类型，并且该字段的值可以适合带符号的 int32，则该字段将被序列化为 BSON int32 而不是 BSON int64。如果该值不适合带符号的 int32，则忽略此标记。 truncate 如果字段类型是非浮点数字类型，则未编组到该字段中的 BSON 双精度将在小数点处被截断。 inline 如果字段类型是 struct 或 map 字段，则该字段将在编组时展平，在解组时不展平。 如果没有来自结构标签的额外指令，Go Driver 将使用以下规则编组结构：\nGo Driver 仅对导出的字段进行编组和解组。 Go Driver 使用相应结构字段的小写字母生成 BSON 密钥。 Go 驱动程序将嵌入的结构字段编组为子文档。每个键都是字段类型的小写。 如果指针非 nil，Go Driver 将指针字段编组为基础类型。如果指针为 nil，则驱动程序将其编组为 BSON 空值。 解组时，Go Driver 跟随这些 D/M 类型映射 对于类型的字段interface{}。驱动程序将未编组的 BSON 文档interface{}作为D类型解组到字段中。 模型默认字段 每个模型的都包含mgm.DefaultModel,包含下面三个字段:\n_id : 文档 Id. created_at: 文档创建时间. 保存文档时通过 Creating 勾子自动填充。 updated_at: 文档最后更新时间. 保存文档时通过 Saving 勾子自动填充。 模型勾子（Hook） Creating: Model新模型时调用.使用DefaultModel默认使用该Hook 函数签名: Creating() error\nCreated: Model创建完成后被调用。 函数签名: Created() error\nUpdating: Model更新时调用. 函数签名: Updating() error\nUpdated : Model更新后被调用. 函数签名: Updated(result *mongo.UpdateResult) error\nSaving: Model 在creating 或者updating被调用.使用DefaultModel默认使用该Hook 函数签名: Saving() error\nSaved: Model 在Created 或 updated被调用. 函数签名: Saved() error\nDeleting: Model在 deleting时调用. 函数签名: Deleting() error\nDeleted: Model删除后调用. 函数签名: Deleted(result *mongo.DeleteResult) error\n下面是一个使用Creating进行参数校验的例子：\nfunc (model *Book) Creating() error { // Call to DefaultModel Creating hook if err:=model.DefaultModel.Creating();err!=nil{ return err } // We can check if model fields is not valid, return error to // cancel document insertion . if model.Pages \u0026lt; 1 { return errors.New(\u0026#34;book must have at least one page\u0026#34;) } return nil } 使用 开始使用之前，先设置默认配置选项：Descending\nimport ( \u0026#34;github.com/kamva/mgm/v3\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; ) func init() { // Setup the mgm default config err := mgm.SetDefaultConfig(nil, \u0026#34;test\u0026#34;, options.Client().ApplyURI(\u0026#34;mongodb://root:12345@localhost:27017\u0026#34;)) } 新增 book:=NewBook(\u0026#34;Pride and Prejudice\u0026#34;, 345) // Make sure pass the model by reference. err := mgm.Coll(book).Create(book) 如果需要设置数据在某一时间自动过期（清除),那么可以使用下面的语句：\nbook:=NewBook(\u0026#34;Pride and Prejudice\u0026#34;, 345) model := mongo.IndexModel{ Keys: bson.D{ {\u0026#34;created_at\u0026#34;, 1}, {\u0026#34;expireAfterSeconds\u0026#34;, t.data.temporaryRecordExpireSeconds}}, } _, err = mgm.Coll(book).Indexes().CreateOne(ctx, model) if err != nil { return \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, err } 更多详情，请参考 expire data index ttl\n删除 // Just find and delete your document err := mgm.Coll(book).Delete(book) 更新 常规更新\n// Find your book book:=findMyFavoriteBook() // and update it book.Name=\u0026#34;Moulin Rouge!\u0026#34; err:=mgm.Coll(book).Update(book) upsert更新\nfilter := bson.D{{\u0026#34;type\u0026#34;, \u0026#34;Oolong\u0026#34;}} update := bson.D{{\u0026#34;$set\u0026#34;, bson.D{{\u0026#34;rating\u0026#34;, 8}}}} opts := options.Update().SetUpsert(true) result, err := mgm.Coll(book).UpdateOne(mgm.Ctx(), filter, update, opts) if err != nil { panic(err) } 查询 基础查询 简单查询\n//Get document\u0026#39;s collection book := \u0026amp;Book{} coll := mgm.Coll(book) // Find and decode doc to the book model. _ = coll.FindByID(\u0026#34;5e0518aa8f1a52b0b9410ee3\u0026#34;, book) // Get first doc of collection _ = coll.First(bson.M{}, book) // Get first doc of collection with filter _ = coll.First(bson.M{\u0026#34;page\u0026#34;:400}, book) 查询并返回列表\nresult := []Book{} err := mgm.Coll(\u0026amp;Book{}).SimpleFind(\u0026amp;result, bson.M{\u0026#34;age\u0026#34;: bson.M{operator.Gt: 24}}) 自定义返回字段 查询并隐藏_id字段\nopts := options.FindOne().SetProjection(bson.D{{\u0026#34;_id\u0026#34;, 0}}) // 如果是调用的Find方法就应该是opts := options.Find().SetProjection(bson.D{{\u0026#34;_id\u0026#34;, 0}}) err := mgm.Coll(\u0026amp;Book{}).FindOne(nil, bson.M{}, opts) 查询并返回name和publish_year字段\nopts := options.FindOne().SetProjection(bson.D{{\u0026#34;_id\u0026#34;, 0},{\u0026#34;name\u0026#34;,1},{\u0026#34;publish_year\u0026#34;,1}}) // 如果是调用的Find方法就应该是opts := options.Find().SetProjection(bson.D{{\u0026#34;_id\u0026#34;, 0},{\u0026#34;name\u0026#34;,1},{\u0026#34;publish_year\u0026#34;,1}}) err := mgm.Coll(\u0026amp;Book{}).FindOne(nil, bson.M{}, opts) 自定义排序 查询并设置按字段排序.1表示升序，-1表示降序，下面的例子是按创建时间升序排列。\nopts := options.FindOne().SetSort(bson.M{\u0026#34;created_at\u0026#34;: 1}) // 如果是调用的Find方法就应该是opts := options.Find().SetSort(bson.M{\u0026#34;created_at\u0026#34;: 1}) err := mgm.Coll(\u0026amp;Book{}).FindOne(nil, bson.M{}, opts) 按多个字段进行排序\nopts := options.FindOne().SetSort(bson.D{{\u0026#34;created_at\u0026#34;,1},{\u0026#34;price\u0026#34;,-1}}) // 如果是调用的Find方法就应该是opts := options.Find().SetSort(bson.D{{\u0026#34;created_at\u0026#34;,1},{\u0026#34;price\u0026#34;,-1}}) err := mgm.Coll(\u0026amp;Book{}).FindOne(nil, bson.M{}, opts) 分页查询 一般从传统关系型数据库转过来的一般会使用skip+limit的组合，但是当数据量很大的时候，这种查询会变得很慢。所以推荐使用 range query + limit的方式.下面是一个简单的实现：\nvar lastId primitive.ObjectID coll := mgm.Coll(\u0026amp;Book{}) pageOptions := options.Find() pageOptions.SetSort(bson.M{\u0026#34;created_at\u0026#34;: -1}) pageOptions.SetLimit(pageSize) if page != 1 { pageFind := options.Find() pageFind.SetSort(bson.M{\u0026#34;created_at\u0026#34;: -1}) pageFind.SetLimit((page - 1) * pageSize) pageFind.SetProjection(bson.M{\u0026#34;_id\u0026#34;: 1}) cur, err := coll.Find(context.Background(), bson.M{}, pageFind) if err != nil { return } var data []primitive.ObjectID{} if err := cur.All(context.Background(), \u0026amp;data); err != nil { return } id:= data[len(data)-1] lastId = id } coll.Find(context.Background(), bson.M{\u0026#34;_id\u0026#34;: bson.M{operator.Gt: lastId}}, pageOptions) 每一次分页查询，都要把当前最后的一条记录的_id作为参数传给下一次调用。\n参考文章：\nhttps://isotropic.co/how-to-implement-pagination-in-mongodb/ https://www.codementor.io/@arpitbhayani/fast-and-efficient-pagination-in-mongodb-9095flbqr https://www.mongodb.com/blog/post/paging-with-the-bucket-pattern--part-1 https://www.mongodb.com/blog/post/paging-with-the-bucket-pattern--part-2 聚合 尽管我们可以使用官方go驱动中的聚合操作，但mgm也提供了更简单的方法：\n官方go驱动实现\nimport ( \u0026#34;github.com/kamva/mgm/v3\u0026#34; \u0026#34;github.com/kamva/mgm/v3/builder\u0026#34; \u0026#34;github.com/kamva/mgm/v3/field\u0026#34; . \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; ) // Author model collection authorColl := mgm.Coll(\u0026amp;Author{}) cur, err := mgm.Coll(\u0026amp;Book{}).Aggregate(mgm.Ctx(), A{ // S function get operators and return bson.M type. builder.S(builder.Lookup(authorColl.Name(), \u0026#34;author_id\u0026#34;, field.Id, \u0026#34;author\u0026#34;)), }) 使用mgm实现\nauthorCollName := mgm.Coll(\u0026amp;Author{}).Name() result := []Book{} // Lookup in just single line _ := mgm.Coll(\u0026amp;Book{}).SimpleAggregate(\u0026amp;result, builder.Lookup(authorCollName, \u0026#34;auth_id\u0026#34;, \u0026#34;_id\u0026#34;, \u0026#34;author\u0026#34;)) // Multi stage(mix of mgm builders and raw stages) _ := mgm.Coll(\u0026amp;Book{}).SimpleAggregate(\u0026amp;result, builder.Lookup(authorCollName, \u0026#34;auth_id\u0026#34;, \u0026#34;_id\u0026#34;, \u0026#34;author\u0026#34;), M{operator.Project: M{\u0026#34;pages\u0026#34;: 0}}, ) // Do something with result... 复杂点的例子\nimport ( \u0026#34;github.com/kamva/mgm/v3\u0026#34; \u0026#34;github.com/kamva/mgm/v3/builder\u0026#34; \u0026#34;github.com/kamva/mgm/v3/field\u0026#34; \u0026#34;github.com/kamva/mgm/v3/operator\u0026#34; . \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson/primitive\u0026#34; ) // Author model collection authorColl := mgm.Coll(\u0026amp;Author{}) _, err := mgm.Coll(\u0026amp;Book{}).Aggregate(mgm.Ctx(), A{ // S function get operators and return bson.M type. builder.S(builder.Lookup(authorColl.Name(), \u0026#34;author_id\u0026#34;, field.Id, \u0026#34;author\u0026#34;)), builder.S(builder.Group(\u0026#34;pages\u0026#34;, M{\u0026#34;books\u0026#34;: M{operator.Push: M{\u0026#34;name\u0026#34;: \u0026#34;$name\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;$author\u0026#34;}}})), M{operator.Unwind: \u0026#34;$books\u0026#34;}, }) if err != nil { panic(err) } 另外一个例子\nimport ( \u0026#34;github.com/kamva/mgm/v3\u0026#34; f \u0026#34;github.com/kamva/mgm/v3/field\u0026#34; o \u0026#34;github.com/kamva/mgm/v3/operator\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; ) // Instead of hard-coding mongo operators and fields _, _ = mgm.Coll(\u0026amp;Book{}).Aggregate(mgm.Ctx(), bson.A{ bson.M{\u0026#34;$count\u0026#34;: \u0026#34;\u0026#34;}, bson.M{\u0026#34;$project\u0026#34;: bson.M{\u0026#34;_id\u0026#34;: 0}}, }) // Use predefined operators and pipeline fields. _, _ = mgm.Coll(\u0026amp;Book{}).Aggregate(mgm.Ctx(), bson.A{ bson.M{o.Count: \u0026#34;\u0026#34;}, bson.M{o.Project: bson.M{f.Id: 0}}, }) 事务 Transaction 要在默认连接上运行事务，请使用 mgm.Transaction() 函数，例如: d := \u0026amp;Doc{Name: \u0026#34;Mehran\u0026#34;, Age: 10} err := mgm.Transaction(func(session mongo.Session, sc mongo.SessionContext) error { // do not forget to pass the session\u0026#39;s context to the collection methods. err := mgm.Coll(d).CreateWithCtx(sc, d) if err != nil { return err } return session.CommitTransaction(sc) }) 要使用您的上下文运行事务，请使用 mgm.TransactionWithCtx() 方法。 要在另一个连接上运行事务，请使用 mgm.TransactionWithClient() 方法。 参考资料 官方文档 Quick Start: Golang \u0026amp; MongoDB - Data Aggregation Pipeline Go By Example 官方GO驱动使用详解 Custom-marshal Golang structs with flattening https://medium.com/@amsokol.com/new-official-mongodb-go-driver-and-google-protobuf-making-them-work-together-6357b0118f3f ","permalink":"https://czyt.tech/post/golang-mongodb-mgm-odm-usage/","summary":"(本文大部分内容根据官方文档翻译而来)\n环境准备 golang 1.10+ mongodb mgm 模型定义 定义 定义模型\ntype Book struct { // DefaultModel adds _id, created_at and updated_at fields to the Model mgm.DefaultModel `bson:\u0026#34;,inline\u0026#34;` Name string `json:\u0026#34;name\u0026#34; bson:\u0026#34;name\u0026#34;` Pages int `json:\u0026#34;pages\u0026#34; bson:\u0026#34;pages\u0026#34;` } func NewBook(name string, pages int) *Book { return \u0026amp;Book{ Name: name, Pages: pages, } } mgm 在创建表时会自动检测Model生成的Collection名称\nbook:=Book{} // Print your model collection name. collName := mgm.CollName(\u0026amp;book) fmt.Println(collName) // 打印: books 如果要自定义生成Collection的名称。需要实现CollectionNameGetter接口。\nfunc (model *Book) CollectionName() string { return \u0026#34;my_books\u0026#34; } // mgm return \u0026#34;my_books\u0026#34; collection coll:=mgm.","title":"Golang MongoDB ODM mgm使用"},{"content":"在Flutter开发时，可能因为网络等原因导致maven不能正常工作，造成Flutter项目卡住的情况。下面是解决办法。原文链接 https://flutter.cn/community/china\n如果你在国内使用 Flutter，那么你可能需要找一个与官方同步的可信的镜像站点，帮助你的 Flutter 命令行工具到该镜像站点下载其所需的资源。你需要为此设置两个环境变量：PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL，然后再运行 Flutter 命令行工具。\n以 macOS 或者与 Linux 相近的系统为例，这里有以下步骤帮助你设定镜像。在系统终端里执行如下命令设定环境变量，并通过 GitHub 检出 Flutter SDK：\ncontent_copy\n$ export PUB_HOSTED_URL=https://pub.flutter-io.cn\r$ export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\r$ git clone -b dev https://github.com/flutter/flutter.git\r$ export PATH=\u0026#34;$PWD/flutter/bin:$PATH\u0026#34;\r$ cd ./flutter\r$ flutter doctor Flutter SDK配置修改 flutter的maven设置在\u0026lt;安装目录\u0026gt;\\packages\\flutter_tools\\gradle\\flutter.gradle\n打包配置 buildscript {\rrepositories {\rmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/central\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }\r// google()\r// jcenter()\r}\rdependencies {\r/* When bumping, also update ndkVersion above. */\rclasspath \u0026#39;com.android.tools.build:gradle:4.1.0\u0026#39;\r}\r} FlutterPlugin配置 class FlutterPlugin implements Plugin\u0026lt;Project\u0026gt; {\r// private static final String DEFAULT_MAVEN_HOST = \u0026#34;https://storage.googleapis.com\u0026#34;;\rprivate static final String MAVEN_REPO = \u0026#34;https://storage.flutter-io.cn/download.flutter.io\u0026#34;; 所有项目设置 rootProject.allprojects {\rrepositories {\rmaven {\rurl repository\r}\r// 添加下面的内容\rmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; }\r}\r} Flutter项目配置修改 修改Flutter项目下的android下的build.gradle\nbuildscript {\rext.kotlin_version = \u0026#39;1.6.10\u0026#39;\rrepositories {\r// google()\r// jcenter()\rmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; }\r}\rdependencies {\rclasspath \u0026#39;com.android.tools.build:gradle:7.1.2\u0026#39;\rclasspath \u0026#34;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\u0026#34;\r}\r}\rallprojects {\rrepositories {\r// google()\r// jcenter()\rmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; }\r}\r} 配置完毕。\n相关资源 在中国网络环境下使用 Flutter\n阿里云Maven中央仓库 ","permalink":"https://czyt.tech/post/maven-setting-for-flutter-dev/","summary":"在Flutter开发时，可能因为网络等原因导致maven不能正常工作，造成Flutter项目卡住的情况。下面是解决办法。原文链接 https://flutter.cn/community/china\n如果你在国内使用 Flutter，那么你可能需要找一个与官方同步的可信的镜像站点，帮助你的 Flutter 命令行工具到该镜像站点下载其所需的资源。你需要为此设置两个环境变量：PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL，然后再运行 Flutter 命令行工具。\n以 macOS 或者与 Linux 相近的系统为例，这里有以下步骤帮助你设定镜像。在系统终端里执行如下命令设定环境变量，并通过 GitHub 检出 Flutter SDK：\ncontent_copy\n$ export PUB_HOSTED_URL=https://pub.flutter-io.cn\r$ export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\r$ git clone -b dev https://github.com/flutter/flutter.git\r$ export PATH=\u0026#34;$PWD/flutter/bin:$PATH\u0026#34;\r$ cd ./flutter\r$ flutter doctor Flutter SDK配置修改 flutter的maven设置在\u0026lt;安装目录\u0026gt;\\packages\\flutter_tools\\gradle\\flutter.gradle\n打包配置 buildscript {\rrepositories {\rmaven { url \u0026#39;https://maven.aliyun.com/repository/google\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/public\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/central\u0026#39; }\rmaven { url \u0026#39;https://maven.aliyun.com/repository/jcenter\u0026#39; }\r// google()\r// jcenter()\r}\rdependencies {\r/* When bumping, also update ndkVersion above.","title":"Flutter开发Maven配置"},{"content":"TL;DR\n环境准备 mongoDB 预备知识 MongoDB常见的数据类型\n数据类型 示例 说明 Null {\u0026quot;x\u0026quot; : null} Boolean {\u0026quot;x\u0026quot; : true} Number {\u0026quot;x\u0026quot; : 3.14} {\u0026quot;x\u0026quot; : 3} {\u0026quot;x\u0026quot; : NumberInt(\u0026quot;3\u0026quot;)} {\u0026quot;x\u0026quot; : NumberLong(\u0026quot;3\u0026quot;)} 默认64位浮点数，整数需要使用NumberInt和NumberLong String {\u0026quot;x\u0026quot; : \u0026quot;foobar\u0026quot;} 编码格式为UTF-8 Date {\u0026quot;x\u0026quot; : new Date()} 64位时间戳(从January 1, 1970)，不存时区。通过new Date()进行调用。 Regular expression {\u0026quot;x\u0026quot; : /foobar/i} javascript 正则 Array {\u0026quot;x\u0026quot; : [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]} Embedded document {\u0026quot;x\u0026quot; : {\u0026quot;foo\u0026quot; : \u0026quot;bar\u0026quot;}} Object ID {\u0026quot;x\u0026quot; : ObjectId()} 文档12字节的ID Binary data 一个任意字节的字符串。是保存非UTF-8字符串到数据库的唯一方法。 Code {\u0026quot;x\u0026quot; : function() { /* ... */ }} 数据操作 数据库连接 连接字符串 MongoDB的连接字符串为如下格式\n示例连接地址 mongodb://user:pass@sample.host:27017/?maxPoolSize=20\u0026amp;w=majority\n官方提供的连接字符选项说明\nOption Name Type Default Value Description connectTimeoutMS integer 30000 Specifies the number of milliseconds to wait before timeout on a TCP connection. maxPoolSize integer 100 Specifies the maximum number of connections that a connection pool may have at a given time. replicaSet string null Specifies the replica set name for the cluster. All nodes in the replica set must have the same replica set name, or the Client will not consider them as part of the set. maxIdleTimeMS integer 0 Specifies the maximum amount of time a connection can remain idle in the connection pool before being removed and closed. The default is 0, meaning a connection can remain unused indefinitely. minPoolSize integer 0 Specifies the minimum number of connections that the driver maintains in a single connection pool. socketTimeoutMS integer 0 Specifies the number of milliseconds to wait for a socket read or write to return before returning a network error. The 0 default value indicates that there is no timeout. serverSelectionTimeoutMS integer 30000 Specifies the number of milliseconds to wait to find an available, suitable server to execute an operation. heartbeatFrequencyMS integer 10000 Specifies the number of milliseconds to wait between periodic background server checks. tls boolean false Specifies whether to establish a Transport Layer Security (TLS) connection with the instance. This is automatically set to true when using a DNS seedlist (SRV) in the connection string. You can override this behavior by setting the value to false. w string or integer null Specifies the write concern. To learn more about values, see the server documentation on Write Concern options. directConnection boolean false Specifies whether to force dispatch all operations to the host specified in the connection URI. 数据库驱动 这里以Golang语言为例。本文使用MongoDB标准数据库驱动，未使用ODM框架如mgm、upper/db、mango等。引入方法\nimport \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; Demo程序如下:\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/options\u0026#34; \u0026#34;go.mongodb.org/mongo-driver/mongo/readpref\u0026#34; ) // Connection URI const uri = \u0026#34;mongodb://user:pass@sample.host:27017/?maxPoolSize=20\u0026amp;w=majority\u0026#34; func main() { // Create a new client and connect to the server client, err := mongo.Connect(context.TODO(), options.Client().ApplyURI(uri)) if err != nil { panic(err) } defer func() { if err = client.Disconnect(context.TODO()); err != nil { panic(err) } }() // Ping the primary if err := client.Ping(context.TODO(), readpref.Primary()); err != nil { panic(err) } fmt.Println(\u0026#34;Successfully connected and pinged.\u0026#34;) } BSON简介 ​ MongoDB中的JSON文档存储在名为BSON(二进制编码的JSON)的二进制表示中。与其他将JSON数据存储为简单字符串和数字的数据库不同，BSON编码扩展了JSON表示，使其包含额外的类型，如int、long、date、浮点数和decimal128。这使得应用程序更容易可靠地处理、排序和比较数据。\n连接MongoDB的Go驱动程序中有两大类型表示BSON数据：D和Raw。\n类型D家族被用来简洁地构建使用本地Go类型的BSON对象。这对于构造传递给MongoDB的命令特别有用。D家族包括四类:\nD：一个BSON文档。这种类型应该在顺序重要的情况下使用，比如MongoDB命令。 M：一张无序的map。它和D是一样的，只是它不保持顺序。 A：一个BSON数组。 E：D里面的一个元素。 要使用BSON，需要先导入下面的包：\nimport \u0026#34;go.mongodb.org/mongo-driver/bson\u0026#34; 下面是一个使用D类型构建的过滤器文档的例子，它可以用来查找name字段与’张三’或’李四’匹配的文档:\nbson.D{{ \u0026#34;name\u0026#34;, bson.D{{ \u0026#34;$in\u0026#34;, bson.A{\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;}, }}, }} Raw类型家族用于验证字节切片。你还可以使用Lookup()从原始类型检索单个元素。如果你不想要将BSON反序列化成另一种类型的开销，那么这是很有效的一种手段。下面介绍MongoDB的一些基本操作。\n新增数据 insertOne insertOne用于插入一条记录:\ndb.movies.insertOne({\u0026#34;title\u0026#34; : \u0026#34;Stand by Me\u0026#34;}) insertMany insertMany用于插入多条记录：\ndb.movies.insertMany([{\u0026#34;title\u0026#34; : \u0026#34;Ghostbusters\u0026#34;}, {\u0026#34;title\u0026#34; : \u0026#34;E.T.\u0026#34;}, {\u0026#34;title\u0026#34; : \u0026#34;Blade Runner\u0026#34;}]); 删除数据 deleteOne db.movies.deleteOne({\u0026#34;_id\u0026#34; : 4}) deleteMany db.mailing.list.deleteMany({\u0026#34;opt-out\u0026#34; : true}) drop drop用于删除collection\ndb.movies.drop() 更新数据 一般更新 一般更新使用findOneAndReplace updateOne updateMany方法。\n常见逻辑操作符\n操作符 含义 示例 $inc 数值类型数据增加。可用于数值类型 integer long double decimal的增加及减小。 db.analytics.updateOne({\u0026quot;url\u0026quot; : \u0026quot;www.example.com\u0026quot;}, {\u0026quot;$inc\u0026quot; : {\u0026quot;pageviews\u0026quot; : 1}}) $mul 乘法（$mul）运算符用于将一个数字字段的值乘以 给定的数字。 db.movies.findOneAndUpdate( {\u0026quot;title\u0026quot; : \u0026quot;Macbeth\u0026quot;},{$mul : {\u0026quot;rating\u0026quot; : 2}},{returnNewDocument : true}) $rename $rename操作符用于重命名字段。 db.movies.findOneAndUpdate({\u0026quot;title\u0026quot; : \u0026quot;Macbeth\u0026quot;},{$rename : {\u0026quot;num_mflix_comments\u0026quot; : \u0026quot;comments\u0026quot;, \u0026quot;imdb_rating\u0026quot; : \u0026quot;rating\u0026quot;}}, {returnNewDocument : true}) $set 更新字段值，不存在会自动创建。 db.user.updateOne({_id:2},{\u0026quot;$set\u0026quot;:{\u0026quot;lovemusic\u0026quot;:\u0026quot;jaychou\u0026quot;}}); $setOnInsert $setOnInsert与$set类似，但是，它只在upsert插入操作时设置给定的字段。如果要更新的文档存在则不更新。 db.products.update( { _id: 1 }, { $set: { item: \u0026quot;apple\u0026quot; }, $setOnInsert: { defaultQty: 100 } }, { upsert: true } ) $unset 删除键及对应的值 示例1db.user.updateOne({_id:2},{\u0026quot;$unset\u0026quot;:{\u0026quot;lovemusic\u0026quot;:\u0026quot;jaychou\u0026quot;}});示例2db.user.update({\u0026quot;email_state\u0026quot;:{\u0026quot;$exists\u0026quot;:true}},{\u0026quot;$unset\u0026quot;:{\u0026quot;email_state\u0026quot;,\u0026quot;\u0026quot;}},{multi:true});该语句将删除表的email_state字段 $push 当字段为数组对象时，更新字段使用。可以往数组对象添加记录。 db.blog.posts.updateOne({\u0026quot;title\u0026quot; : \u0026quot;A blog post\u0026quot;},{\u0026quot;$push\u0026quot; : {\u0026quot;comments\u0026quot; :{\u0026quot;name\u0026quot; : \u0026quot;joe\u0026quot;, \u0026quot;email\u0026quot; : \u0026quot;joe@example.com\u0026quot;,\u0026quot;content\u0026quot; : \u0026quot;nice post.\u0026quot;}}}) $each 和$push配合使用，适用于一次操作添加多个记录的情况 db.stock.ticker.updateOne({\u0026quot;_id\u0026quot; : \u0026quot;GOOG\u0026quot;}, {\u0026quot;$push\u0026quot; : {\u0026quot;hourly\u0026quot; : {\u0026quot;$each\u0026quot; : [562.776, 562.790, 559.123]}}}) $slice 配合$push和$each使用，用于限制字段数组的最大长度。右侧的示例意思为，将数组内容限制为10条记录，导入优先级从后向前。单独使用，可以实现TOP的效果 配合使用db.movies.updateOne({\u0026quot;genre\u0026quot; : \u0026quot;horror\u0026quot;}, {\u0026quot;$push\u0026quot; : {\u0026quot;top10\u0026quot; : {\u0026quot;$each\u0026quot; : [\u0026quot;Nightmare on Elm Street\u0026quot;, \u0026quot;Saw\u0026quot;], \u0026quot;$slice\u0026quot; : -10}}})单独使用db.blog.posts.findOne(criteria, {\u0026quot;comments\u0026quot; : {\u0026quot;$slice\u0026quot; : 10}})返回前10条记录db.blog.posts.findOne(criteria, {\u0026quot;comments\u0026quot; : {\u0026quot;$slice\u0026quot; : [23, 10]}})返回从24条开始的10条数据 db.blog.posts.findOne(criteria, {\u0026quot;comments\u0026quot; : {\u0026quot;$slice\u0026quot; : -1}})返回最后一条评论 $sort 配合$push和$each使用,用于设置添加记录字段的排序，1升序 -1 降序 db.movies.updateOne({\u0026quot;genre\u0026quot; : \u0026quot;horror\u0026quot;}, {\u0026quot;$push\u0026quot; : {\u0026quot;top10\u0026quot; : {\u0026quot;$each\u0026quot; : [{\u0026quot;name\u0026quot; : \u0026quot;Nightmare on Elm Street\u0026quot;, \u0026quot;rating\u0026quot; : 6.6}, {\u0026quot;name\u0026quot; : \u0026quot;Saw\u0026quot;, \u0026quot;rating\u0026quot; : 4.3}], \u0026quot;$slice\u0026quot; : -10, \u0026quot;$sort\u0026quot; : {\u0026quot;rating\u0026quot; : -1}}}}) $ne 判断记录是否已经存在于数组。可以理解为Is Not Exist db.papers.updateOne({\u0026quot;authors cited\u0026quot; : {\u0026quot;$ne\u0026quot; : \u0026quot;Richie\u0026quot;}},{$push : {\u0026quot;authors cited\u0026quot; : \u0026quot;Richie\u0026quot;}}) $currentDate $currentDate用于设置一个给定字段的值为当前的 日期或时间戳。 db.movies.findOneAndUpdate( {\u0026quot;title\u0026quot; : \u0026quot;Macbeth\u0026quot;}, {$currentDate : { \u0026quot;created_date\u0026quot; : true, \u0026quot;last_updated.date\u0026quot; : {$type : \u0026quot;date\u0026quot;}, \u0026quot;last_updated.timestamp\u0026quot; : {$type : \u0026quot;timestamp\u0026quot;},}}, {returnNewDocument : true}) $addToSet 功能与$ne有部分重叠，添加前会检查是否存在以避免重复，适用于$ne不适用的场景且有更好的描述性。 db.users.updateOne({\u0026quot;_id\u0026quot; : ObjectId(\u0026quot;4b2d75476cc613d5ee930164\u0026quot;)},{\u0026quot;$addToSet\u0026quot; : {\u0026quot;emails\u0026quot; : \u0026quot;joe@hotmail.com\u0026quot;}}) $pop 从数组尾部移除。{\u0026quot;$pop\u0026quot; : {\u0026ldquo;key\u0026rdquo; : 1}}从尾部移除1条记录，{\u0026quot;$pop\u0026quot; : {\u0026ldquo;key\u0026rdquo; : -1}}从前面移除1条记录。 $pull 移除所有满足条件的记录。例如记录为[1,2,3,1]调用$pull删除1，则只剩下[2,3] 插入几条数据db.lists.insertOne({\u0026quot;todo\u0026quot; : [\u0026quot;dishes\u0026quot;,dishes\u0026quot;, \u0026quot;laundry\u0026quot;, \u0026quot;dry cleaning\u0026quot;]}) 删除一条数据 db.lists.updateOne({}, {\u0026quot;$pull\u0026quot; : {\u0026quot;todo\u0026quot; : \u0026quot;dishes\u0026quot;}}) $ 位置运算符，用于替代筛选记录的Index。该运算符只更新第一个匹配的记录。 db.blog.updateOne({\u0026quot;comments.author\u0026quot; : \u0026quot;John\u0026quot;},{\u0026quot;$set\u0026quot; : {\u0026quot;comments.$.author\u0026quot; : \u0026quot;Jim\u0026quot;}}) arrayFilters db.blog.updateOne({\u0026quot;post\u0026quot; : post_id },{ $set: { \u0026quot;comments.$[elem].hidden\u0026quot; : true } },{ arrayFilters: [ { \u0026quot;elem.votes\u0026quot;: { $lte: -5 } } ]}) Upsert更新 Upsert是一种特殊的更新。如果记录不存在会合并筛选条件和更新记录来自动创建记录。示例：\ndb.post.updateOne({title:\u0026#34;my love song\u0026#34;},{$set:{content:{head:\u0026#34;js\u0026#34;,body:\u0026#34;javascript\u0026#34;}}},{upsert:true}); 查询数据 MongoDB 常用查询的逻辑操作符如下：\n运算符 含义 $lt \u0026lt; $lte \u0026lt;= $gt \u0026gt; $gte \u0026gt;= $ne != $in in $nin not in $or or $not not $nor $nor操作符在语法上与$or相似，但行为方式相反。$nor运算符$nor操作符以数组的形式接受多个条件表达式，并且 返回不满足任何给定条件的文档。db.movies.find({$nor:[{\u0026quot;rated\u0026quot; : \u0026quot;G\u0026quot;},{\u0026quot;year\u0026quot; : 2005}, {\u0026quot;num_mflix_comments\u0026quot; : {$gte : 5}}]}) $mod mod取模运算。如 db.users.find({\u0026quot;id_num\u0026quot; : {\u0026quot;$mod\u0026quot; : [5, 1]}})返回用户id为1 , 6 , 11 , 16等符合取模运算的记录。 $regex 正则匹配 $all 所有 满足条件的记录 $size 将数组长度作为查询的一部分。如db.food.find({\u0026quot;fruit\u0026quot; : {\u0026quot;$size\u0026quot; : 3}})表示查询所有fruit字段值为3元素数组的记录。 $elemMatch 强迫MongoDB用一个单个数组元素进行比较，不匹配非数组元素.db.test.find({\u0026quot;x\u0026quot; : {\u0026quot;$elemMatch\u0026quot; : {\u0026quot;$gt\u0026quot; : 10, \u0026quot;$lt\u0026quot; : 20}}})表示查询字段为数组且数组元素均满足 10\u0026lt;x\u0026lt;20的记录。 $where $match db.companies.aggregate([{$match: {founded_year: 2004}}])等价于db.companies.find({founded_year: 2004}) find/findOne find用于查询所有满足条件的记录。示例:\ndb.users.find({\u0026#34;username\u0026#34; : \u0026#34;joe\u0026#34;}) 注:传入{}表示全部查询。\n指定返回字段的查询，示例: db.users.find({}, {\u0026#34;username\u0026#34; : 1, \u0026#34;email\u0026#34; : 1}) 默认是要返回_id字段，如果要隐藏，则上面的语句需要改成下面的语句(其他字段如果需要隐藏，操作也是类似):\ndb.users.find({}, {\u0026#34;username\u0026#34; : 1,\u0026#34;email\u0026#34; : 1, \u0026#34;_id\u0026#34; : 0}) 比较查询 db.users.find({\u0026#34;age\u0026#34; : {\u0026#34;$gte\u0026#34; : 18, \u0026#34;$lte\u0026#34; : 30}}) IN查询 db.raffle.find({\u0026#34;ticket_no\u0026#34; : {\u0026#34;$in\u0026#34; : [725, 542, 390]}}) OR查询 db.raffle.find({\u0026#34;$or\u0026#34; : [{\u0026#34;ticket_no\u0026#34; : 725}, {\u0026#34;winner\u0026#34; : true}]}) 查询字段为null的记录 db.c.find({\u0026#34;z\u0026#34; : {\u0026#34;$eq\u0026#34; : null, \u0026#34;$exists\u0026#34; : true}}) 默认查询不存在的记录会返回所有的记录，所以需要添加$exist来检查记录是否存在。\n数组查询，如一个表有下面的记录： 则可以使用语句db.food.find({\u0026quot;fruit\u0026quot; : \u0026quot;banana\u0026quot;})进行查询。如果要查询多条数据，可以使用$all来查询，示例语句db.food.find({fruit : {$all : [\u0026quot;apple\u0026quot;, \u0026quot;banana\u0026quot;]}})表示查询所有fruit为apple和banana的记录。\n正则模糊匹配查询\ndb.users.find( {\u0026#34;name\u0026#34; : {\u0026#34;$regex\u0026#34; : /joe/i } }) 注：MongoDB的正则引擎为PCRE\nsort 设置按记录字段的排序。\ndb.c.find().sort({username : 1, age : -1}) 注：1 表示升序排列 -1 表示降序排列。\nskip 跳过数据条数。类似于limit，区别在于Skip设置的是数据数量的下限。\ndb.c.find().skip(3) 当Skip的数字较大时，请勿使用skip，这会影响数据库的性能。\nlimit 限制返回记录条数。limit设置的是数据数量的上限。\ndb.c.find().limit(3) distinct 查询去重。\ndb.movies.distinct(\u0026#34;rated\u0026#34;, {\u0026#34;year\u0026#34; : 1994}) countDocuments/count/estimatedDocumentCount 查询统计\ndb.movies.countDocuments({\u0026#34;year\u0026#34;: 1999}) 聚合查询 Aggregation ​\tMongoDB聚合查询用于对数据文档进行变换和组合。实现上，MongoDB聚合管道基于数据流的概念，数据进入管道经过多个stage操作（主要有筛选、投射、分组、排序、限制及跳过），最终输出。常用管道操作符参考下表：\n操作符 简述 $project 投射操作符，用于重构每一个文档的字段，可以提取字段，重命名字段，甚至可以对原有字段进行操作后新增字段。如db.users.aggregate([{ $project : { userId: '$_id', _id: 0 } }]);将_id 字段重命名为userId ，不显示字段_id。 $match 匹配操作符，用于对文档集合进行筛选。 $group 分组操作符，用于对文档集合进行分组。_id字段是必须的。db.users.aggregate([{$group : {_id: '$sex',avgAge: { $avg: '$age' }, count: { $sum: 1 }}} ]);将用户按性别分组并显示各性别的平均年龄，最后返回各性别人数。db.users.aggregate([{$match:{locale:{$eq:\u0026quot;zh-Hans\u0026quot;}}},{$group: {_id: \u0026quot;$username\u0026quot;,Email: {$addToSet: \u0026quot;$email\u0026quot;,}}}])返回语言为中文的用户邮件地址并按用户名分组 $unwind 拆分操作符，用于将数组中的每一个值拆分为单独的文档。 $sort 排序操作符，用于根据一个或多个字段对文档进行排序。如db.users.aggregate([{ $sort : { age: 1 } }]);将用户按字段age升序排列。 $limit 限制操作符，用于限制返回文档的数量。 $skip 跳过操作符，用于跳过指定数量的文档。 $lookup 连接操作符，用于连接同一个数据库中另一个集合，并获取指定的文档，类似于populate。 $count 统计操作符，用于统计文档的数量。 $sum 对文档字段求和。 $avg 对文档字段进行平均值计算。 更多管道操作符,参考官网、中文文档。\n数据库定义与设计 按官方博客的MongoDB设计模式，大致可分为下面几种（机翻整理）。\n模式名 适用场景 优点 缺点 Approximation 当频繁进行昂贵的计算并且这些计算的精度不是最高优先级时，近似模式很有用。 对数据库的写入更少。保持统计上有效的数字。 没有表示确切的数字。必须在应用程序中执行。 Attribute 属性模式对于基于具有许多相似字段的大型文档的问题很有用，但是有一个共享共同特征的字段子集，我们希望对该字段子集进行排序或查询。当我们需要排序的字段仅在一小部分文档中找到时。或者当文档中同时满足这两个条件时。 需要更少的索引。查询变得更容易编写并且通常更快。 Bucket 当需要管理流数据时，桶模式是一个很好的解决方案，例如时间序列、实时分析或物联网 (IoT) 应用程序。 减少集合中的文档总数。提高索引性能。可以通过利用预聚合来简化数据访问。 Computed 当存在读取密集型数据访问模式并且该数据需要由应用程序重复计算时，计算模式是一个很好的探索选择。 减少频繁计算的 CPU 工作量。查询变得更容易编写并且通常更快。 可能很难确定对这种模式的需求。除非需要，否则应避免应用或过度使用该模式。 Document Versioning 当您需要在 MongoDB 中维护以前版本的文档时，文档版本控制模式是一种可能的解决方案。 即使在现有系统上也易于实施。对最新版本的查询没有性能影响。 写入次数翻倍。查询需要针对正确的集合。 Extended Reference 当您的应用程序经历大量 JOIN 操作以汇集经常访问的数据时， 您会发现扩展引用模式最有用。 当有很多 JOIN 操作时提高性能。更快的读取和 JOIN 总数的减少。 数据重复。 Outlier 您是否发现有一些查询或文档不适合您的其他典型数据模式？这些例外是否在推动您的应用解决方案？如果是这样，异常值模式是解决这种情况的绝妙方法。 防止一些文档或查询确定应用程序的解决方案。查询是针对“典型”用例量身定制的，但仍会处理异常值。 通常为特定查询量身定制，因此临时查询可能表现不佳。这种模式的大部分是通过应用程序代码完成的。 Pre-allocation 当您知道您的文档结构并且您的应用程序只需要用数据填充它时，预分配模式是正确的选择。 事先知道文档结构时的设计简化。 简单性与性能。 Polymorphic 多态模式是当存在多种文档的相似性多于差异并且需要将文档保存在单个集合中时的解决方案。 易于实施。查询可以跨单个集合运行。 Schema Versioning 几乎每个应用程序都可以从模式版本控制模式中受益，因为数据模式的更改经常发生在应用程序的生命周期中。此模式允许文档的先前版本和当前版本并排存在于集合中。 无需停机。控制模式迁移。减少未来的技术债务。 在迁移期间可能需要为同一字段创建两个索引。 Subset 子集模式解决了由于文档中的大部分数据未被应用程序使用而导致工作集超出 RAM 容量的问题。 减少工作集的整体大小。最常用数据的磁盘访问时间更短。 我们必须管理子集。提取额外数据需要额外访问数据库。 Tree 当数据具有层次结构并且经常被查询时，树模式是要实现的设计模式。 通过避免多次 JOIN 操作来提高性能。 需要在应用程序中管理对图形的更新。 近似模式Approximation 想象一个相当大的城市，大约有 39,000 人。随着人们进出城市、婴儿出生和人们死亡，确切的数字非常不稳定。我们可以花时间尝试每天获得准确数量的居民。但大多数时候，39,000 这个数字“足够好”。同样，在我们开发的许多应用程序中，知道一个“足够好”的数字就足够了。如果“足够好”的数字足够好，那么这是将近似模式应用于您的模式设计的绝佳机会。\n近似模式 当我们需要显示具有挑战性或资源昂贵的计算（时间、内存、CPU 周期）来计算以及精度不是最高优先级时，我们可以使用*近似模式。*再想想人口问题。准确计算该数字的成本是多少？自从我开始计算以来，它会改变还是可能改变？如果报告为 39,000 而实际上是 39,012，对城市的规划战略有何影响？\n从应用程序的角度来看，我们可以构建一个近似因子，这将允许更少的数据库写入，并且仍然提供统计上有效的数字。例如，假设我们的城市规划策略是基于每 10,000 人需要一辆消防车。100 人似乎是一个很好的规划“更新”期。“我们正在接近下一个门槛，更好地开始预算。”\n然后在应用程序中，我们可以构建一个计数器，而不是每次更改都更新数据库中的人口，并且只更新 100 次，即 1% 的时间。我们的写入在这里显着减少，在这个例子中减少了 99%。另一种选择可能是有一个返回随机数的函数。例如，如果该函数返回一个从 0 到 100 的数字，那么它将在大约 1% 的时间内返回 0。当满足该条件时，我们将计数器增加 100。\n我们为什么要关心这个？好吧，当处理大量数据或大量用户时，写入操作对性能的影响也会很大。你扩大的规模越大，影响也越大，而且在规模上，这通常是你最重要的考虑因素。通过减少写入并减少不需要“完美”的数据的资源，它可以带来性能的巨大改进。\n示例用例 人口模式是近似模式的一个例子。我们可以使用此模式的另一个用例是网站视图。一般来说，知道是否有 700,000 人访问了该网站，还是 699,983 人并不重要。因此，我们可以在我们的应用程序中构建一个计数器，并在达到我们的阈值时在数据库中更新它。\n这可能会极大地降低网站的性能。将时间和资源花在业务关键的数据写入上是有意义的。将它们全部花在页面计数器上似乎并不是对资源的充分利用。\n电影网站 - 减少写作工作量\n在上图中，我们看到了如何使用近似模式并不仅减少计数器操作的写入，而且我们还可以看到通过减少这些写入来降低架构复杂性和成本。这可以进一步节省写入数据的时间。*与我们之前探讨的计算模式*类似，它不必频繁地运行计算，从而节省了整体 CPU 使用率。\n结论 对于处理难以计算和/或计算成本高昂的数据并且这些数字的准确性不是关键任务的应用程序，*近似模式是一种出色的解决方案。*我们可以减少对数据库的写入，从而提高性能，并且仍然保持统计上有效的数字。然而，使用这种模式的代价是没有表示确切的数字，并且必须在应用程序本身中完成实现。\n属性模式Attribute 属性模式特别适合以下情况：\n我们有包含许多相似字段的大型文档，但是有一个具有共同特征的字段子集，我们希望对该字段子集进行排序或查询，或者 我们需要排序的字段只能在一小部分文档中找到，或者 上述两个条件都在文件中得到满足。 出于性能原因，为了优化我们的搜索，我们可能需要许多索引来解释所有子集。创建所有这些索引可能会降低性能。属性模式为这些情况提供了一个很好的解决方案。\n属性模式 让我们考虑一下电影的集合。这些文档可能在所有文档中都涉及类似的字段：标题、导演、制片人、演员等。假设我们要搜索发布日期。这样做时我们面临的一个挑战是哪个发布日期？电影通常在不同国家的不同日期上映。\n{\rtitle: \u0026#34;Star Wars\u0026#34;,\rdirector: \u0026#34;George Lucas\u0026#34;,\r...\rrelease_US: ISODate(\u0026#34;1977-05-20T01:00:00+01:00\u0026#34;),\rrelease_France: ISODate(\u0026#34;1977-10-19T01:00:00+01:00\u0026#34;),\rrelease_Italy: ISODate(\u0026#34;1977-10-20T01:00:00+01:00\u0026#34;),\rrelease_UK: ISODate(\u0026#34;1977-12-27T01:00:00+01:00\u0026#34;),\r...\r} 搜索发布日期需要同时查看多个字段。为了快速搜索上映日期，我们的电影收藏需要几个索引：\n{release_US: 1}\r{release_France: 1}\r{release_Italy: 1}\r... 通过使用属性模式，我们可以将这个信息子集移动到一个数组中并减少索引需求。我们将此信息转换为键值对数组：\n{\rtitle: \u0026#34;Star Wars\u0026#34;,\rdirector: \u0026#34;George Lucas\u0026#34;,\r…\rreleases: [\r{\rlocation: \u0026#34;USA\u0026#34;,\rdate: ISODate(\u0026#34;1977-05-20T01:00:00+01:00\u0026#34;)\r},\r{\rlocation: \u0026#34;France\u0026#34;,\rdate: ISODate(\u0026#34;1977-10-19T01:00:00+01:00\u0026#34;)\r},\r{\rlocation: \u0026#34;Italy\u0026#34;,\rdate: ISODate(\u0026#34;1977-10-20T01:00:00+01:00\u0026#34;)\r},\r{\rlocation: \u0026#34;UK\u0026#34;,\rdate: ISODate(\u0026#34;1977-12-27T01:00:00+01:00\u0026#34;)\r},\r… ],\r… } 通过在数组中的元素上创建一个索引，索引变得更易于管理：\n{ \u0026#34;releases.location\u0026#34;: 1, \u0026#34;releases.date\u0026#34;: 1} 通过使用属性模式，我们可以为我们的文档添加组织以获取常见特征并解释稀有/不可预测的字段。例如，在新的或小型的电影节上上映的电影。此外，转向键/值约定允许使用非确定性命名和轻松添加限定符。例如，如果我们的数据收集是关于瓶装水，我们的属性可能类似于：\n\u0026#34;specs\u0026#34;: [\r{ k: \u0026#34;volume\u0026#34;, v: \u0026#34;500\u0026#34;, u: \u0026#34;ml\u0026#34; },\r{ k: \u0026#34;volume\u0026#34;, v: \u0026#34;12\u0026#34;, u: \u0026#34;ounces\u0026#34; }\r] 在这里，我们将信息分解为键和值，“k”和“v”，并添加第三个字段“u”，它允许单独存储度量单位。\n{\u0026#34;specks.k\u0026#34;: 1, \u0026#34;specs.v\u0026#34;: 1, \u0026#34;specs.u\u0026#34;: 1} 示例用例 属性模式非常适合具有相同值类型的字段集的模式，例如日期列表。在处理产品特性时，它也能很好地工作。某些产品（例如服装）的尺寸可能以小号、中号或大号表示。同一集合中的其他产品可能以数量表示。还有一些可以用物理尺寸或重量来表示。\n资产管理领域的一位客户最近使用属性模式部署了他们的解决方案。客户使用该模式来存储给定资产的所有特征。这些特征在资产中很少常见，或者在设计时很难预测。关系模型通常使用复杂的设计过程以用户定义字段的形式表达相同的想法。\n虽然产品目录中的许多字段相似，例如名称、供应商、制造商、原产国等，但项目的规格或属性可能不同。如果您的应用程序和数据访问模式依赖于同时搜索许多不同的字段，则属性模式为数据提供了良好的结构。\n结论 属性模式提供了更轻松的文档索引，针对每个文档的许多相似字段。通过将这个数据子集移动到一个键值子文档中，我们可以使用非确定性的字段名称，为信息添加额外的限定符，更清楚地说明原始字段和值的关系。当我们使用属性模式时，我们需要更少的索引，我们的查询变得更容易编写，我们的查询变得更快。\n桶模式 Bucket 这种模式在处理物联网 (IoT)、实时分析或一般时间序列数据时特别有效。通过将数据分组在一起，我们可以更轻松地组织特定的数据组，提高发现历史趋势或提供未来预测的能力，并优化我们对存储的使用。\n桶模式 随着一段时间内的数据流（时间序列数据）进入，我们可能倾向于将每个测量值存储在自己的文档中。然而，这种倾向是处理数据的一种非常相关的方法。如果我们有一个传感器每分钟测量一次温度并将其保存到数据库中，我们的数据流可能类似于：\n{\rsensor_id: 12345,\rtimestamp: ISODate(\u0026#34;2019-01-31T10:00:00.000Z\u0026#34;),\rtemperature: 40\r}\r{\rsensor_id: 12345,\rtimestamp: ISODate(\u0026#34;2019-01-31T10:01:00.000Z\u0026#34;),\rtemperature: 40\r}\r{\rsensor_id: 12345,\rtimestamp: ISODate(\u0026#34;2019-01-31T10:02:00.000Z\u0026#34;),\rtemperature: 41\r} 随着我们的应用程序在数据和索引大小方面的扩展，这可能会带来一些问题。例如，我们最终可能不得不为每一个单独的测量建立索引sensor_id，timestamp以便以 RAM 为代价实现快速访问。但是，通过利用文档数据模型，我们可以按时间将这些数据“存储”到包含特定时间跨度的测量值的文档中。我们还可以以编程方式向这些“桶”中的每一个添加附加信息。\n通过将桶模式应用于我们的数据模型，我们在节省索引大小、潜在的查询简化以及在文档中使用预聚合数据的能力方面获得了一些好处。从上面获取数据流并将 Bucket Pattern 应用到它，我们最终会得到：\n{\rsensor_id: 12345,\rstart_date: ISODate(\u0026#34;2019-01-31T10:00:00.000Z\u0026#34;),\rend_date: ISODate(\u0026#34;2019-01-31T10:59:59.000Z\u0026#34;),\rmeasurements: [\r{\rtimestamp: ISODate(\u0026#34;2019-01-31T10:00:00.000Z\u0026#34;),\rtemperature: 40\r},\r{\rtimestamp: ISODate(\u0026#34;2019-01-31T10:01:00.000Z\u0026#34;),\rtemperature: 40\r},\r… {\rtimestamp: ISODate(\u0026#34;2019-01-31T10:42:00.000Z\u0026#34;),\rtemperature: 42\r}\r],\rtransaction_count: 42,\rsum_temperature: 2413\r} 通过使用存储桶模式，我们将数据“存储”到了一个一小时的存储桶中。这个特定的数据流仍然会增长，因为它目前只有 42 个测量值；该小时还有更多测量值要添加到“存储桶”中。当它们被添加到measurements数组中时，transaction_count将增加并且sum_temperature也将被更新。\n使用预先汇总的sum_temperature值，就可以轻松地拉起特定的桶并确定该桶的平均温度 ( sum_temperature / transaction_count)。在处理时间序列数据时，了解 2018 年 7 月 13 日加利福尼亚州康宁市下午 2:00 至下午 3:00 的平均温度通常比了解下午 2:03 的温度更有趣和重要。通过分桶和进行预聚合，我们能够更轻松地提供该信息。\n此外，随着我们收集越来越多的信息，我们可能会确定将所有源数据保存在存档中会更有效。例如，我们需要多久获取一次康宁 1948 年以来的温度？能够将这些数据桶移动到数据存档中可能是一个很大的好处。\n示例用例 使时间序列数据在现实世界中有价值的一个例子来自博世的物联网实施。他们在汽车现场数据应用程序中使用 MongoDB 和时间序列数据。该应用程序从整个车辆的各种传感器捕获数据，从而改进对车辆本身和组件性能的诊断。\n其他示例包括已将这种模式纳入金融应用程序以将交易组合在一起的主要银行。\n结论 在处理时间序列数据时，在 MongoDB 中使用 Bucket Pattern 是一个不错的选择。它减少了集合中的文档总数，提高了索引性能，并且通过利用预聚合，它可以简化数据访问。\n计算模式Computed *我们已经研究了在“使用模式构建”*系列中优化存储数据的各种方法。现在，我们将研究模式设计的不同方面。通常，仅存储数据并使其可用并不是那么有用。当我们可以从中计算值时，数据的有用性变得更加明显。最新的亚马逊 Alexa 的总销售收入是多少？有多少观众观看了最新的大片？这些类型的问题可以从存储在数据库中的数据中回答，但必须进行计算。\n每次请求时都运行这些计算成为一个高度资源密集型的过程，尤其是在巨大的数据集上。CPU 周期、磁盘访问、内存都可能涉及。\n想一想电影信息 Web 应用程序。每次我们访问该应用程序查找电影时，该页面都会提供有关该电影已播放的电影院数量、观看该电影的总人数以及总收入的信息。如果应用程序必须为每次页面访问不断计算这些值，它可能会在流行电影上使用大量处理资源\n然而，大多数时候，我们不需要知道这些确切的数字。我们可以在后台进行计算并偶尔更新主电影信息文档。然后，这些计算使我们能够显示数据的有效表示，而无需在 CPU 上付出额外的努力。\n计算模式 当我们有需要在应用程序中重复计算的数据时，就会使用计算模式。当数据访问模式是读取密集型时，也会使用计算模式。例如，如果您每小时有 1,000,000 次读取，但每小时只有 1,000 次写入，则在写入时进行计算会将计算次数除以 1000。\n在我们的电影数据库示例中，我们可以根据我们对特定电影的所有放映信息进行计算，计算结果，并将它们与电影本身的信息一起存储。在低写入环境中，可以结合源数据的任何更新来完成计算。在有更多定期写入的情况下，可以按定义的时间间隔进行计算 - 例如每小时。由于我们不会干扰筛选信息中的源数据，因此我们可以在任何时间点继续重新运行现有计算或运行新计算，并且知道我们会得到正确的结果。\n执行计算的其他策略可能涉及，例如，向文档添加时间戳以指示其上次更新时间。然后应用程序可以确定何时需要进行计算。另一种选择可能是有一个需要完成的计算队列。选择更新策略最好留给应用程序开发人员。\n示例用例 计算模式可用于需要对数据进行计算的任何地方。需要总和的数据集（例如收入或观众）就是一个很好的例子，但时间序列数据、产品目录、单一视图应用程序和事件溯源也是这种模式的主要候选者。\n这是许多客户已经实施的模式。例如，客户对车辆数据进行大量聚合查询，并将结果存储给服务器以显示接下来几个小时的信息。\n一家出版公司编译所有类型的数据以创建像“100 Best \u0026hellip;”这样的有序列表。这些列表只需要偶尔重新生成一次，而基础数据可能会在其他时间更新。\n结论 这种强大的设计模式可以减少 CPU 工作量并提高应用程序性能。它可用于对集合中的数据进行计算或操作，并将结果存储在文档中。这允许避免重复进行相同的计算。每当您的系统重复执行相同的计算并且您具有较高的读写比率时，请考虑Computed Pattern。\n文档版本控制模式 Document Versioning 数据库，如 MongoDB，非常擅长查询大量数据并经常更新这些数据。然而，在大多数情况下，我们只对数据的最新状态执行查询。我们需要查询数据的先前状态的情况呢？如果我们需要对文档进行版本控制怎么办？这是我们可以使用文档版本控制模式的地方。\n这种模式是关于保持文档的版本历史可用和可用。我们可以构建一个系统，将专用版本控制系统与 MongoDB 结合使用。一个系统用于少数更改的文档，而 MongoDB 用于其他文档。这可能会很麻烦。然而，通过使用文档版本控制模式，我们能够避免使用多个系统来管理当前文档及其历史记录，方法是将它们保存在一个数据库中。\n文档版本控制模式 这种模式解决了希望在 MongoDB 中保留某些文档的旧版本而不是引入第二个管理系统的问题。为此，我们向每个文档添加一个字段，以便我们跟踪文档版本。然后数据库将有两个集合：一个包含最新（和查询最多的数据），另一个包含所有数据的修订。\n文档版本控制模式对数据库中的数据和应用程序所做的数据访问模式做了一些假设。\n每个文档没有太多的修订。 没有太多要版本的文档。 执行的大多数查询都是在文档的最新版本上完成的。 如果您发现这些假设不适合您的用例，则此模式可能不太适合。您可能需要更改实现文档版本控制模式版本的方式，或者您的用例可能只需要不同的解决方案。\n示例用例 文档版本控制模式在需要一组数据的特定时间点版本的高度监管行业中非常有用。金融和医疗保健行业就是很好的例子。保险和法律行业是其他一些行业。有许多用例可以跟踪数据的某些部分的历史记录。\n想想保险公司如何利用这种模式。每个客户都有一个“标准”保单和一个特定于该客户的第二部分，如果你愿意的话，一个保单附加条款。第二部分将包含一份保单附加项列表和一份正在投保的特定项目列表。随着客户更改投保的特定项目，需要更新此信息，同时还需要提供历史信息。这在房主或租房者保险单中相当普遍。例如，如果某人有超出所提供的典型承保范围的特定项目，他们将作为附加险单独列出。保险公司的另一个用例可能是保留他们随时间邮寄给客户的“标准保单”的所有版本。\n如果我们看一下文档版本控制模式的要求，这似乎是一个很好的用例。保险公司可能有几百万客户，对“附加”列表的修改可能不会太频繁，并且大多数对保单的搜索将是最新版本。\n在我们的数据库中，每个客户可能都有一个current_policy文档——包含客户特定信息——在一个current_policies集合中，policy_revision文档在一个policy_revisions集合中。此外，standard_policy对于大多数客户来说，会有一个相同的集合。当客户购买新项目并希望将其添加到他们的保单中时，policy_revision会使用该文档创建一个新current_policy文档。然后增加文档中的版本字段以将其标识为最新修订并添加客户的更改。\n最新版本将存储在current_policies集合中，旧版本将写入policy_revisions集合。current_policy通过在集合中保留最新版本，查询可以保持简单。该policy_revisions集合也可能只保留几个版本，具体取决于数据需求和要求。\n在这个例子中， Middle-earth Insurance将standard_policy为其客户提供一个。The Shire的所有居民都将分享这份特定的政策文件。Bilbo 在他的正常保险范围之外还有一些他想要投保的特定事项。他的精灵之剑，最终，一环被添加到他的政策中。这些将驻留在current_policies集合中，并且在进行更改时，policy_revisions集合将保留更改的历史记录。\n文档版本控制模式相对容易实现。它可以在现有系统上实现，而无需对应用程序或现有文档进行太多更改。此外，访问文档最新版本的查询仍然有效。\n这种模式的一个缺点是需要访问不同的历史信息集合。另一个事实是，对数据库的总体写入量会更高。这就是为什么使用此模式的要求之一是它发生在不太频繁更改的数据上。\n结论 当您需要跟踪对文档的更改时，文档版本控制模式是一个不错的选择。它相对容易实现，并且可以应用于现有的文档集。另一个好处是对最新版本数据的查询仍然表现良好。但是，它不会取代专用的版本控制系统。\n扩展引用模式 Extended Reference 在整个使用模式构建系列中，我希望您已经发现，模式应该是什么样子的驱动力是该数据的数据访问模式是什么。如果我们有许多类似的字段，属性模式可能是一个不错的选择。容纳对一小部分数据的访问是否会极大地改变我们的应用程序？也许异常值模式是需要考虑的。一些模式，例如Subset Pattern，引用额外的集合并依靠 JOIN 操作将每条数据重新组合在一起。当需要大量 JOIN 操作来汇集经常访问的数据时，实例会怎样呢？这是我们可以使用扩展参考模式的地方。\n扩展引用模式 有时单独收集数据是有意义的。如果一个实体可以被认为是一个单独的“事物”，那么拥有一个单独的集合通常是有意义的。例如，在电子商务应用程序中，存在订单、客户和库存的概念。它们是独立的逻辑实体。\n然而，从性能的角度来看，这会成为问题，因为我们需要将信息片段放在一起以实现特定的顺序。一个客户可以有 N 个订单，形成 1-N 关系。从订单的角度来看，如果我们反过来看，他们与客户的关系是 N-1。为每个订单嵌入有关客户的所有信息只是为了减少 JOIN 操作会导致大量重复信息。此外，订单可能不需要所有客户信息。\n扩展参考模式提供了一种处理这些情况的好方法。我们不会复制客户的所有信息，而是只复制我们经常访问的字段。我们没有嵌入所有信息或包含对 JOIN 信息的引用，而是仅嵌入那些具有最高优先级和最常访问的字段，例如姓名和地址。\n使用这种模式时要考虑的一点是数据是重复的。因此，如果存储在主文档中的数据是不经常更改的字段，则效果最好。像 user_id 和人名这样的东西是不错的选择。这些很少改变。\n此外，仅引入并复制所需的数据。想想订单发票。如果我们在发票上注明客户的姓名，我们是否需要他们当时的辅助电话号码和非送货地址？可能不会，因此我们可以将该数据从invoice集合中删除并引用一个customer集合。\n当信息更新时，我们也需要考虑如何处理。哪些扩展引用发生了变化？这些应该什么时候更新？如果信息是帐单地址，我们是否需要出于历史目的维护该地址，还是可以更新？有时重复数据会更好，因为您可以保留历史值，这可能更有意义。我们运送产品时客户居住的地址在订单文档中更有意义，然后通过客户集合获取当前地址。\n示例用例 订单管理应用程序是这种模式的经典用例。在考虑 N-1 关系、向客户下订单时，我们希望减少信息的加入以提高绩效。通过包含对最常连接的数据的简单引用，我们节省了处理步骤。\n如果我们继续以订单管理系统为例，在发票上 Acme Co. 可能被列为铁砧供应商。从发票的角度来看，拥有 Acme Co. 的联系信息可能并不是很重要。例如，该信息最好存放在单独的supplier集合中。在invoice集合中，我们会保留有关供应商的所需信息，作为对供应商信息的扩展参考。\n结论 当您的应用程序经历许多重复的 JOIN 操作时，扩展引用模式是一个很好的解决方案。通过在查找端识别字段并将那些经常访问的字段带入主文档，可以提高性能。这是通过更快的读取和减少 JOIN 的总数来实现的。但是请注意，数据重复是这种模式设计模式的副作用。\n异常值模式Outlier 到目前为止，在使用模式构建系列中，我们已经了解了Polymorphic、Attribute和Bucket模式。虽然这些模式中的文档模式略有不同，但从应用程序和查询的角度来看，文档结构是相当一致的。但是，如果不是这种情况，会发生什么？当存在超出“正常”模式的数据时会发生什么？如果有异常值怎么办？\n想象一下，您正在创建一个销售书籍的电子商务网站。您可能有兴趣运行的查询之一是“谁购买了特定的书”。这对于推荐系统向您的客户展示您感兴趣的类似书籍可能很有用。您决定user_id为每本书存储一个客户的数组。很简单，对吧？\n好吧，这可能确实适用于 99.99% 的案例，但是当 JK 罗琳发布新的《哈利波特》书籍并且销量飙升数百万时会发生什么？很容易达到16MB BSON 文档大小的限制。针对这种异常情况重新设计我们的整个应用程序可能会导致典型书籍的性能降低，但我们确实需要考虑到这一点。\n异常值模式 使用离群值模式，我们正在努力防止一些查询或文档将我们的解决方案推向一种对于我们的大多数用例而言并非最佳的解决方案。并非每本书售出都会售出数百万册。\n存储信息的典型book文档user_id可能类似于：\n{\r\u0026#34;_id\u0026#34;: ObjectID(\u0026#34;507f1f77bcf86cd799439011\u0026#34;)\r\u0026#34;title\u0026#34;: \u0026#34;A Genealogical Record of a Line of Alger\u0026#34;,\r\u0026#34;author\u0026#34;: \u0026#34;Ken W. Alger\u0026#34;,\r…,\r\u0026#34;customers_purchased\u0026#34;: [\u0026#34;user00\u0026#34;, \u0026#34;user01\u0026#34;, \u0026#34;user02\u0026#34;]\r} 这对于大多数不太可能进入“畅销书”列表的书籍非常有效。考虑异常值虽然会导致customers_purchased数组扩展超出我们设置的 1000 项限制，但我们将添加一个新字段以将图书“标记”为异常值。\n{\r\u0026#34;_id\u0026#34;: ObjectID(\u0026#34;507f191e810c19729de860ea\u0026#34;),\r\u0026#34;title\u0026#34;: \u0026#34;Harry Potter, the Next Chapter\u0026#34;,\r\u0026#34;author\u0026#34;: \u0026#34;J.K. Rowling\u0026#34;,\r…,\r\u0026#34;customers_purchased\u0026#34;: [\u0026#34;user00\u0026#34;, \u0026#34;user01\u0026#34;, \u0026#34;user02\u0026#34;, …, \u0026#34;user999\u0026#34;],\r\u0026#34;has_extras\u0026#34;: \u0026#34;true\u0026#34;\r} 然后，我们会将溢出信息移动到与本书链接的单独文档中id。在应用程序内部，我们将能够确定文档是否具有has_extras值为 的字段true。如果是这种情况，应用程序将检索额外信息。这可以被处理，以便它对大多数应用程序代码来说是相当透明的。\n许多设计决策将基于应用程序工作负载，因此此解决方案旨在展示异常值模式的示例。这里要掌握的重要概念是，异常值在其数据中具有足够大的差异，如果将它们视为“正常”，则为它们更改应用程序设计会降低更典型查询和文档的性能。\n示例用例 异常值模式是一种高级模式，但它可以带来很大的性能改进。它经常用于受欢迎程度是一个因素的情况，例如社交网络关系、图书销售、电影评论等。互联网已经把我们的世界变成了一个小得多的地方，当某件事变得流行时，它改变了我们需要的方式对项目周围的数据进行建模。\n一个示例是拥有视频会议产品的客户。大多数视频会议中的授权与会者列表可以保存在与会议相同的文档中。然而，有一些活动，比如公司的全体员工，预计会有成千上万的参与者。对于那些异常会议，客户实施了“溢出”文档来记录那些长长的与会者名单。\n结论 异常值模式解决的问题是阻止一些文档或查询来确定应用程序的解决方案。尤其是当该解决方案对于大多数用例而言不是最佳的时。我们可以利用 MongoDB 灵活的数据模型向文档中添加一个字段，将其“标记”为异常值。然后，在应用程序内部，我们处理异常值的方式略有不同。通过为典型文档或查询定制架构，应用程序性能将针对这些正常用例进行优化，异常值仍将得到解决。\n这种模式需要考虑的一件事是，它通常是为特定的查询和情况量身定制的。因此，即席查询可能会导致性能不佳。此外，由于大部分工作是在应用程序代码本身内完成的，因此随着时间的推移可能需要额外的代码维护。\n预分配模式 Preallocation MongoDB 的一大优点是文档数据模型。它不仅在模式设计中而且在开发周期中都提供了很大的灵活性。不知道以后需要哪些字段，使用 MongoDB 文档可以轻松处理。然而，有时结构是已知的并且能够填充或增长结构使得设计更加简单。这是我们可以使用预分配模式的地方。\n内存分配通常在块中完成以避免性能问题。在 MongoDB 的早期（MongoDB 3.2 版之前），当它使用MMAPv1存储引擎时，一个常见的优化是提前分配不断增长的文档未来大小所需的内存。MMAPv1 中不断增长的文档需要由服务器以相当昂贵的成本重新定位。凭借其无锁和重写更新算法，WiredTiger不需要同样的处理。\n随着 MongoDB 4.0 中 MMAPv1 的弃用，预分配模式似乎失去了一些光彩和必要性。然而，WiredTiger 的预分配模式仍有一些用例。与我们在使用模式构建系列中讨论的其他模式一样，需要考虑一些应用程序注意事项。\n预分配模式 这种模式只是要求创建一个初始的空结构以供以后填充。这可能听起来微不足道，但是，您需要在简化的预期结果与解决方案可能消耗的额外资源之间取得平衡。更大的文档将产生更大的工作集，从而导致更多的 RAM 来包含该工作集。\n如果应用程序的代码使用未完全填充的结构更容易编写和维护，那么它可能很容易超过 RAM 的成本。假设需要将一个剧院房间表示为一个二维数组，其中每个座位都有一个“行”和“编号”，例如座位“C7”。有些行可能有更少的座位，但是在二维数组中找到座位“B3”比在只有现有座位的单元格的一维数组中找到座位的复杂公式更快、更清晰。能够识别无障碍座位也更容易，因为可以为这些座位创建单独的阵列。\n场地的一维表示，可访问的座位以蓝色显示。\n场地的二维表示，可用绿色的有效座位。带有蓝色轮廓的无障碍座位。\n示例用例 如前所述，表示二维结构（如场地）是一个很好的用例。另一个示例可以是预留系统，其中资源每天被阻止或预留。每天使用一个单元格可能会比保留范围列表更快地进行计算和检查。\n2019 年 4 月，有一系列美国工作日。\n2019 年 4 月，包含一系列美国工作日作为范围列表。\n结论 在将 MMAPv1 存储引擎与 MongoDB 一起使用时，这种模式可能是最常用的模式之一。然而，由于这个存储引擎的弃用，它已经失去了它的通用用例，但它在某些情况下仍然有用。和其他模式一样，您需要在“简单性”和“性能”之间进行权衡。\n多态模式 polymorphic 当我们的文档相似性多于差异性时，就会使用此模式。当我们想要将文档保存在单个集合中时，它也非常适合。\n多态模式 当集合中的所有文档具有相似但不相同的结构时，我们称之为多态模式。如前所述，当我们想要从单个集合访问（查询）信息时，多态模式很有用。根据我们想要运行的查询将文档分组在一起（而不是跨表或集合分离对象）有助于提高性能。\n想象一下，我们的应用程序跟踪所有不同运动的职业运动员。\n我们仍然希望能够访问我们应用程序中的所有运动员，但是每个运动员的属性非常不同。这就是多态模式大放异彩的地方。在下面的示例中，我们将来自两个不同运动的运动员的数据存储在同一个集合中。即使文档在同一个集合中，存储的关于每个运动员的数据也不必相同。\n职业运动员的记录有一些相似之处，但也有一些差异。使用多态模式，我们很容易适应这些差异。如果我们不使用多态模式，我们可能会有保龄球运动员的集合和网球运动员的集合。当我们想要查询所有运动员时，我们需要进行耗时且可能复杂的连接。相反，由于我们使用的是多态模式，所以我们所有的数据都存储在一个运动员集合中，并且可以通过一个简单的查询来完成对所有运动员的查询。\n这种设计模式也可以流入嵌入的子文档。在上面的例子中，玛蒂娜·纳芙拉蒂洛娃不只是作为一个球员参加比赛，所以我们可能希望将她的记录构造如下：\n从应用程序开发的角度来看，当使用多态模式时，我们将查看文档或子文档中的特定字段，以便能够跟踪差异。例如，我们知道网球运动员可能会参与不同的赛事，而不同的运动员可能不会。这通常需要根据给定文档中的信息在应用程序代码中使用不同的代码路径。或者，可能会编写不同的类或子类来处理网球、保龄球、足球和橄榄球运动员之间的差异。\n示例用例 多态模式的一个示例用例是单一视图应用程序. 想象一下为一家公司工作，随着时间的推移，该公司利用他们的技术和数据模式收购了其他公司。例如，每家公司都有许多数据库，每个数据库都以不同的方式模拟“与客户的保险”。然后，您购买了这些公司，并希望将所有这些系统集成为一个。将这些不同的系统合并到一个统一的 SQL 模式中既费钱又费时。\n大都会人寿能够利用 MongoDB 和多态模式在几个月内构建他们的单视图应用程序。他们的 Single View 应用程序将来自多个来源的数据聚合到一个中央存储库中，使客户服务、保险代理、计费和其他部门能够获得 360 度的客户图片。这使他们能够以更低的成本为公司提供更好的客户服务。此外，使用 MongoDB 的灵活数据模型和多态模式，开发团队能够快速创新，将他们的产品上线。\n单视图应用程序是多态模式的一个用例。它也适用于自行车与钓鱼竿具有不同属性的产品目录等内容。我们的运动员示例可以很容易地扩展为更成熟的内容管理系统，并在那里使用多态模式。\n结论 当文档的相似性多于差异性时，使用多态模式。这种模式设计的典型用例是：\n单一视图应用程序 内容管理 移动应用 产品目录 多态模式提供了一种易于实现的设计，允许跨单个集合进行查询，并且是我们将在接下来的文章中探索的许多设计模式的起点。\n模式版本控制模式 Schema Versioning 有人说，生活中唯一不变的就是变化。这也适用于数据库模式。我们曾经认为不需要的信息，现在我们想要捕获。或者新服务变得可用并且需要包含在数据库记录中。不管更改背后的原因是什么，一段时间后，我们不可避免地需要对应用程序中的底层架构设计进行更改。虽然这通常会带来挑战，并且在遗留表格数据库系统中可能至少会带来一些令人头疼的问题，但在 MongoDB 中，我们可以使用模式版本控制模式来简化更改。\n如前所述，更新表格数据库中的数据库模式可能具有挑战性。通常需要停止应用程序，迁移数据库以支持新模式，然后重新启动。这种停机时间可能会导致糟糕的客户体验。此外，如果迁移没有完全成功，会发生什么？恢复到之前的状态通常是一个更大的挑战。\nSchema Versioning 模式利用了 MongoDB 对不同形状文档的支持以存在于同一数据库集合中。MongoDB 的这种多态性非常强大。它允许具有不同字段甚至同一字段的不同字段类型的文档和平共存。\n模式版本控制模式 这种模式的实现相对容易。我们的应用程序从最终需要更改的原始模式开始。发生这种情况时，我们可以使用字段创建新模式并将其保存到数据库schema_version中。该字段将允许我们的应用程序知道如何处理此特定文档。或者，我们可以让我们的应用程序根据某些给定字段的存在与否来推断版本，但前一种方法是首选。我们可以假设没有这个字段的文档是版本 1。然后每个新的模式版本都会增加schema_version字段值，并且可以在应用程序中进行相应的处理。\n随着新信息的保存，我们使用最新的模式版本。我们可以根据应用程序和用例来确定是否需要将所有文档更新为新设计、何时更新记录被访问或根本不更新。在应用程序内部，我们将为每个模式版本创建处理函数。\n示例用例 如前所述，几乎每个数据库都需要在其生命周期的某个时间点进行更改，因此这种模式在许多情况下都很有用。让我们看一下客户资料用例。在有多种联系方式之前，我们就开始保留客户信息。他们只能在家里或工作中联系到：\n{ \u0026#34;_id\u0026#34;: \u0026#34;\u0026lt;ObjectId\u0026gt;\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Anakin Skywalker\u0026#34;, \u0026#34;home\u0026#34;: \u0026#34;503-555-0000\u0026#34;, \u0026#34;work\u0026#34;: \u0026#34;503-555-0010\u0026#34; } 随着岁月的流逝，越来越多的客户记录被保存，我们注意到手机号码也需要保存。添加该字段是直截了当的。\n{\r\u0026#34;_id\u0026#34;: \u0026#34;\u0026lt;ObjectId\u0026gt;\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Darth Vader\u0026#34;,\r\u0026#34;home\u0026#34;: \u0026#34;503-555-0100\u0026#34;,\r\u0026#34;work\u0026#34;: \u0026#34;503-555-0110\u0026#34;,\r\u0026#34;mobile\u0026#34;: \u0026#34;503-555-0120\u0026#34;\r} 随着时间的流逝，现在我们发现拥有家庭电话的人越来越少，而其他联系方式也变得越来越重要。Twitter、Skype 和 Google Hangouts 等项目正变得越来越流行，甚至可能在我们刚开始保留联系信息时都不可用。我们还想尽可能地尝试对我们的应用程序进行未来验证，并且在阅读了使用模式构建系列之后，我们了解了属性模式并将其实现为一contact_method组值。为此，我们创建了一个新的模式版本。\n{\r\u0026#34;_id\u0026#34;: \u0026#34;\u0026lt;ObjectId\u0026gt;\u0026#34;,\r\u0026#34;schema_version\u0026#34;: \u0026#34;2\u0026#34;,\r\u0026#34;name\u0026#34;: \u0026#34;Anakin Skywalker (Retired)\u0026#34;,\r\u0026#34;contact_method\u0026#34;: [\r{ \u0026#34;work\u0026#34;: \u0026#34;503-555-0210\u0026#34; },\r{ \u0026#34;mobile\u0026#34;: \u0026#34;503-555-0220\u0026#34; },\r{ \u0026#34;twitter\u0026#34;: \u0026#34;@anakinskywalker\u0026#34; },\r{ \u0026#34;skype\u0026#34;: \u0026#34;AlwaysWithYou\u0026#34; }\r]\r} MongoDB 文档模型的灵活性允许所有这些都发生，而无需数据库停机。从应用程序的角度来看，它可以设计为读取模式的两个版本。假设涉及的应用程序服务器不止一个，那么如何处理架构差异的这种应用程序更改也不应该需要停机时间。\n结论 Schema Versioning 模式非常适用于无法选择应用程序停机时间、更新文档可能需要数小时、数天或数周时间才能完成、不需要将文档更新到新版本或任意组合的情况。这些。它允许schema_version轻松添加新字段并使应用程序适应这些变化。此外，它为我们作为开发人员提供了更好地决定何时以及如何进行数据迁移的机会。所有这些都会减少未来的技术债务，这是这种模式的另一大优势。\n与本系列中提到的其他模式一样，Schema Versioning 模式也需要考虑一些事项。如果您在文档中不在同一级别的字段上有索引，则在迁移文档时可能需要 2 个索引。\n这种模式的主要好处之一是数据模型本身的简单性。所需要的只是添加该schema_version字段。然后允许应用程序处理和处理不同的文档版本。\n此外，正如在用例示例中所见，我们能够将模式设计模式组合在一起以获得额外的性能。在这种情况下，同时使用模式版本控制和属性模式。允许在不停机的情况下进行模式升级使得模式版本控制模式在 MongoDB 中特别强大，并且很可能有足够的理由为您的下一个应用程序使用 MongoDB 的文档模型而不是旧的表格数据库。\n子集模式 Subset 几年前，第一台 PC 拥有高达 256KB 的 RAM 和双 5.25\u0026quot; 软盘驱动器。没有硬盘驱动器，因为它们当时非常昂贵。这些限制导致由于工作时内存不足而不得不物理交换软盘有大量（当时）数据。如果当时只有一种方法可以只将我经常使用的数据带入内存，就像整体数据的一个子集一样。\n现代应用程序无法避免耗尽资源。MongoDB 将经常访问的数据（称为工作集）保存在 RAM 中。当数据和索引的工作集增长到超出分配的物理 RAM 时，性能会随着磁盘访问开始发生并且数据从 RAM 中滚出而降低。\n我们如何解决这个问题？首先，我们可以向服务器添加更多 RAM。不过，这只规模很大。我们可以考虑对我们的集合进行分片，但这会带来额外的成本和复杂性，我们的应用程序可能还没有准备好。另一种选择是减小我们工作集的大小。这是我们可以利用子集模式的地方。\n子集模式 此模式解决了与超出 RAM 的工作集相关的问题，从而导致信息从内存中删除。这通常是由具有大量应用程序实际未使用的数据的大型文档引起的。我到底是什么意思？\n想象一个有一个产品评论列表的电子商务网站。在访问该产品的数据时，我们很可能只需要最近十条左右的评论。使用所有评论提取整个产品数据很容易导致工作集扩展。\n我们可以将集合分成两个集合，而不是将所有评论与产品一起存储。一个集合包含最常用的数据，例如当前评论，而另一个集合包含不常用的数据，例如旧评论、产品历史等。我们可以复制部分 1-N 或 NN 关系，该关系由关系中最常用的一面。\n在产品集合中，我们只会保留最近的 10 条评论。这允许通过仅引入整体数据的一部分或子集来减少工作集。附加信息（本例中的评论）存储在单独的评论集合中，如果用户想要查看其他评论，可以访问该集合。在考虑在哪里拆分数据时，文档中最常用的部分应该进入“主”集合，而不太常用的数据应该进入另一个集合。对于我们的评论，该拆分可能是产品页面上可见的评论数量。\n示例用例 当我们在文档中有大量很少需要的数据时，子集模式非常有用。产品评论、文章评论、电影中的演员都是这种模式的用例示例。每当文档大小对工作集的大小施加压力并导致工作集超出计算机的 RAM 容量时，子集模式是一个可以考虑的选项。\n结论 通过使用具有更频繁访问数据的较小文档，我们减小了工作集的整体大小。这允许对应用程序需要的最常用信息进行更短的磁盘访问时间。使用子集模式时我们必须做出的一个权衡是我们必须管理子集，而且如果我们需要提取较旧的评论或所有信息，则需要额外访问数据库才能这样做。\n树模式 Tree 到目前为止，我们介绍的许多模式设计模式都强调节省 JOIN 操作的时间是一个好处。一起访问的数据应该存储在一起，并且一些数据重复是可以的。像扩展参考这样的模式设计模式就是一个很好的例子。但是，如果要连接的数据是分层的怎么办？例如，您想确定从员工到 CEO 的报告链？MongoDB 提供了$graphLookup操作符来以图表的形式导航数据，这可能是一种解决方案。但是，如果您需要对这种分层数据结构进行大量查询，您可能希望应用相同的规则将一起访问的数据存储在一起。这是我们可以使用树模式的地方。\n树模式 有许多方法可以表示旧表格数据库中的树。最常见的是图中的节点列出其父节点和节点列出其子节点。这两种表示都可能需要多次访问来构建节点链。\n具有父节点的公司结构\n具有子节点的公司结构\n或者，我们可以存储从节点到层次结构顶部的完整路径。在这种情况下，我们基本上会为每个节点存储“父母”。在表格数据库中，它可能通过对父母列表进行编码来完成。MongoDB 中的方法是将其简单地表示为一个数组。\n从这里可以看出，在这个表示中有一些数据重复。如果信息是相对静态的，比如家谱，你的父母和祖先不会改变，使这个数组易于管理。但是，在我们的公司结构示例中，当事情发生变化并进行重组时，您将需要根据需要更新层次结构。与不一直计算树所获得的好处相比，这仍然是一个很小的成本。\n示例用例 产品目录是使用树模式的另一个很好的例子。产品通常属于类别，而类别又是其他类别的一部分。例如，固态驱动器可能在Hard Drives下，在Storage下，在Computer Parts下。有时，类别的组织可能会发生变化，但不会太频繁。\n请注意文档上方ancestor_categories跟踪整个层次结构的字段。我们也有领域parent_category。在这两个字段中复制直接父级是我们在与许多使用树模式的客户合作后开发的最佳实践。包含“父”字段通常很方便，特别是如果您需要保持在文档上使用 $graphLookup 的能力。\n将祖先保留在数组中提供了在这些值上创建多键索引的能力。它允许轻松找到给定类别的所有后代。至于直系子女，可以通过查看将我们给定类别作为其直系“父母”的文档来访问它们。我们刚刚告诉过你，这个字段会很方便。\n结论 对于许多模式，在使用它们时通常需要在简单性和性能之间进行权衡。在树模式的情况下，您可以通过避免多个连接来获得更好的性能，但是，您需要管理对图形的更新。\n参考 Building with Patterns: A Summary mogodb go driver usage excample MongoDB 进阶模式设计 MongoDB设计方法及技巧 ","permalink":"https://czyt.tech/post/operate-mongodb-tutorial/","summary":"TL;DR\n环境准备 mongoDB 预备知识 MongoDB常见的数据类型\n数据类型 示例 说明 Null {\u0026quot;x\u0026quot; : null} Boolean {\u0026quot;x\u0026quot; : true} Number {\u0026quot;x\u0026quot; : 3.14} {\u0026quot;x\u0026quot; : 3} {\u0026quot;x\u0026quot; : NumberInt(\u0026quot;3\u0026quot;)} {\u0026quot;x\u0026quot; : NumberLong(\u0026quot;3\u0026quot;)} 默认64位浮点数，整数需要使用NumberInt和NumberLong String {\u0026quot;x\u0026quot; : \u0026quot;foobar\u0026quot;} 编码格式为UTF-8 Date {\u0026quot;x\u0026quot; : new Date()} 64位时间戳(从January 1, 1970)，不存时区。通过new Date()进行调用。 Regular expression {\u0026quot;x\u0026quot; : /foobar/i} javascript 正则 Array {\u0026quot;x\u0026quot; : [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;]} Embedded document {\u0026quot;x\u0026quot; : {\u0026quot;foo\u0026quot; : \u0026quot;bar\u0026quot;}} Object ID {\u0026quot;x\u0026quot; : ObjectId()} 文档12字节的ID Binary data 一个任意字节的字符串。是保存非UTF-8字符串到数据库的唯一方法。 Code {\u0026quot;x\u0026quot; : function() { /* .","title":"MongoDB操作指北"},{"content":"缘起 近期项目上设备会自动更新windows10为windows11，通过搜索，搜索到第三方工具windows-update-blocker ，因为改工具支持命令行参数，故也很方便于集成。批处理大致如下\n@echo off pushd %~dp0 echo 开始禁用windows更新服务 %~dp0Wub_x64.exe /D /P timeout 3 背后的操作 作为技术人，还是需要知道软件做了什么背后的操作，通过TotalUninstaller监控，获取到软件写入的注册表如下,实现的手段就是镜像劫持windows更新的进程，并且更新windows的组策略选项：\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer] \u0026#34;NoWindowsUpdate\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options] \u0026#34;WubBlockLists\u0026#34;=hex(7):57,00,61,00,61,00,53,00,4D,00,65,00,64,00,69,00,63,00,\\ 2E,00,65,00,78,00,65,00,00,00,57,00,61,00,61,00,73,00,4D,00,65,00,64,00,69,\\ 00,63,00,41,00,67,00,65,00,6E,00,74,00,2E,00,65,00,78,00,65,00,00,00,57,00,\\ 69,00,6E,00,64,00,6F,00,77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,\\ 00,64,00,65,00,2E,00,65,00,78,00,65,00,00,00,57,00,69,00,6E,00,64,00,6F,00,\\ 77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,00,64,00,65,00,72,00,41,\\ 00,70,00,70,00,2E,00,65,00,78,00,65,00,00,00,55,00,70,00,64,00,61,00,74,00,\\ 65,00,41,00,73,00,73,00,69,00,73,00,74,00,61,00,6E,00,74,00,2E,00,65,00,78,\\ 00,65,00,00,00,55,00,73,00,6F,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,00,\\ 65,00,78,00,65,00,00,00,72,00,65,00,6D,00,73,00,68,00,2E,00,65,00,78,00,65,\\ 00,00,00,45,00,4F,00,53,00,6E,00,6F,00,74,00,69,00,66,00,79,00,2E,00,65,00,\\ 78,00,65,00,00,00,53,00,69,00,68,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,\\ 00,65,00,78,00,65,00,00,00,75,00,70,00,66,00,63,00,2E,00,65,00,78,00,65,00,\\ 00,00,49,00,6E,00,73,00,74,00,61,00,6C,00,6C,00,41,00,67,00,65,00,6E,00,74,\\ 00,2E,00,65,00,78,00,65,00,00,00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,\\ 66,00,69,00,63,00,61,00,74,00,69,00,6F,00,6E,00,2E,00,65,00,78,00,65,00,00,\\ 00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,66,00,69,00,63,00,61,00,74,00,\\ 69,00,6F,00,6E,00,55,00,78,00,2E,00,65,00,78,00,65,00,00,00,00,00,00,00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\EOSnotify.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\InstallAgent.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotification.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotificationUx.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\remsh.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\SihClient.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\UpdateAssistant.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\upfc.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\UsoClient.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\WaaSMedic.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\WaasMedicAgent.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Windows10Upgrade.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Windows10UpgraderApp.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsUpdate\\UX\\Settings] \u0026#34;TrayIconVisibility\u0026#34;=dword:00000000 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft] \u0026#34;WindowsStore\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate] \u0026#34;DisableOSUpgrade\u0026#34;=dword:00000001 \u0026#34;DisableWindowsUpdateAccess\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU] \u0026#34;NoAutoUpdate\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DoSvc] \u0026#34;Start\u0026#34;=dword:00000004 \u0026#34;WubLock\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc] \u0026#34;Start\u0026#34;=dword:00000003 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WaaSMedicSvc] \u0026#34;Start\u0026#34;=dword:00000004 \u0026#34;WubLock\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv] \u0026#34;Start\u0026#34;=dword:00000004 \u0026#34;WubLock\u0026#34;=dword:00000001 恢复为默认更新配置的注册表项\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer] \u0026#34;NoWindowsUpdate\u0026#34;=- [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options] \u0026#34;WubBlockLists\u0026#34;=- [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\EOSnotify.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\InstallAgent.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotification.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotificationUx.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\remsh.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\SihClient.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\UpdateAssistant.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\upfc.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\UsoClient.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\WaaSMedic.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\WaasMedicAgent.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Windows10Upgrade.exe] [-HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\Windows10UpgraderApp.exe] [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsUpdate\\UX\\Settings] \u0026#34;TrayIconVisibility\u0026#34;=- [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft] \u0026#34;WindowsStore\u0026#34;=- [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate] \u0026#34;DisableOSUpgrade\u0026#34;=- \u0026#34;DisableWindowsUpdateAccess\u0026#34;=- [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU] \u0026#34;NoAutoUpdate\u0026#34;=- [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DoSvc] \u0026#34;Start\u0026#34;=dword:00000002 \u0026#34;WubLock\u0026#34;=- [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\UsoSvc] \u0026#34;Start\u0026#34;=dword:00000002 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\WaaSMedicSvc] \u0026#34;Start\u0026#34;=dword:00000003 \u0026#34;WubLock\u0026#34;=- [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\wuauserv] \u0026#34;Start\u0026#34;=dword:00000002 \u0026#34;WubLock\u0026#34;=- ","permalink":"https://czyt.tech/post/block-windows10-update-via-registry/","summary":"缘起 近期项目上设备会自动更新windows10为windows11，通过搜索，搜索到第三方工具windows-update-blocker ，因为改工具支持命令行参数，故也很方便于集成。批处理大致如下\n@echo off pushd %~dp0 echo 开始禁用windows更新服务 %~dp0Wub_x64.exe /D /P timeout 3 背后的操作 作为技术人，还是需要知道软件做了什么背后的操作，通过TotalUninstaller监控，获取到软件写入的注册表如下,实现的手段就是镜像劫持windows更新的进程，并且更新windows的组策略选项：\nWindows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer] \u0026#34;NoWindowsUpdate\u0026#34;=dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options] \u0026#34;WubBlockLists\u0026#34;=hex(7):57,00,61,00,61,00,53,00,4D,00,65,00,64,00,69,00,63,00,\\ 2E,00,65,00,78,00,65,00,00,00,57,00,61,00,61,00,73,00,4D,00,65,00,64,00,69,\\ 00,63,00,41,00,67,00,65,00,6E,00,74,00,2E,00,65,00,78,00,65,00,00,00,57,00,\\ 69,00,6E,00,64,00,6F,00,77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,\\ 00,64,00,65,00,2E,00,65,00,78,00,65,00,00,00,57,00,69,00,6E,00,64,00,6F,00,\\ 77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,00,64,00,65,00,72,00,41,\\ 00,70,00,70,00,2E,00,65,00,78,00,65,00,00,00,55,00,70,00,64,00,61,00,74,00,\\ 65,00,41,00,73,00,73,00,69,00,73,00,74,00,61,00,6E,00,74,00,2E,00,65,00,78,\\ 00,65,00,00,00,55,00,73,00,6F,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,00,\\ 65,00,78,00,65,00,00,00,72,00,65,00,6D,00,73,00,68,00,2E,00,65,00,78,00,65,\\ 00,00,00,45,00,4F,00,53,00,6E,00,6F,00,74,00,69,00,66,00,79,00,2E,00,65,00,\\ 78,00,65,00,00,00,53,00,69,00,68,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,\\ 00,65,00,78,00,65,00,00,00,75,00,70,00,66,00,63,00,2E,00,65,00,78,00,65,00,\\ 00,00,49,00,6E,00,73,00,74,00,61,00,6C,00,6C,00,41,00,67,00,65,00,6E,00,74,\\ 00,2E,00,65,00,78,00,65,00,00,00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,\\ 66,00,69,00,63,00,61,00,74,00,69,00,6F,00,6E,00,2E,00,65,00,78,00,65,00,00,\\ 00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,66,00,69,00,63,00,61,00,74,00,\\ 69,00,6F,00,6E,00,55,00,78,00,2E,00,65,00,78,00,65,00,00,00,00,00,00,00 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\EOSnotify.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\InstallAgent.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotification.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\MusNotificationUx.exe] \u0026#34;Debugger\u0026#34;=\u0026#34;/\u0026#34; [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\remsh.","title":"通过注册表禁用windows10自动更新"},{"content":"代码 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { l, _ := ListenNetlink() for { msgs, err := l.ReadMsgs() if err != nil { fmt.Println(\u0026#34;Could not read netlink: %s\u0026#34;, err) } for _, m := range msgs { if IsNewAddr(\u0026amp;m) { fmt.Println(\u0026#34;New Addr\u0026#34;) } if IsDelAddr(\u0026amp;m) { fmt.Println(\u0026#34;Del Addr\u0026#34;) } } } } type NetlinkListener struct { fd int sa *syscall.SockaddrNetlink } func ListenNetlink() (*NetlinkListener, error) { groups := (1 \u0026lt;\u0026lt; (syscall.RTNLGRP_LINK - 1)) | (1 \u0026lt;\u0026lt; (syscall.RTNLGRP_IPV4_IFADDR - 1)) | (1 \u0026lt;\u0026lt; (syscall.RTNLGRP_IPV6_IFADDR - 1)) s, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_DGRAM, syscall.NETLINK_ROUTE) if err != nil { return nil, fmt.Errorf(\u0026#34;socket: %s\u0026#34;, err) } saddr := \u0026amp;syscall.SockaddrNetlink{ Family: syscall.AF_NETLINK, Pid: uint32(0), Groups: uint32(groups), } err = syscall.Bind(s, saddr) if err != nil { return nil, fmt.Errorf(\u0026#34;bind: %s\u0026#34;, err) } return \u0026amp;NetlinkListener{fd: s, sa: saddr}, nil } func (l *NetlinkListener) ReadMsgs() ([]syscall.NetlinkMessage, error) { defer func() { recover() }() pkt := make([]byte, 2048) n, err := syscall.Read(l.fd, pkt) if err != nil { return nil, fmt.Errorf(\u0026#34;read: %s\u0026#34;, err) } msgs, err := syscall.ParseNetlinkMessage(pkt[:n]) if err != nil { return nil, fmt.Errorf(\u0026#34;parse: %s\u0026#34;, err) } return msgs, nil } func IsNewAddr(msg *syscall.NetlinkMessage) bool { if msg.Header.Type == syscall.RTM_NEWADDR { return true } return false } func IsDelAddr(msg *syscall.NetlinkMessage) bool { if msg.Header.Type == syscall.RTM_DELADDR { return true } return false } // rtm_scope is the distance to the destination: // // RT_SCOPE_UNIVERSE global route // RT_SCOPE_SITE interior route in the // local autonomous system // RT_SCOPE_LINK route on this link // RT_SCOPE_HOST route on the local host // RT_SCOPE_NOWHERE destination doesn\u0026#39;t exist // // The values between RT_SCOPE_UNIVERSE and RT_SCOPE_SITE are // available to the user. func IsRelevant(msg *syscall.IfAddrmsg) bool { if msg.Scope == syscall.RT_SCOPE_UNIVERSE || msg.Scope == syscall.RT_SCOPE_SITE { return true } return false } 参考 https://stackoverflow.com/questions/36347807/how-to-monitor-ip-address-change-using-rtnetlink-socket-in-go-language\nhttps://man7.org/linux/man-pages/man7/rtnetlink.7.html\nhttps://github.com/golang/go/issues/15080\n","permalink":"https://czyt.tech/post/golang-monitor-linux-network-events/","summary":"代码 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;syscall\u0026#34; ) func main() { l, _ := ListenNetlink() for { msgs, err := l.ReadMsgs() if err != nil { fmt.Println(\u0026#34;Could not read netlink: %s\u0026#34;, err) } for _, m := range msgs { if IsNewAddr(\u0026amp;m) { fmt.Println(\u0026#34;New Addr\u0026#34;) } if IsDelAddr(\u0026amp;m) { fmt.Println(\u0026#34;Del Addr\u0026#34;) } } } } type NetlinkListener struct { fd int sa *syscall.SockaddrNetlink } func ListenNetlink() (*NetlinkListener, error) { groups := (1 \u0026lt;\u0026lt; (syscall.","title":"Golang监测Linux网络事件"},{"content":"\r缘起 来自于一段prometheus代码\ntype stripeLock struct { sync.RWMutex // Padding to avoid multiple locks being on the same cache line. _ [40]byte } 简单地讲就是因为CPU读取数据的缓存机制问题，可能导致性能上的不同差异。参考资料见后文。\n常见类型的内存占用大小（Go101）：\nKinds of Types Value Size Required by Go Specification bool 1 byte not specified int8, uint8 (byte) 1 byte 1 byte int16, uint16 2 bytes 2 bytes int32 (rune), uint32, float32 4 bytes 4 bytes int64, uint64, float64, complex64 8 bytes 8 bytes complex128 16 bytes 16 bytes int, uint 1 word architecture dependent, 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures uintptr 1 word large enough to store the uninterpreted bits of a pointer value string 2 words not specified pointer (safe or unsafe) 1 word not specified slice 3 words not specified map 1 word not specified channel 1 word not specified function 1 word not specified interface 2 words not specified struct (the sum of sizes of all fields) + (the number of padding bytes) the size of a struct type is zero if it contains no fields that have a size greater than zero array (element value size) * (array length) the size of an array type is zero if its element type has zero size 参考 https://medium.com/@genchilu/whats-false-sharing-and-how-to-solve-it-using-golang-as-example-ef978a305e10 https://dariodip.medium.com/false-sharing-an-example-with-go-bc7e90594f3f https://github.com/glebarez/false-sharing-demo https://betterprogramming.pub/when-io-bound-hides-inside-cpu-e6e7f9df3187 https://colobu.com/2019/01/24/cacheline-affects-performance-in-go/ https://www.shouxicto.com/article/3984.html https://www.wangt.cc/2021/11/golang-%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E5%92%8C%E4%BC%AA%E5%85%B1%E4%BA%ABfalse-sharing/ ","permalink":"https://czyt.tech/post/golang-false-sharing/","summary":"缘起 来自于一段prometheus代码\ntype stripeLock struct { sync.RWMutex // Padding to avoid multiple locks being on the same cache line. _ [40]byte } 简单地讲就是因为CPU读取数据的缓存机制问题，可能导致性能上的不同差异。参考资料见后文。\n常见类型的内存占用大小（Go101）：\nKinds of Types Value Size Required by Go Specification bool 1 byte not specified int8, uint8 (byte) 1 byte 1 byte int16, uint16 2 bytes 2 bytes int32 (rune), uint32, float32 4 bytes 4 bytes int64, uint64, float64, complex64 8 bytes 8 bytes complex128 16 bytes 16 bytes int, uint 1 word architecture dependent, 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures uintptr 1 word large enough to store the uninterpreted bits of a pointer value string 2 words not specified pointer (safe or unsafe) 1 word not specified slice 3 words not specified map 1 word not specified channel 1 word not specified function 1 word not specified interface 2 words not specified struct (the sum of sizes of all fields) + (the number of padding bytes) the size of a struct type is zero if it contains no fields that have a size greater than zero array (element value size) * (array length) the size of an array type is zero if its element type has zero size 参考 https://medium.","title":"Golang False sharing"},{"content":"缘起 近期项目使用到相关技术，故整理文章一篇。\n获取可用输入设备 软件的本质无非是输入和输出，那么WPF如何获取电脑是否有可用输入设备呢？查询了Google,在StackOverflow上找到一个提问，原帖地址，代码如下：\nKeyboardCapabilities keyboardCapabilities = new Windows.Devices.Input.KeyboardCapabilities(); return keyboardCapabilities.KeyboardPresent != 0 ? true : false; 如果没有可用输入设备，那么就该虚拟键盘上场了。windows里面有两个虚拟键盘的程序，一个是TabTip.exe一个是osk.exe,可以直接调用进程，也可以使用 WPF的第三方组件https://github.com/maximcus/WPFTabTip 详细实现可以参考后面的链接。\n平板模式 下面代码将当前系统的运行模式改为平板模式\npublic static readonly Guid CLSID_ImmersiveShell = new Guid(\u0026#34;C2F03A33-21F5-47FA-B4BB-156362A2F239\u0026#34;); [ComImport()] [Guid(\u0026#34;4FDA780A-ACD2-41F7-B4F2-EBE674C9BF2A\u0026#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] public interface ITabletModeController { int GetMode(ref int mode); int SetMode(int mode, int modeTrigger); } [ComImport] [Guid(\u0026#34;6D5140C1-7436-11CE-8034-00AA006009FA\u0026#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] internal interface IServiceProvider { [return: MarshalAs(UnmanagedType.IUnknown)] object QueryService(ref Guid service, ref Guid riid); } 调用\nvar pSP = (IServiceProvider)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_ImmersiveShell)); var pTMC = (ITabletModeController)pSP.QueryService(typeof(ITabletModeController).GUID, typeof(ITabletModeController).GUID); if (pTMC != null) { // 0 = Desktop, 1 = Tablet int nMode = 0; int nRet = pTMC.GetMode(ref nMode); nRet = pTMC.SetMode(nMode==0?1:0, 4); } 系统运行模式检测\n[DllImport(\u0026#34;user32.dll\u0026#34;)] static extern int GetSystemMetrics(SystemMetric smIndex); //http://www.pinvoke.net/default.aspx/Enums/SystemMetric.html public enum SystemMetric { SM_CXSCREEN = 0, // 0x00 SM_CYSCREEN = 1, // 0x01 SM_CXVSCROLL = 2, // 0x02 SM_CYHSCROLL = 3, // 0x03 SM_CYCAPTION = 4, // 0x04 SM_CXBORDER = 5, // 0x05 SM_CYBORDER = 6, // 0x06 SM_CXDLGFRAME = 7, // 0x07 SM_CXFIXEDFRAME = 7, // 0x07 SM_CYDLGFRAME = 8, // 0x08 SM_CYFIXEDFRAME = 8, // 0x08 SM_CYVTHUMB = 9, // 0x09 SM_CXHTHUMB = 10, // 0x0A SM_CXICON = 11, // 0x0B SM_CYICON = 12, // 0x0C SM_CXCURSOR = 13, // 0x0D SM_CYCURSOR = 14, // 0x0E SM_CYMENU = 15, // 0x0F SM_CXFULLSCREEN = 16, // 0x10 SM_CYFULLSCREEN = 17, // 0x11 SM_CYKANJIWINDOW = 18, // 0x12 SM_MOUSEPRESENT = 19, // 0x13 SM_CYVSCROLL = 20, // 0x14 SM_CXHSCROLL = 21, // 0x15 SM_DEBUG = 22, // 0x16 SM_SWAPBUTTON = 23, // 0x17 SM_CXMIN = 28, // 0x1C SM_CYMIN = 29, // 0x1D SM_CXSIZE = 30, // 0x1E SM_CYSIZE = 31, // 0x1F SM_CXSIZEFRAME = 32, // 0x20 SM_CXFRAME = 32, // 0x20 SM_CYSIZEFRAME = 33, // 0x21 SM_CYFRAME = 33, // 0x21 SM_CXMINTRACK = 34, // 0x22 SM_CYMINTRACK = 35, // 0x23 SM_CXDOUBLECLK = 36, // 0x24 SM_CYDOUBLECLK = 37, // 0x25 SM_CXICONSPACING = 38, // 0x26 SM_CYICONSPACING = 39, // 0x27 SM_MENUDROPALIGNMENT = 40, // 0x28 SM_PENWINDOWS = 41, // 0x29 SM_DBCSENABLED = 42, // 0x2A SM_CMOUSEBUTTONS = 43, // 0x2B SM_SECURE = 44, // 0x2C SM_CXEDGE = 45, // 0x2D SM_CYEDGE = 46, // 0x2E SM_CXMINSPACING = 47, // 0x2F SM_CYMINSPACING = 48, // 0x30 SM_CXSMICON = 49, // 0x31 SM_CYSMICON = 50, // 0x32 SM_CYSMCAPTION = 51, // 0x33 SM_CXSMSIZE = 52, // 0x34 SM_CYSMSIZE = 53, // 0x35 SM_CXMENUSIZE = 54, // 0x36 SM_CYMENUSIZE = 55, // 0x37 SM_ARRANGE = 56, // 0x38 SM_CXMINIMIZED = 57, // 0x39 SM_CYMINIMIZED = 58, // 0x3A SM_CXMAXTRACK = 59, // 0x3B SM_CYMAXTRACK = 60, // 0x3C SM_CXMAXIMIZED = 61, // 0x3D SM_CYMAXIMIZED = 62, // 0x3E SM_NETWORK = 63, // 0x3F SM_CLEANBOOT = 67, // 0x43 SM_CXDRAG = 68, // 0x44 SM_CYDRAG = 69, // 0x45 SM_SHOWSOUNDS = 70, // 0x46 SM_CXMENUCHECK = 71, // 0x47 SM_CYMENUCHECK = 72, // 0x48 SM_SLOWMACHINE = 73, // 0x49 SM_MIDEASTENABLED = 74, // 0x4A SM_MOUSEWHEELPRESENT = 75, // 0x4B SM_XVIRTUALSCREEN = 76, // 0x4C SM_YVIRTUALSCREEN = 77, // 0x4D SM_CXVIRTUALSCREEN = 78, // 0x4E SM_CYVIRTUALSCREEN = 79, // 0x4F SM_CMONITORS = 80, // 0x50 SM_SAMEDISPLAYFORMAT = 81, // 0x51 SM_IMMENABLED = 82, // 0x52 SM_CXFOCUSBORDER = 83, // 0x53 SM_CYFOCUSBORDER = 84, // 0x54 SM_TABLETPC = 86, // 0x56 SM_MEDIACENTER = 87, // 0x57 SM_STARTER = 88, // 0x58 SM_SERVERR2 = 89, // 0x59 SM_MOUSEHORIZONTALWHEELPRESENT = 91, // 0x5B SM_CXPADDEDBORDER = 92, // 0x5C SM_DIGITIZER = 94, // 0x5E SM_MAXIMUMTOUCHES = 95, // 0x5F SM_REMOTESESSION = 0x1000, // 0x1000 SM_SHUTTINGDOWN = 0x2000, // 0x2000 SM_REMOTECONTROL = 0x2001, // 0x2001 SM_CONVERTABLESLATEMODE = 0x2003, SM_SYSTEMDOCKED = 0x2004, } // should handle in event SystemEvents.UserPreferenceChanging which e.Category == UserPreferenceCategory.General if (GetSystemMetrics(SystemMetric.SM_CONVERTABLESLATEMODE) == 0) { Debug.WriteLine(\u0026#34;detected slate mode\u0026#34;); } else if (GetSystemMetrics(SystemMetric.SM_SYSTEMDOCKED) == 0) { Debug.WriteLine(\u0026#34;detected docked mode\u0026#34;); } 修改键盘布局\nMSDN LoadKeyboardLayout\n[DllImport(\u0026#34;user32.dll\u0026#34;)] static extern IntPtr LoadKeyboardLayout(string pwszKLID, uint Flags); 调用例子\nLoadKeyboardLayout(\u0026#34;00010409\u0026#34;, 1) 参考 https://blog.mzikmund.com/2015/09/how-to-show-touch-keyboard-on-touch-interaction-with-wpf-textboxes/\nhttps://www.autohotkey.com/boards/viewtopic.php?t=15619\n","permalink":"https://czyt.tech/post/wpf-virtual-keyboard-related/","summary":"缘起 近期项目使用到相关技术，故整理文章一篇。\n获取可用输入设备 软件的本质无非是输入和输出，那么WPF如何获取电脑是否有可用输入设备呢？查询了Google,在StackOverflow上找到一个提问，原帖地址，代码如下：\nKeyboardCapabilities keyboardCapabilities = new Windows.Devices.Input.KeyboardCapabilities(); return keyboardCapabilities.KeyboardPresent != 0 ? true : false; 如果没有可用输入设备，那么就该虚拟键盘上场了。windows里面有两个虚拟键盘的程序，一个是TabTip.exe一个是osk.exe,可以直接调用进程，也可以使用 WPF的第三方组件https://github.com/maximcus/WPFTabTip 详细实现可以参考后面的链接。\n平板模式 下面代码将当前系统的运行模式改为平板模式\npublic static readonly Guid CLSID_ImmersiveShell = new Guid(\u0026#34;C2F03A33-21F5-47FA-B4BB-156362A2F239\u0026#34;); [ComImport()] [Guid(\u0026#34;4FDA780A-ACD2-41F7-B4F2-EBE674C9BF2A\u0026#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] public interface ITabletModeController { int GetMode(ref int mode); int SetMode(int mode, int modeTrigger); } [ComImport] [Guid(\u0026#34;6D5140C1-7436-11CE-8034-00AA006009FA\u0026#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] internal interface IServiceProvider { [return: MarshalAs(UnmanagedType.IUnknown)] object QueryService(ref Guid service, ref Guid riid); } 调用\nvar pSP = (IServiceProvider)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_ImmersiveShell)); var pTMC = (ITabletModeController)pSP.","title":"WPF与虚拟键盘的那些事"},{"content":"基础接口 授权 curl --location --request POST \u0026#39;https://api.gotokeep.com/v1.1/users/login\u0026#39; \\ --header \u0026#39;Content-Type: application/json\u0026#39; \\ --data-raw \u0026#39;{\u0026#34;mobile\u0026#34;: 18888888888, \u0026#34;password\u0026#34;: \u0026#34;aa\u0026#34;}\u0026#39; 返回token内容需要作为后续请求的header传递，返回示例：\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;data\u0026#34;: { \u0026#34;userId\u0026#34;: \u0026#34;011981111e131\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;goal\u0026#34;: 0, \u0026#34;gender\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;xxxxxxxxxxxx\u0026#34;, \u0026#34;userRegisterInfo\u0026#34;: null }, \u0026#34;errorCode\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;now\u0026#34;: \u0026#34;2022-04-21T05:02:57Z\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;text\u0026#34;: null, \u0026#34;more\u0026#34;: {} } 动作库 获取动作分类\ncurl --location --request GET \u0026#39;https://api.gotokeep.com/training/v2/trainingpoints/exerciselib\u0026#39; \\ --header \u0026#39;Authorization: Bearer xxxxxxxxx\u0026#39; 返回\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;data\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;胸部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad82\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963b0e73800000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;背部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad84\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963ab1a4c00000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;肩部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad83\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963b1db3c00000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;手臂\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad88\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/559639a46e400000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;颈部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;55cb1b72bfbf17f934371eba\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963afccdc00000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;腹部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad86\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963b3fc0400000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;腰部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;55cb1ca06fe674f94036d581\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963b2cc0800000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;臀部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad87\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/559639594f800000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;腿部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad85\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/55963ad31b400000.png\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;全身\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad81\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.keepcdn.com/misc/2016/08/05/12/559638c467800000.png\u0026#34; } ], \u0026#34;errorCode\u0026#34;: 0, \u0026#34;text\u0026#34;: \u0026#34;\u0026#34; } 获取动作库某个分类下的动作\ncurl --location --request GET \u0026#39;https://api.gotokeep.com/search/v3/exercise?trainingPoints=54826e417fb786000069ad82\u0026#39; \\ --header \u0026#39;Authorization: Bearer xxxxxxxxx\u0026#39; 动作搜索 curl --location --request GET \u0026#39;https://api.gotokeep.com/search/v4/exercise?keyword=坐姿左侧大腿后侧拉伸\u0026amp;limit=20\u0026#39; \\ --header \u0026#39;Authorization: Bearer xxxxxxxx\u0026#39; 参考 https://github.com/wodewone/keepForMac/blob/master/Doc-api-keep.md\n","permalink":"https://czyt.tech/post/keep-api-collect/","summary":"基础接口 授权 curl --location --request POST \u0026#39;https://api.gotokeep.com/v1.1/users/login\u0026#39; \\ --header \u0026#39;Content-Type: application/json\u0026#39; \\ --data-raw \u0026#39;{\u0026#34;mobile\u0026#34;: 18888888888, \u0026#34;password\u0026#34;: \u0026#34;aa\u0026#34;}\u0026#39; 返回token内容需要作为后续请求的header传递，返回示例：\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;data\u0026#34;: { \u0026#34;userId\u0026#34;: \u0026#34;011981111e131\u0026#34;, \u0026#34;level\u0026#34;: 0, \u0026#34;goal\u0026#34;: 0, \u0026#34;gender\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;token\u0026#34;: \u0026#34;xxxxxxxxxxxx\u0026#34;, \u0026#34;userRegisterInfo\u0026#34;: null }, \u0026#34;errorCode\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;now\u0026#34;: \u0026#34;2022-04-21T05:02:57Z\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;text\u0026#34;: null, \u0026#34;more\u0026#34;: {} } 动作库 获取动作分类\ncurl --location --request GET \u0026#39;https://api.gotokeep.com/training/v2/trainingpoints/exerciselib\u0026#39; \\ --header \u0026#39;Authorization: Bearer xxxxxxxxx\u0026#39; 返回\n{ \u0026#34;ok\u0026#34;: true, \u0026#34;data\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;胸部\u0026#34;, \u0026#34;_id\u0026#34;: \u0026#34;54826e417fb786000069ad82\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;http://static1.","title":"Keep运动接口"},{"content":"Csharp 安装Grpc.tools https://www.nuget.org/packages/Grpc.Tools/\n下载解压 nupkg文件（改扩展名为zip），也可以使用附件的7z包\n解压 找到tools中对应系统架构的软件，设置下环境变量，让系统可以找到就行。\nLinux 需要创建一个符号链接\nln -s `which grpc_csharp_plugin` /usr/bin/protoc-gen-grpc-csharp 修改Kratos项目的Make文件 在api这个make任务中添加下面内容\n--csharp_out=./api/pipe/v1 \\ --grpc-csharp_out=./api/pipe/v1 \\ 完整内容为\n.PHONY: api # generate api proto api: protoc --proto_path=./api \\ --proto_path=./third_party \\ --go_out=paths=source_relative:./api \\ --go-http_out=paths=source_relative:./api \\ --go-grpc_out=paths=source_relative:./api \\ --csharp_out=./api/pipe/v1 \\ --grpc-csharp_out=./api/pipe/v1 \\ --openapi_out==paths=source_relative:. \\ 参考\nhttps://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md\n📎tools.7z\nPython 安装必要包 pip install grpclib protobuf 查询路径 which protoc-gen-grpclib_python 或者 which protoc-gen-python_grpc我这里返回信息如下： ➜ czyt which protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpclib_python 如法炮制，创建软链接 ln -s /usr/sbin/protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpc_python 修改Makefile 添加下面的内容,再执行make api生成api即可。 --python_out=./api \\ --grpc_python_out=./api \\ TypeScript 纯typescript类 ts-proto typescript类+服务 安装proto工具 go get go.einride.tri p tech/protoc-gen-typescript-http\n在MakeFile中添加一行\n--typescript-http_out [OUTPUT DIR] \\ [.proto files ...] 生成的示例代码\nconst rootUrl = \u0026#34;...\u0026#34;; type Request = { path: string, method: string, body: string | null } function fetchRequestHandler({path, method, body}: Request) { return fetch(rootUrl + path, {method, body}).then(response =\u0026gt; response.json()) } export function siteClient() { return createShipperServiceClient(fetchRequestHandler); } 其他 在线proto转typescript ","permalink":"https://czyt.tech/post/add-muti-kinds-output-for-kratos/","summary":"Csharp 安装Grpc.tools https://www.nuget.org/packages/Grpc.Tools/\n下载解压 nupkg文件（改扩展名为zip），也可以使用附件的7z包\n解压 找到tools中对应系统架构的软件，设置下环境变量，让系统可以找到就行。\nLinux 需要创建一个符号链接\nln -s `which grpc_csharp_plugin` /usr/bin/protoc-gen-grpc-csharp 修改Kratos项目的Make文件 在api这个make任务中添加下面内容\n--csharp_out=./api/pipe/v1 \\ --grpc-csharp_out=./api/pipe/v1 \\ 完整内容为\n.PHONY: api # generate api proto api: protoc --proto_path=./api \\ --proto_path=./third_party \\ --go_out=paths=source_relative:./api \\ --go-http_out=paths=source_relative:./api \\ --go-grpc_out=paths=source_relative:./api \\ --csharp_out=./api/pipe/v1 \\ --grpc-csharp_out=./api/pipe/v1 \\ --openapi_out==paths=source_relative:. \\ 参考\nhttps://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md\n📎tools.7z\nPython 安装必要包 pip install grpclib protobuf 查询路径 which protoc-gen-grpclib_python 或者 which protoc-gen-python_grpc我这里返回信息如下： ➜ czyt which protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpclib_python 如法炮制，创建软链接 ln -s /usr/sbin/protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpc_python 修改Makefile 添加下面的内容,再执行make api生成api即可。 --python_out=.","title":"为Kratos prtobuf文件添加多种编译输出"},{"content":"下载 官方下载 https://go.dev/dl/\nGoogle 香港镜像\nGolang Downloads Mirrors\n更多请参考 Thanks Mirror\n环境设置 设置proxy\ngo env -w GOPROXY=https://goproxy.io,https://goproxy.cn,direct 安装相关工具 框架Cli kratos go install github.com/go-kratos/kratos/cmd/kratos/v2@latest\nwire go install github.com/google/wire/cmd/wire@latest\nent go install entgo.io/ent/cmd/ent@latest\nentimport go install ariga.io/entimport/cmd/entimport@latest\nentproto go install entgo.io/contrib/entproto/cmd/entproto@latest\n代码Lint golangci-lint go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\ngofumpt go install mvdan.cc/gofumpt@latest goland设置\nGoLand doesn\u0026rsquo;t use gopls so it should be configured to use gofumpt directly. Once gofumpt is installed, follow the steps below:\nOpen Settings (File \u0026gt; Settings) Open the Tools section Find the File Watchers sub-section Click on the + on the right side to add a new file watcher Choose Custom Template When a window asks for settings, you can enter the following:\nFile Types: Select all .go files Scope: Project Files Program: Select your gofumpt executable Arguments: -w $FilePath$ Output path to refresh: $FilePath$ Working directory: $ProjectFileDir$ Environment variables: GOROOT=$GOROOT$;GOPATH=$GOPATH$;PATH=$GoBinDirs$ To avoid unnecessary runs, you should disable all checkboxes in the Advanced section.\nbuf 需要使用格式化功能，windows环境需要安装diff工具,goland则需要安装插件Buf for Protocol Buffers\nbuf 首页: https://github.com/bufbuild/buf\n其他 Handy well-known and lesser-known tools for Go projects ","permalink":"https://czyt.tech/post/personal-golang-env-quick-set/","summary":"下载 官方下载 https://go.dev/dl/\nGoogle 香港镜像\nGolang Downloads Mirrors\n更多请参考 Thanks Mirror\n环境设置 设置proxy\ngo env -w GOPROXY=https://goproxy.io,https://goproxy.cn,direct 安装相关工具 框架Cli kratos go install github.com/go-kratos/kratos/cmd/kratos/v2@latest\nwire go install github.com/google/wire/cmd/wire@latest\nent go install entgo.io/ent/cmd/ent@latest\nentimport go install ariga.io/entimport/cmd/entimport@latest\nentproto go install entgo.io/contrib/entproto/cmd/entproto@latest\n代码Lint golangci-lint go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\ngofumpt go install mvdan.cc/gofumpt@latest goland设置\nGoLand doesn\u0026rsquo;t use gopls so it should be configured to use gofumpt directly. Once gofumpt is installed, follow the steps below:","title":"个人Golang环境安装快速设置"},{"content":"安装 机器安装的是Manjaro,所以本文介绍的是Manjaro的树莓派3安装方式\n➜ ~ screenfetch czyt@** OS: Manjaro-ARM 22.01 Kernel: aarch64 Linux 5.15.24-1-MANJARO-ARM-RPI ##### Uptime: 21d 21h 58m ####### Packages: Unknown ##O#O## Shell: zsh 5.8.1 ####### Disk: 11G / 118G (9%) ########### CPU: BCM2835 @ 4x 1.2GHz ############# GPU: ############### RAM: 248MiB / 919MiB ################ ################# ##################### ##################### ################# 使用命令 yay -S mongodb44-bin进行安装，安装完毕后\n启用服务 systemctl enable mongodb\n检查服务状态 systemctl status mongodb\n● mongodb.service - MongoDB Database Server Loaded: loaded (/usr/lib/systemd/system/mongodb.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2022-03-23 13:11:08 CST; 11s ago Docs: https://docs.mongodb.org/manual Main PID: 624895 (mongod) CPU: 2.610s CGroup: /system.slice/mongodb.service └─624895 /usr/bin/mongod --config /etc/mongodb.conf 遇到的问题 启动服务报错 非法指令 (核心已转储)英文系统可能是(Illegal instruction(core dumped))\n开始使用的是 yay -S mongodb-bin进行安装，后搜索官方论坛发现是官方打包的时候默认使用了最新架构，但是树莓派是老设备，可能不支持部分指令，换成上文的指令安装4.x版本后解决。 注意：默认安装是不在mongodb tools的，所以需要执行 yay -S mongodb-tools-bin进行安装。参考下面语句：\n备份\nmongodump -h \u0026lt;host\u0026gt;:\u0026lt;port\u0026gt; -u \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; -d ubertower-new -o /path/to/destination/directory 恢复\nmongorestore -h \u0026lt;host\u0026gt;:\u0026lt;port\u0026gt; -u \u0026lt;username\u0026gt; -p \u0026lt;password\u0026gt; -d \u0026lt;DBNAME\u0026gt; /path/to/destination/directory/\u0026lt;DBNAME\u0026gt; 恢复文件夹下的bson文件\nfor FILENAME in *.bson; do mongorestore -d nts -c \u0026#34;${FILENAME%.*}\u0026#34; $FILENAME; done // 带权限的恢复 for FILENAME in *.bson; do mongorestore --authenticationDatabase=\u0026#34;admin\u0026#34; -d \u0026#34;nts\u0026#34; -u=\u0026#34;xxxx\u0026#34; -p=\u0026#34;yyyy\u0026#34; -c \u0026#34;${FILENAME%.*}\u0026#34; $FILENAME; done 原帖 https://www.mongodb.com/community/forums/t/core-dump-on-mongodb-5-0-on-rpi-4/115291/13\n启动服务后不能连接到mongoDB\n需要修改配置文件，默认是/etc/mongodb.conf,修改其中的监听地址为0.0.0.0或者您要访问MongoDB服务的网段中当前设备的IP。\n# network interfaces net: port: 27017 bindIp: 0.0.0.0 创建用户。执行mongo命令，执行下面的命令。\nuse admin; db.createUser( { user: \u0026#34;admin\u0026#34;, pwd: \u0026#34;admin_Pwd\u0026#34;, roles: [ { role: \u0026#34;readAnyDatabase\u0026#34;, db: \u0026#34;admin\u0026#34; } ] } ); 后期如果需要调整角色，可以使用语句db.grantRolesToUser(\u0026quot;admin\u0026quot;,[\u0026quot;userAdminAnyDatabase\u0026quot;])\n修改配置文件/etc/mongodb.conf，启用授权连接。\nsecurity: authorization: enabled 重启mongodb服务 systemctl restart mongodb 使配置生效。\n参考连接 https://dba.stackexchange.com/questions/283843/create-user-for-all-databases-in-mongodb https://www.guru99.com/mongodb-create-user.html ","permalink":"https://czyt.tech/post/install-mongodb-on-rasp3b/","summary":"安装 机器安装的是Manjaro,所以本文介绍的是Manjaro的树莓派3安装方式\n➜ ~ screenfetch czyt@** OS: Manjaro-ARM 22.01 Kernel: aarch64 Linux 5.15.24-1-MANJARO-ARM-RPI ##### Uptime: 21d 21h 58m ####### Packages: Unknown ##O#O## Shell: zsh 5.8.1 ####### Disk: 11G / 118G (9%) ########### CPU: BCM2835 @ 4x 1.2GHz ############# GPU: ############### RAM: 248MiB / 919MiB ################ ################# ##################### ##################### ################# 使用命令 yay -S mongodb44-bin进行安装，安装完毕后\n启用服务 systemctl enable mongodb\n检查服务状态 systemctl status mongodb\n● mongodb.service - MongoDB Database Server Loaded: loaded (/usr/lib/systemd/system/mongodb.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2022-03-23 13:11:08 CST; 11s ago Docs: https://docs.","title":"Rasp3b 安装MongoDB"},{"content":"Nuget包 基础包 Microsoft Logging Abstractions Microsoft Extensions DependencyInjection 可选日志包 可以按实际需求进行选择，如NLog等,我们这里采用的是 Serilog 这个Nuget包Serilog Extensions Logging\n根据日志输出的目标不同，可以选择不同的扩展方法包\n目标 包名 说明 文件 Serilog.Sinks.File WiteTo可以使用File方法详细说明 命令行 Serilog.Sinks.Console 调试输出 Serilog.Sinks.Debug WiteTo可以使用Debug方法 其他扩展，请搜索 点击\n日志容器注册 我们使用的是 DryIoc 进行注册，需要安装Nuget包 DryIoc.Microsoft.DependencyInjection 具体代码如下：\nprotected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =\u0026gt; loggingBuilder.AddSerilog(dispose: true)); return new DryIocContainerExtension(new Container(CreateContainerRules()) .WithDependencyInjectionAdapter(serviceCollection)); } 如果是Unity 则需要安装包 Unity.Microsoft.DependencyInjection 具体代码如下：\nprotected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =\u0026gt; loggingBuilder.AddSerilog(dispose: true)); var container = new UnityContainer(); container.BuildServiceProvider(serviceCollection); return new UnityContainerExtension(container); } 我们对于不同的日志插件框架都是在 AddLogging这个地方进行添加的，需要注意的是我们不仅需要在ServiceCollection 中注册，还需要在容器对象中注册。注意区分 DryIoc中的WithDependencyInjectionAdapter 与Unity中的BuildServiceProvider使用差异。\n日志配置 日志配置在Prism入口程序的CreateShell方法中\nprotected override Window CreateShell() { Log.Logger = new LoggerConfiguration() .Enrich.FromLogContext() .WriteTo.File(\u0026#34;App.log\u0026#34;) .CreateLogger(); return Container.Resolve\u0026lt;MainWindow\u0026gt;(); } 日志使用 注册ILogger接口使用日志\npublic class MyService : IMyService { public MyService(ILogger\u0026lt;MyService\u0026gt; logger) { logger.LogInformation(\u0026#34;Hello World from your logger!\u0026#34;); } } 参考连接 How To Register Logging in a Prism 8 WPF App WPF Prism8.0中注册Nlog日志服务 ","permalink":"https://czyt.tech/post/how-to-register-logging-in-prism8/","summary":"Nuget包 基础包 Microsoft Logging Abstractions Microsoft Extensions DependencyInjection 可选日志包 可以按实际需求进行选择，如NLog等,我们这里采用的是 Serilog 这个Nuget包Serilog Extensions Logging\n根据日志输出的目标不同，可以选择不同的扩展方法包\n目标 包名 说明 文件 Serilog.Sinks.File WiteTo可以使用File方法详细说明 命令行 Serilog.Sinks.Console 调试输出 Serilog.Sinks.Debug WiteTo可以使用Debug方法 其他扩展，请搜索 点击\n日志容器注册 我们使用的是 DryIoc 进行注册，需要安装Nuget包 DryIoc.Microsoft.DependencyInjection 具体代码如下：\nprotected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =\u0026gt; loggingBuilder.AddSerilog(dispose: true)); return new DryIocContainerExtension(new Container(CreateContainerRules()) .WithDependencyInjectionAdapter(serviceCollection)); } 如果是Unity 则需要安装包 Unity.Microsoft.DependencyInjection 具体代码如下：\nprotected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =\u0026gt; loggingBuilder.","title":"WPF Prism 8如何注册Logging"},{"content":" 下载protoc，打开链接 下载后将对应的文件解压到gopath的bin目录。 下载protoc的golang插件。下载地址 链接 下载后放在protoc的同级目录（需要改扩展名为exe） 测试，定义一个Proto syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;.;hello\u0026#34;; package main; message String { string value = 1; } 然后执行命令 protoc hello.proto --go_out=. ,大功告成，生成的文件内容如下：\n// Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.24.0-devel // protoc v3.12.3 // source: hello.proto package hello import ( proto \u0026#34;github.com/golang/protobuf/proto\u0026#34; protoreflect \u0026#34;google.golang.org/protobuf/reflect/protoreflect\u0026#34; protoimpl \u0026#34;google.golang.org/protobuf/runtime/protoimpl\u0026#34; reflect \u0026#34;reflect\u0026#34; sync \u0026#34;sync\u0026#34; ) const ( // Verify that this generated code is sufficiently up-to-date. _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion) // Verify that runtime/protoimpl is sufficiently up-to-date. _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20) ) // This is a compile-time assertion that a sufficiently up-to-date version // of the legacy proto package is being used. const _ = proto.ProtoPackageIsVersion4 type String struct { state protoimpl.MessageState sizeCache protoimpl.SizeCache unknownFields protoimpl.UnknownFields Value string `protobuf:\u0026#34;bytes,1,opt,name=value,proto3\u0026#34; json:\u0026#34;value,omitempty\u0026#34;` } func (x *String) Reset() { *x = String{} if protoimpl.UnsafeEnabled { mi := \u0026amp;file_hello_proto_msgTypes[0] ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) ms.StoreMessageInfo(mi) } } func (x *String) String() string { return protoimpl.X.MessageStringOf(x) } func (*String) ProtoMessage() {} func (x *String) ProtoReflect() protoreflect.Message { mi := \u0026amp;file_hello_proto_msgTypes[0] if protoimpl.UnsafeEnabled \u0026amp;\u0026amp; x != nil { ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x)) if ms.LoadMessageInfo() == nil { ms.StoreMessageInfo(mi) } return ms } return mi.MessageOf(x) } // Deprecated: Use String.ProtoReflect.Descriptor instead. func (*String) Descriptor() ([]byte, []int) { return file_hello_proto_rawDescGZIP(), []int{0} } func (x *String) GetValue() string { if x != nil { return x.Value } return \u0026#34;\u0026#34; } var File_hello_proto protoreflect.FileDescriptor var file_hello_proto_rawDesc = []byte{ 0x0a, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x22, 0x1e, 0x0a, 0x06, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x42, 0x09, 0x5a, 0x07, 0x2e, 0x3b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33, } var ( file_hello_proto_rawDescOnce sync.Once file_hello_proto_rawDescData = file_hello_proto_rawDesc ) func file_hello_proto_rawDescGZIP() []byte { file_hello_proto_rawDescOnce.Do(func() { file_hello_proto_rawDescData = protoimpl.X.CompressGZIP(file_hello_proto_rawDescData) }) return file_hello_proto_rawDescData } var file_hello_proto_msgTypes = make([]protoimpl.MessageInfo, 1) var file_hello_proto_goTypes = []interface{}{ (*String)(nil), // 0: main.String } var file_hello_proto_depIdxs = []int32{ 0, // [0:0] is the sub-list for method output_type 0, // [0:0] is the sub-list for method input_type 0, // [0:0] is the sub-list for extension type_name 0, // [0:0] is the sub-list for extension extendee 0, // [0:0] is the sub-list for field type_name } func init() { file_hello_proto_init() } func file_hello_proto_init() { if File_hello_proto != nil { return } if !protoimpl.UnsafeEnabled { file_hello_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} { switch v := v.(*String); i { case 0: return \u0026amp;v.state case 1: return \u0026amp;v.sizeCache case 2: return \u0026amp;v.unknownFields default: return nil } } } type x struct{} out := protoimpl.TypeBuilder{ File: protoimpl.DescBuilder{ GoPackagePath: reflect.TypeOf(x{}).PkgPath(), RawDescriptor: file_hello_proto_rawDesc, NumEnums: 0, NumMessages: 1, NumExtensions: 0, NumServices: 0, }, GoTypes: file_hello_proto_goTypes, DependencyIndexes: file_hello_proto_depIdxs, MessageInfos: file_hello_proto_msgTypes, }.Build() File_hello_proto = out.File file_hello_proto_rawDesc = nil file_hello_proto_goTypes = nil file_hello_proto_depIdxs = nil } 注意:\n参考官网的步骤，精简下安装流程\n启用GOMOUDLE 运行 set GO111MODULE=on (临时)或者设置环境变量\n安装生成相关工具\ngo插件\ngo get -u google.golang.org/protobuf/cmd/protoc-gen-go go get -u google.golang.org/grpc/cmd/protoc-gen-go-grpc protobuf编译器 可以去github release页面下载，我这里直接给出地址，请按系统架构选择，下载解压到GOPATH目录即可\nhttps://github.com/protocolbuffers/protobuf/releases/download/v3.14.0/protoc-3.14.0-win32.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.14.0/protoc-3.14.0-win64.zip vsCode可以安装插件 vscode-proto3 后，在 settings.json 中添加下面的内容，将可以实现保存proto文件后自动生成对应的go文件：\n\u0026#34;protoc\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;${env.GOPATH}/bin/protoc\u0026#34;, \u0026#34;compile_on_save\u0026#34;: true, \u0026#34;options\u0026#34;: [ \u0026#34;--proto_path=.\u0026#34;, \u0026#34;--proto_path=${workspaceRoot}/proto\u0026#34;, \u0026#34;--experimental_allow_proto3_optional\u0026#34;, // \u0026#34;--csharp_out=${workspaceRoot}/proto\u0026#34;, \u0026#34;--go_out=${workspaceRoot}/proto\u0026#34;, \u0026#34;--go_opt=paths=source_relative\u0026#34;, \u0026#34;--go-grpc_out=require_unimplemented_servers=false:${workspaceRoot}/proto\u0026#34;, \u0026#34;--go-grpc_opt=paths=source_relative\u0026#34; ] }, 注： 处理官方库不能访问的问题\ngo mod edit -replace=google.golang.org/grpc=github.com/grpc/grpc-go@latest go mod tidy go mod vendor go build -mod=vendor grpc生态插件 github\ngo install \\ github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway \\ github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-openapiv2 \\ google.golang.org/protobuf/cmd/protoc-gen-go \\ google.golang.org/grpc/cmd/protoc-gen-go-grpc 常见问题 protoc-gen-go failed :: The import path must contain at least one forward slash (\u0026rsquo;/\u0026rsquo;) character.\u0026quot;\n修改proto定义中的 `option go_package=\u0026quot;pb\u0026quot;;` 为 `option go_package = \u0026quot;./;pb\u0026quot;;`\r参考\n链接\n参考教程 https://www.liwenzhou.com/posts/Go/gRPC/ https://blog.didiyun.com/index.php/2018/12/12/grpc-golang-1/ ","permalink":"https://czyt.tech/post/grpc-golang-setup-in-windows/","summary":"下载protoc，打开链接 下载后将对应的文件解压到gopath的bin目录。 下载protoc的golang插件。下载地址 链接 下载后放在protoc的同级目录（需要改扩展名为exe） 测试，定义一个Proto syntax = \u0026#34;proto3\u0026#34;; option go_package = \u0026#34;.;hello\u0026#34;; package main; message String { string value = 1; } 然后执行命令 protoc hello.proto --go_out=. ,大功告成，生成的文件内容如下：\n// Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.24.0-devel // protoc v3.12.3 // source: hello.proto package hello import ( proto \u0026#34;github.com/golang/protobuf/proto\u0026#34; protoreflect \u0026#34;google.golang.org/protobuf/reflect/protoreflect\u0026#34; protoimpl \u0026#34;google.golang.org/protobuf/runtime/protoimpl\u0026#34; reflect \u0026#34;reflect\u0026#34; sync \u0026#34;sync\u0026#34; ) const ( // Verify that this generated code is sufficiently up-to-date.","title":"grpc-golang windows环境搭建说明"},{"content":"下载rustup 从此处下载\n设置rustup镜像 字节提供的镜像 https://rsproxy.cn\nexport RUSTUP_DIST_SERVER=\u0026#34;https://rsproxy.cn\u0026#34; export RUSTUP_UPDATE_ROOT=\u0026#34;https://rsproxy.cn/rustup\u0026#34; 设置两个环境变量即可 设置环境变量 RUSTUP_DIST_SERVER (用于更新 toolchain)\nexport RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 以及 RUSTUP_UPDATE_ROOT (用于更新 rustup)\nexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup crates.io 镜像 编辑 ~/.cargo/config [source.crates-io]\rreplace-with = \u0026#39;rsproxy\u0026#39;\r[source.rsproxy]\rregistry = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[registries.rsproxy]\rindex = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[net]\rgit-fetch-with-cli = true 安装Rust 安装rust即可。可以参考我的步骤\nCurrent installation options: default host triple: x86_64-pc-windows-msvc default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation \u0026gt;2 I\u0026#39;m going to ask you the value of each of these installation options. You may simply press the Enter key to leave unchanged. Default host triple? x86_64-pc-windows-gnu Default toolchain? (stable/beta/nightly/none) Profile (which tools and data to install)? (minimal/default/complete) Modify PATH variable? (y/n) y Current installation options: default host triple: x86_64-pc-windows-gnu default toolchain: stable profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation \u0026gt;1 info: profile set to \u0026#39;default\u0026#39; info: setting default host triple to x86_64-pc-windows-gnu info: syncing channel updates for \u0026#39;stable-x86_64-pc-windows-gnu\u0026#39; info: latest update on 2020-10-08, rust version 1.47.0 (18bf6b4f0 2020-10-07) info: downloading component \u0026#39;cargo\u0026#39; 5.6 MiB / 5.6 MiB (100 %) 1023.6 KiB/s in 5s ETA: 0s info: downloading component \u0026#39;clippy\u0026#39; info: downloading component \u0026#39;rust-docs\u0026#39; 12.9 MiB / 12.9 MiB (100 %) 5.5 MiB/s in 1s ETA: 0s info: downloading component \u0026#39;rust-mingw\u0026#39; 4.2 MiB / 4.2 MiB (100 %) 1.4 MiB/s in 4s ETA: 0s info: downloading component \u0026#39;rust-std\u0026#39; 19.5 MiB / 19.5 MiB (100 %) 15.5 MiB/s in 1s ETA: 0s info: downloading component \u0026#39;rustc\u0026#39; 66.4 MiB / 66.4 MiB (100 %) 13.0 MiB/s in 8s ETA: 0s info: downloading component \u0026#39;rustfmt\u0026#39; 6.0 MiB / 6.0 MiB (100 %) 1.3 MiB/s in 4s ETA: 0s info: installing component \u0026#39;cargo\u0026#39; info: Defaulting to 500.0 MiB unpack ram info: installing component \u0026#39;clippy\u0026#39; info: installing component \u0026#39;rust-docs\u0026#39; 12.9 MiB / 12.9 MiB (100 %) 2.9 MiB/s in 4s ETA: 0s info: installing component \u0026#39;rust-mingw\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; 19.5 MiB / 19.5 MiB (100 %) 9.5 MiB/s in 2s ETA: 0s info: installing component \u0026#39;rustc\u0026#39; 66.4 MiB / 66.4 MiB (100 %) 10.1 MiB/s in 6s ETA: 0s info: installing component \u0026#39;rustfmt\u0026#39; info: default toolchain set to \u0026#39;stable\u0026#39; stable installed - rustc 1.47.0 (18bf6b4f0 2020-10-07) Rust is installed now. Great! 配置cargo镜像 参考\nhttps://www.cnblogs.com/dhcn/p/12100675.html\nhttps://erasin.wang/rustup/\n跨平台编译 rust支持的Target列表 rustup target list\naarch64-apple-darwin aarch64-apple-ios aarch64-apple-ios-sim aarch64-fuchsia aarch64-linux-android aarch64-pc-windows-msvc aarch64-unknown-linux-gnu aarch64-unknown-linux-musl aarch64-unknown-none aarch64-unknown-none-softfloat arm-linux-androideabi arm-unknown-linux-gnueabi arm-unknown-linux-gnueabihf arm-unknown-linux-musleabi arm-unknown-linux-musleabihf armebv7r-none-eabi armebv7r-none-eabihf armv5te-unknown-linux-gnueabi armv5te-unknown-linux-musleabi armv7-linux-androideabi armv7-unknown-linux-gnueabi armv7-unknown-linux-gnueabihf armv7-unknown-linux-musleabi armv7-unknown-linux-musleabihf armv7a-none-eabi armv7r-none-eabi armv7r-none-eabihf asmjs-unknown-emscripten i586-pc-windows-msvc i586-unknown-linux-gnu i586-unknown-linux-musl i686-linux-android i686-pc-windows-gnu i686-pc-windows-msvc i686-unknown-freebsd i686-unknown-linux-gnu i686-unknown-linux-musl mips-unknown-linux-gnu mips-unknown-linux-musl mips64-unknown-linux-gnuabi64 mips64-unknown-linux-muslabi64 mips64el-unknown-linux-gnuabi64 mips64el-unknown-linux-muslabi64 mipsel-unknown-linux-gnu mipsel-unknown-linux-musl nvptx64-nvidia-cuda powerpc-unknown-linux-gnu powerpc64-unknown-linux-gnu powerpc64le-unknown-linux-gnu riscv32i-unknown-none-elf riscv32imac-unknown-none-elf riscv32imc-unknown-none-elf riscv64gc-unknown-linux-gnu riscv64gc-unknown-none-elf riscv64imac-unknown-none-elf s390x-unknown-linux-gnu sparc64-unknown-linux-gnu sparcv9-sun-solaris thumbv6m-none-eabi thumbv7em-none-eabi thumbv7em-none-eabihf thumbv7m-none-eabi thumbv7neon-linux-androideabi thumbv7neon-unknown-linux-gnueabihf thumbv8m.base-none-eabi thumbv8m.main-none-eabi thumbv8m.main-none-eabihf wasm32-unknown-emscripten wasm32-unknown-unknown wasm32-wasi x86_64-apple-darwin x86_64-apple-ios x86_64-fortanix-unknown-sgx x86_64-fuchsia x86_64-linux-android x86_64-pc-solaris x86_64-pc-windows-gnu x86_64-pc-windows-msvc x86_64-sun-solaris x86_64-unknown-freebsd x86_64-unknown-illumos x86_64-unknown-linux-gnu (installed) x86_64-unknown-linux-gnux32 x86_64-unknown-linux-musl x86_64-unknown-netbsd x86_64-unknown-redox 这里以添加aarch64-unknown-linux-gnu平台为例，添加命令如下：\nrustup target add --toolchain stable aarch64-unknown-linux-gnu Ps：如果要移除指定Target把上面命令换成rustup target remove即可。\n输出如下\ninfo: downloading component \u0026#39;rust-std\u0026#39; for \u0026#39;aarch64-unknown-linux-gnu\u0026#39; info: installing component \u0026#39;rust-std\u0026#39; for \u0026#39;aarch64-unknown-linux-gnu\u0026#39; 35.6 MiB / 35.6 MiB (100 %) 9.9 MiB/s in 3s ETA: 0s 安装完成后可以通过Cargo进行编译 cargo build --target=aarch64-unknown-linux-gnu\n参考\nCross-compilation\ncompiling-rust-for-raspberry-pi-arm\n\u0026ndash; 全文完 \u0026ndash;\n","permalink":"https://czyt.tech/post/rust-setup-and-config/","summary":"下载rustup 从此处下载\n设置rustup镜像 字节提供的镜像 https://rsproxy.cn\nexport RUSTUP_DIST_SERVER=\u0026#34;https://rsproxy.cn\u0026#34; export RUSTUP_UPDATE_ROOT=\u0026#34;https://rsproxy.cn/rustup\u0026#34; 设置两个环境变量即可 设置环境变量 RUSTUP_DIST_SERVER (用于更新 toolchain)\nexport RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 以及 RUSTUP_UPDATE_ROOT (用于更新 rustup)\nexport RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup crates.io 镜像 编辑 ~/.cargo/config [source.crates-io]\rreplace-with = \u0026#39;rsproxy\u0026#39;\r[source.rsproxy]\rregistry = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[registries.rsproxy]\rindex = \u0026#34;https://rsproxy.cn/crates.io-index\u0026#34;\r[net]\rgit-fetch-with-cli = true 安装Rust 安装rust即可。可以参考我的步骤\nCurrent installation options: default host triple: x86_64-pc-windows-msvc default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation \u0026gt;2 I\u0026#39;m going to ask you the value of each of these installation options.","title":"Rust安装及配置"},{"content":"示例：\nhttps://dds.dui.ai/runtime/v1/synthesize?voiceId=ppangf_csn\u0026amp;text=您好世界\u0026amp;speed=1\u0026amp;volume=50\u0026amp;audioType=wav 使用步骤\ngraph LR;\r选择声音 --\u003e 输入要转语音文本 --\u003e 拼接URL --\u003e 使用语音\r参数说明：\ntext 要转音频的文本内容 （200字以内） speed 语速 volume 声音大小 voiceId 发音类型可以取下面的值： VoiceId 名称 说明 qiumum_0gushi 精品秋木 活泼开朗适合有声读物等场景 kaolam_diantai 精品考拉 电台男声温柔的电台男声 juan1f 小美 客服女声声音甜美热情，客服、营销场景均适用 xmguof 婷婷 营销女声音色亲切大方，适用于电话销售、调研回访等场景 xmamif 小咪 营销女声活力甜美，适用于电话营销、邀约等场景 lunaif_ctn 晓健 标准粤语女声偏正式的标准粤语，适用于新闻播报等场景 hchunf_ctn 何春 自然粤语女声音色偏甜美自然，适用于家居播报等场景 dayaof_csd 大瑶 山东话女声音色偏甜美自然，适用于家居播报等场景 wqingf_csn 文卿 四川话女声音色偏甜美自然，适用于车载导航等场景 ppangf_csn 胖胖 四川话女声音色偏甜美自然，适用于家居播报等场景 yezi1f_csh 叶子 上海话女声音色偏甜美自然，适用于家居播报等场景 madoufp_yubo 麻豆 娱播女声甜美欢快的女声，适合做娱乐新闻的播报 madoufp_wenrou 麻豆 甜美温柔客服、营销、阅读听书的场景均可使用 xjingfp 小静 甜美女声音色甜美知性，可用于娱乐新闻等播报 xjingf_gushi 小静 自然音色甜美知性，可用于娱乐新闻等播报 xjingf 小静 商务知性音色甜美知性，可用于娱乐新闻等播报 zhilingfp 小玲 甜美女神音色亲切、欢快、自然，适合用于各种场景 zhilingfp_huankuai 小玲 欢快自然音色亲切、欢快、自然，适合用于各种场景 zhilingfa 小玲 标准小玲的音色亲切，甜美，自然，适合用于各种场景 zhilingf 传统小玲 甜美性感音色甜美、自然、性感，适合用于各种场景 anonyf 小佚 平和沉稳音色沉稳严肃，适合用于新闻播报等 xbekef 贝壳 可爱女童童真可爱，适合讲幼儿故事 xijunma 精品小军 新闻播报适合新闻播报等场景 xijunm 传统小军 标准正式标准发音，适合新闻播报等场景 geyou 葛爷 淡定风趣模仿葛优音色 gdgm 纲叔 沉稳幽默模仿郭德纲音色 zxcm 星哥 风趣幽默模仿周星驰音色 qianranf 传统然然 天真俏皮成人女声模仿女童音色 hyanif 小妮 温柔亲切适合情感电台播报等场景 gqlanf 标准小兰 邻家女声温柔的邻家女声，适合做客服音色 gqlanfp 精品小兰 温柔甜美温柔的邻家女声，适合做客服音色 qianranfa 标准然然 天真俏皮语速1.2\u0026ndash;1.4更佳 kaolaf 考拉 端庄优雅适合做新闻资讯等场景 smjief 小洁 亲切缓和推荐百科等有声读物的播报 wjianm_xsheng 小江 亲切友善推荐电话客服的场景,推荐语速1.3 feyinf 风吟 女老师威严正式的女老师 jlshim 季老师 成熟稳重适用于新闻播报的场景 lili1f_shangwu 璃璃 商务大气适用于新闻、政务的内容播报 lili1f_yubo 璃璃 活力娱播适合娱乐新闻的播报 xizhef 行者 端庄正式端庄严肃的女声，适合社会新闻的播报 cyangfp 精品初阳 乖巧可爱乖巧可爱的女学生音色，可用于导航场景 cyangf 标准初阳 乖巧可爱乖巧可爱的女学生音色，可用于导航场景 lzliafp 精品连连 活泼可爱推荐讲童话故事等有声读物 lzliafa 标准连连 活泼可爱推荐讲童话故事等有声读物 lzliaf 传统连连 活泼可爱推荐有声读物的场景 gdfanf_natong 方方 元气男孩推荐有声读物的场景 hyanifa 标准小妮 温柔亲切适合情感电台播报等场景 lucyfa 小浩 干练适合英文场景 gdfanfp 芳芳 甜美客服推荐客服场景使用 aningfp 精品安宁 温婉温婉可人，适合讲哲理故事 aningf 标准安宁 温婉温婉可人，适合讲哲理故事 boy 堂堂 少先队推荐使用电话手表等智能设备场景 jjingf 标准晶晶 知性大方知性大方，适合多种文本与场景 jjingfp 精品晶晶 知性大方知性大方，适合多种文本与场景 kaolam 考拉 标准男声发音标准正式，适合新闻资讯等场景 lanyuf 蓝雨 温柔甜美温柔甜美的女声，擅长讲童话故事 lili1f_diantai 璃璃 电台安静适用情感电台的场景 qiumum 秋木 活泼开朗推荐讲寓言故事 tzruim 小睿 活力朝气适合读课文 xiyaof 小妖 慵懒烟嗓特殊的慵懒嗓音，适合讲悬疑小说 xiyaof_qingxin 小妖 清新甜美适合讲言情小说 yaayif 杨阿姨 和蔼可亲亲切的阿姨，适合讲百科知识等场景 zzherf 朱株儿 温柔舒适推荐讲童话故事等有声读物 juyinf_guigushi 绝音 鬼故事推荐讲鬼故事等恐怖场景 zzhuaf 砖砖 自然推荐讲寓言故事等有声读物 yukaim_all 俞老师 磁性发音自然有磁性，可用户哲理故事场景 linbaf_gaoleng 零八 高冷推荐有声读物的场景 linbaf_qingxin 零八 清新推荐有声读物的场景 xiyaof_laoshi 小妖 女老师推荐武侠小说等场景 anonyg 佚佚 成人女声模仿女童音色 luyaof 瑶瑶 自然亲切可用与情感电台等场景 官方网站 https://www.talkinggenie.com/tts\n","permalink":"https://czyt.tech/post/a-free-tts-api/","summary":"示例：\nhttps://dds.dui.ai/runtime/v1/synthesize?voiceId=ppangf_csn\u0026amp;text=您好世界\u0026amp;speed=1\u0026amp;volume=50\u0026amp;audioType=wav 使用步骤\ngraph LR;\r选择声音 --\u003e 输入要转语音文本 --\u003e 拼接URL --\u003e 使用语音\r参数说明：\ntext 要转音频的文本内容 （200字以内） speed 语速 volume 声音大小 voiceId 发音类型可以取下面的值： VoiceId 名称 说明 qiumum_0gushi 精品秋木 活泼开朗适合有声读物等场景 kaolam_diantai 精品考拉 电台男声温柔的电台男声 juan1f 小美 客服女声声音甜美热情，客服、营销场景均适用 xmguof 婷婷 营销女声音色亲切大方，适用于电话销售、调研回访等场景 xmamif 小咪 营销女声活力甜美，适用于电话营销、邀约等场景 lunaif_ctn 晓健 标准粤语女声偏正式的标准粤语，适用于新闻播报等场景 hchunf_ctn 何春 自然粤语女声音色偏甜美自然，适用于家居播报等场景 dayaof_csd 大瑶 山东话女声音色偏甜美自然，适用于家居播报等场景 wqingf_csn 文卿 四川话女声音色偏甜美自然，适用于车载导航等场景 ppangf_csn 胖胖 四川话女声音色偏甜美自然，适用于家居播报等场景 yezi1f_csh 叶子 上海话女声音色偏甜美自然，适用于家居播报等场景 madoufp_yubo 麻豆 娱播女声甜美欢快的女声，适合做娱乐新闻的播报 madoufp_wenrou 麻豆 甜美温柔客服、营销、阅读听书的场景均可使用 xjingfp 小静 甜美女声音色甜美知性，可用于娱乐新闻等播报 xjingf_gushi 小静 自然音色甜美知性，可用于娱乐新闻等播报 xjingf 小静 商务知性音色甜美知性，可用于娱乐新闻等播报 zhilingfp 小玲 甜美女神音色亲切、欢快、自然，适合用于各种场景 zhilingfp_huankuai 小玲 欢快自然音色亲切、欢快、自然，适合用于各种场景 zhilingfa 小玲 标准小玲的音色亲切，甜美，自然，适合用于各种场景 zhilingf 传统小玲 甜美性感音色甜美、自然、性感，适合用于各种场景 anonyf 小佚 平和沉稳音色沉稳严肃，适合用于新闻播报等 xbekef 贝壳 可爱女童童真可爱，适合讲幼儿故事 xijunma 精品小军 新闻播报适合新闻播报等场景 xijunm 传统小军 标准正式标准发音，适合新闻播报等场景 geyou 葛爷 淡定风趣模仿葛优音色 gdgm 纲叔 沉稳幽默模仿郭德纲音色 zxcm 星哥 风趣幽默模仿周星驰音色 qianranf 传统然然 天真俏皮成人女声模仿女童音色 hyanif 小妮 温柔亲切适合情感电台播报等场景 gqlanf 标准小兰 邻家女声温柔的邻家女声，适合做客服音色 gqlanfp 精品小兰 温柔甜美温柔的邻家女声，适合做客服音色 qianranfa 标准然然 天真俏皮语速1.","title":"一个免费的TTS接口"},{"content":"更换软件源 使用中国的镜像排名\nsudo pacman-mirrors -i -c China -m rank //更新镜像排名 sudo pacman -Syy //更新数据源 sudo pacman-mirrors -g //排列数据源 添加archlinuxcn源编辑命令 sudo nano /etc/pacman.conf 添加下面的内容\n[archlinuxcn] SigLevel = Optional TrustedOnly #中科大源 Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch #清华源 # Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 163源 # Server = http://mirrors.163.com/archlinux-cn/$arch 然后再更新软件数据源\nsudo pacman -Syy sudo pacman -S archlinux-keyring archlinuxcn-keyring 因为本文的软件使用yay进行安装，故需要使用命令进行安装，命令为 sudo pacman -S yay 设置yay的mirror\nyay --aururl \u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; --save 可选安装 编译包 yay -S base-devel 注：类似的包管理器还可以用 paru\nSSH管理工具 Remmina 安装 yay -S remmina 可以选装这些插件\nfreerdp remmina-plugin-teamviewer remmina-plugin-webkit remmina-plugin-rdesktop remmina-plugin-anydesk-git 终端： 深度终端 安装 yay -S deepin-terminal alacritty 安装 yay -S alacritty 终端渐变色工具lolcat yay -S lolcat\n浏览器 vivaldi 安装 yay -S vivaldi\nmicrosoft Edge yay -S microsoft-edge-stable-bin\nChrome 安装 yay -S google-chrome\n参考\n解决打开Chrome出现 输入密码以解锁您的登录密钥环 https://blog.csdn.net/kangear/article/details/20789451 bilibili视频不能播放的问题 需要安装对应浏览器的解码包。yay -S vivaldi-ffmpeg-codecs chromium-codecs-ffmpeg chromium-codecs-ffmpeg-extra opera-ffmpeg-codecs (只需安装对应浏览器的包即可，不必全部安装) 翻译软件 有道词典 安装 yay -S youdao-dict\n金山词霸 安装 yay -S powerword-bin\ngoldendict 安装 yay -S goldendict 词库\n聊天软件 微信 安装 yay -S deepin-wine-wechat (新版可能卡死，可以使用下面的命令killall WeChatBrowser.exe \u0026amp;\u0026amp; /opt/deepinwine/tools/sendkeys.sh w wechat 4)\nQQ 安装 yay -S deepin-wine-qq如果你喜欢各种破解，可以试试下载dreamcast的QQ，替换wine下的QQ。命令参考 sudo mv ./QQ ~/.deepinwine/Deepin-QQ/drive_c/\u0026quot;Program Files\u0026quot;/Tencent\ntim yay -S com.qq.tim.spark\nipmsg 安装yay -S iptux\nmattermost 安装 yay -S mattermost-desktop\nslack 安装 yay -S slack-desktop\n可自建的聊天软件 mattermost 安装 yay -S mattermost 参阅\nrocketchat-server 安装 yay -S rocketchat-server 说明：\n安装微信后可能不能启动，需要修改内容，参考 https://github.com/countstarlight/deepin-wine-wechat-arch 微信安装使用时，有透明的窗口问题 使用命令 sudo sed -i 's/env WINEPREFIX/env GTK_IM_MODULE=\u0026quot;fcitx\u0026quot; XMODIFIERS=\u0026quot;@im=fcitx\u0026quot; QT_IM_MODULE=\u0026quot;fcitx\u0026quot; WINEPREFIX/' /opt/deepinwine/apps/Deepin-WeChat/run.sh 执行即可 QQ、微信不能输入中文，在微信的安装目录/opt/deepinwine/apps/Deepin-WeChat下的run.sh前面添加 env locale=zh_CN\rexport XIM=\u0026#34;fcitx\u0026#34;\rexport XMODIFIERS=\u0026#34;@im=fcitx\u0026#34;\rexport GTK_IM_MODULE=\u0026#34;fcitx\u0026#34;\rexport QT_IM_MODULE=\u0026#34;fcitx\u0026#34; 设置构建包时压缩安装包不进行压缩\nsudo sed -i \u0026#34;s/PKGEXT=\u0026#39;.pkg.tar.xz\u0026#39;/PKGEXT=\u0026#39;.pkg.tar\u0026#39;/g\u0026#34; /etc/makepkg.conf 参考\nhttps://printempw.github.io/setting-up-manjaro-linux/\n下载上传 OneDive 安装 yay -S onedrive 或者 yay -S onedrive-abraunegg\n百度云 安装 yay -S baidunetdisk-bin 或者 安装深度的版本 yay -S deepin-baidu-pan\n坚果云 安装 yay -S nutstore 或者 坚果云实验版 yay -S nutstore-experimental DropBox 安装 yay -S dropbox\nresilio sync 安装 yay -S rslsync\n迅雷linux版本 安装 yay -S xunlei-bin\n迅雷极速版 yay -S deepin-wine-thunderspeed\nrclone 同步工具 yay -S rclone (同步onedrive配置 GUI)\naxel 安装 yay -S axel\nzssh 安装 yay -S zssh 配合lrzsz(安装命令 yay -S lrzsz)食用效果最佳。\ntrzsz 安装 yay -S trzsz motrix 安装 yay -S motrix\nMega网盘安装 yay -S megatools-git\nqbittorrent 安装 yay -S qbittorrent(增强版 yay -S qbittorrent-enhanced-git 搜索插件)\nmoose 支持边下边播的BT工具 yay -S moose 参考\ndreamcast的网盘 http://dreamcast2.ys168.com zssh介绍 http://www.v5b7.com/other/zssh.html 办公软件 看雪安全接入ksa 安装 yay -S ksa\ntailscale 安装 yay -S tailscale\n达芬奇视频剪辑 安装 yay -S davinci-resolve\nhandbrake 视频格式转换工具 yay -S handbrake-full\nzettlr markdown编辑器 安装 yay -S zettlr vnode markdown编辑器 安装 yay -S vnote\nWps 安装 yay -S wps-office ttf-wps-fonts wps-office-mui-zh-cn wps-office-mime\nlibreoffice 安装 yay -S libreoffice\nflameshot 截图工具 安装 yay -S flameshot\ngeogebra 几何绘图软件 yay -S geogebra 福昕pdf阅读器 yay -S foxitreader\nTeamviewer yay -S teamviewer如果一直显示未连接，则请退出teamviewer，执行sudo teamviewer --daemon enable 再打开试试\nXrdp yay -S xrdp xorgxrdp-git (参考文档)\n向日葵 安装 yay -S sunloginclient (需要设置开机启动服务 systemctl enable runsunloginclient 启动服务 systemctl start runsunloginclient )\ntoDesk远程工具 安装 yay -S todesk-bin (设置服务 systemctl start\\enable todeskd 才能正常运行)\nparsec 远程工具 安装 yay -S parsec-bin v2ray 安装 yay -S v2ray （安装配置工具yay -S qv2ray qv2ray 插件 yay -S qv2ray-plugin ，福利订阅 新版已经使用AppImage格式发布，下载AppImage格式即可 或者 v2rayDesktop yay -S v2ray-desktop ）\nn2n VPN软件 yay -S n2n\nproxychains-ng 安装 yay -S proxychains-ng\nevernote 开源版本 nixnote2 安装 yay -S nixnote2\njoplin 安装 yay -S joplin\nOkular （KDE上的通用文档阅读器） yay -S okular\nFoliate 简单、现代的电子书阅读器 安装 yay -S foliate\nScreen屏幕共享软件 安装 yay -S screen-desktop U盘启动制作etcher yay -S etcher-bin\nxmind-2020 安装 yay -S xmind-2020 (福利链接)\ndrawio 安装 yay -S drawio-desktop-bin 或者 yay -S drawio-desktop\n钉钉 安装 yay -S dingtalk-electron 企业微信 yay -S deepin-wine-wxwork\n飞书 yay -S feishu-bin\n剪切板工具 uniclip yay -S uniclip\nonenote yay -S p3x-onenote\nrealvnc-server yay -S realvnc-vnc-server (安装完毕后需要注册sudo vnclicense -add 3TH6P-DV5AE-BLHY6-PNENS-B3AQA,启动服务 systemctl enable vncserver-x11-serviced)\nrealvnc-viewer yay -S realvnc-vnc-viewer\nmacast-git跨平台的 DLNA 投屏接收端 yay -S macast-git(需要安装相关pip包 pip install -U urllib3 requests pip install requests[socks])\n在线流程图工具 https://excalidraw.com 参考\nproxychains-ng 使用 https://wsgzao.github.io/post/proxychains/ Linux中制作U盘启动盘的三种方法 https://ywnz.com/linuxjc/5620.html 输入法 fcitx sun输入法 安装 yay -S fcitx fcitx-im fcitx-configtool fcitx-sunpinyin fcitx-googlepinyin fcitx-cloudpinyin fcitx-libpinyin\n皮肤 安装 yay -S fcitx-skin-material\n百度输入法 安装 yay -S fcitx-baidupinyin 安装完成以后记得重启下，不然输入候选框会乱码。\n讯飞输入法 安装 yay -S iflyime or yay -S manjaro-asian-input-support-fcitx\nKDM, GDM, LightDM 等显示管理器，请使用 ~/.xprofile 警告: 上述用户不要在~/.xinitrc中加入下述脚本，否则会造成无法登陆。(但在里头加了也没挂) 如果您用 startx 或者 Slim 启动，请使用~/.xinitrc 中加入\nexport GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export @=fcitx 如果你使用的是较新版本的GNOME，使用 Wayland 显示管理器，则请在/etc/environment中加入\nGTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx @=fcitx 安装相关字体fcitx5\nyay -S wqy-bitmapfont wqy-microhei wqy-zenhei adobe-source-code-pro-fonts adobe-source-han-sans-cn-fonts ttf-monaco noto-fonts-emoji ttf-fira-code ttf-ms-fonts ttf-sarasa-gothic nerd-fonts-complete 输入法有问题，需要重置，使用命令 rm -r ~/.config/fcitx 然后注销即可。\nfcitx5 基本安装 yay -S fcitx5-im fcitx5-chinese-addons 或者 yay -S manjaro-asian-input-support-fcitx5 fcitx5 fcitx5-configtool fcitx5-chinese-addons fcitx5-qt fcitx5-gtk\n安装字典 yay -S fcitx5-pinyin-zhwiki fcitx5-pinyin-sougou\n安装皮肤：\nfcitx5-breeze：提供了与KDE默认的Breeze主题匹配的外观。 fcitx5-nord ：Nord颜色 的主题 fcitx5-material-color：提供了类似微软拼音的外观。 fcitx5-solarized：Solarized颜色 主题 fcitx5-skin-fluentdark-git：具有模糊效果和阴影的 Fluent-Design 深色主题 编辑 /etc/environment 并添加以下几行，然后重新登录\nGTK_IM_MODULE=fcitx\rQT_IM_MODULE=fcitx\rXMODIFIERS=@im=fcitx\rSDL_IM_MODULE=fcitx\rGLFW_IM_MODULE=ibus 如果使用 en_US.UTF-8 时，遇到 GTK2 无法激活 fcitx5，可专门为该 GTK2 应用程序设置输入法为 xim，如\n$ env GTK_IM_MODULE=xim \u0026lt;your_gtk2_application\u0026gt; 请勿将 GTK_IM_MODULE 全局设置为 xim，因为它也会影响 GTK3 程序。XIM 有各种问题（比如输入法重启之后再无法输入），尽可能不要使用。\n注意：\nSDL_IM_MODULE 是为了让一些使用特定版本 SDL2 库的游戏能正常使用输入法。 GLFW_IM_MODULE 是为了让 kitty 启用输入法支持。此环境变量的值只能为 ibus。 更多内容 参考 wiki\nrime 参考官网 传送门 基本库 yay -S ibus ibus-qt ibus-rime 配置文件内容\nexport GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -d -x 四叶草输入法 yay -S rime-cloverpinyin 参考 https://wiki.archlinux.org/index.php/Fcitx\n媒体软件 网易云音乐 安装 yay -S netease-cloud-music\n腾讯视频 安装 yay -S tenvideo\n全聚合影视 安装 yay -S vst-video-bin\nOBS推流工具 yay -S obs-studio\nbilibili yay -S bilibili-bin\n美化 docky 安装 yay -S docky 或者 yay -S plank (这个比较简单，推荐)\nXFCE桌面下安装plank后可能会出现屏幕下方会有一条阴影直线，十分影响视觉。解决方案是在开始菜单的设置管理器(Settings Manager)-窗口管理器微调(Window Manager Tweaks)-合成器(Compositor)中去掉dock阴影(Show shadows under dock windows)前面的勾。\n如果是KDE桌面 yay -S latte-dock\nKDE\n（KDE推荐安装部件(下载网站,最好安装ocs-url yay -S ocs-url) appication title 全局菜单 Launchpad plasma latte Spacer Event calendar (个人google三色时间配置 '\u0026lt;font color=\u0026quot;#EB4334\u0026quot;\u0026gt;'hh'\u0026lt;/font\u0026gt;':'\u0026lt;font color=\u0026quot;#35AA53\u0026quot;\u0026gt;'mm'\u0026lt;/font\u0026gt;':'\u0026lt;font color=\u0026quot;#4586F3\u0026quot;\u0026gt;'ss'\u0026lt;/font\u0026gt;' )）\nKDE whitesur主题 安装 yay -S whitesur-kde-theme-git\nXFCE whitesur主题 https://github.com/vinceliuice/WhiteSur-gtk-theme\nmcmojave-circle-icon-theme-git 图标主题 yay -S mcmojave-circle-icon-theme-git\nxfce全局菜单(参考链接1 参考链接2) yay -S libdbusmenu-glib libdbusmenu-gtk3 libdbusmenu-gtk2 vala-panel-appmenu-xfce appmenu-gtk-module appmenu-qt4 vala-panel-appmenu-registrar 启用使用下面的命令\nxfconf-query -c xsettings -p /Gtk/ShellShowsAppmenu -n -t bool -s true\rxfconf-query -c xsettings -p /Gtk/ShellShowsMenubar -n -t bool -s true conky 性能显示组件 安装 yay -S conky conky-manager\nohmyzh 安装 yay -S zsh \u0026amp;\u0026amp; sh -c \u0026quot;$(curl -fsSL https://fastgit.czyt.tech/https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 安装插件\ngit clone https://github.com/zsh-users/zsh-completions ~/.oh-my-zsh/custom/plugins/zsh-completions\rgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/plugins/zsh-syntax-highlighting\rgit clone https://github.com/zsh-users/zsh-autosuggestions.git ~/.oh-my-zsh/plugins/zsh-autosuggestions\rgit clone https://github.com/qoomon/zsh-lazyload $ZSH_CUSTOM/plugins/zsh-lazyload 配置插件 vim ~/.zshrc\nplugins=(git zsh-lazyload zsh-syntax-highlighting docker docker-compose zsh-autosuggestions zsh-completions) zsh在使用nohup执行任务的时候，可能会出现session注销后，nohup自动被终止的情况，若要保持运行，请执行setopt NO_HUP 参考Zsh文档\n另外还有一个SpaceShip的插件也不错，可以试下。参考这篇文章，下面是引用部分\npaceship ZSH I use Spaceship ZSH as my shell theme, not only does it make my prompt look nice but it also provides extensions that helps improve my developer workflow, bringing information like the current git branch, git status, npm package version and current node version into my shell prompt for increased visibility.\nI ran the script at the command line to download and install.\ngit clone https://github.com/denysdovhan/spaceship-prompt.git \u0026#34;$ZSH_CUSTOM/themes/spaceship-prompt\u0026#34; --depth=1\rln -s \u0026#34;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme\u0026#34; \u0026#34;$ZSH_CUSTOM/themes/spaceship.zsh-theme\u0026#34; I set ZSH_THEME=\u0026quot;spaceship\u0026quot; and uncommented the line in .zshrc.\nI added SPACESHIP_PROMPT_ORDER array to .zshrc above source $ZSH/oh-my-zsh.sh line.\nSPACESHIP_PROMPT_ORDER=(\rdir # Current directory section\rgit # Git section (git_branch + git_status)\rpackage # Package version\rnode # Node.js section\rdotnet # .NET section\rruby # Ruby section\rexec_time # Execution time\rline_sep # Line break\rbattery # Battery level and status\rjobs # Background jobs indicator\rexit_code # Exit code section\rchar # Prompt character\r) The SPACESHIP_PROMPT_ORDER array enables you to define which sections are enabled or disabled in the prompt, this is optional but can improve the performance of the prompt. The less sections are loaded the faster the shell will load, so I enable the sections that are of use to me.\nHUP \u0026hellip; In zsh, if you have a background job running when the shell exits, the shell will assume you want that to be killed; in this case it is sent a particular signal called SIGHUP\u0026hellip; If you often start jobs that should go on even when the shell has exited, then you can set the option NO_HUP, and background jobs will be left alone.\nstarship 安装 yay -S starship (如是安装的zsh，安装完成后在~/.zshrc 加入eval \u0026quot;$(starship init zsh)\u0026quot;即可,配置文档),个人配置文件(通过mkdir -p ~/.config \u0026amp;\u0026amp; touch ~/.config/starship.toml创建)\n# Get editor completions based on the config schema \u0026#34;$schema\u0026#34; = \u0026#39;https://starship.rs/config-schema.json\u0026#39; # Inserts a blank line between shell prompts add_newline = true continuation_prompt = \u0026#34;▶▶\u0026#34; [username] style_user = \u0026#34;white bold\u0026#34; style_root = \u0026#34;red bold\u0026#34; format = \u0026#34;user: [$user]($style) \u0026#34; disabled = false show_always = true # Replace the \u0026#34;❯\u0026#34; symbol in the prompt with \u0026#34;➜\u0026#34; [character] # The name of the module we are configuring is \u0026#34;character\u0026#34; success_symbol = \u0026#34;[➜](bold green)\u0026#34; # The \u0026#34;success_symbol\u0026#34; segment is being set to \u0026#34;➜\u0026#34; with the color \u0026#34;bold green\u0026#34; [golang] format = \u0026#34;via [🏎💨 $version](bold cyan) \u0026#34; [git_status] conflicted = \u0026#34;🏳\u0026#34; ahead = \u0026#34;🏎💨\u0026#34; behind = \u0026#34;😰\u0026#34; diverged = \u0026#34;😵\u0026#34; up_to_date = \u0026#34;✓\u0026#34; untracked = \u0026#34;🤷\u0026#34; stashed = \u0026#34;📦\u0026#34; modified = \u0026#34;📝\u0026#34; staged = \u0026#39;[++\\($count\\)](green)\u0026#39; renamed = \u0026#34;👅\u0026#34; deleted = \u0026#34;🗑\u0026#34; [sudo] style = \u0026#34;bold green\u0026#34; symbol = \u0026#34;👩‍💻 \u0026#34; disabled = false # Disable the package module, hiding it from the prompt completely [package] disabled = true fish yay -S fish 安装oh-my-fish\ncurl -L https://get.oh-my.fish | fish 推荐插件 wttr天气插件\nomf install wttr fisher\ncurl https://git.io/fisher --create-dirs -sLo ~/.config/fish/functions/fisher.fish 参考知乎这篇文章\nnushell 安装 yay -S nushell\nWarp Terminal （有Linux版本的计划，暂未发布）\n自定义主题 需要事先安装软件 yay -S gnome-tweaks chrome-gnome-shell\n手动安装 Gnome 解压主题到 /usr/share/themes解压图标到 /usr/share/icons然后在gnome-tweaks启用即可。 参考\nhttps://zhuanlan.zhihu.com/p/71588449 https://blog.triplez.cn/manjaro-quick-start https://zhuanlan.zhihu.com/p/37852274 KDE /usr/share/plasma/desktoptheme 这是存放plasma主题 /usr//share/plasma/look-and-feel/ 存放全局主题 /usr/share/plasma/plasmoids/ 存放插件\n编程语言 go 安装 yay -S go\nrust 安装 yay -S rustup\nflutter 安装 yay -S flutter\n.net core 安装 yay -S dotnet-sdk-bin\n开发工具 github520 sed -i \u0026quot;/# GitHub520 Host Start/Q\u0026quot; /etc/hosts \u0026amp;\u0026amp; curl https://raw.hellogithub.com/hosts \u0026gt;\u0026gt; /etc/hosts (刷新缓存 systemctl restart nscd)\nlapce yay -S lapce\nlazygit yay -S lazygit\n代码生成图片silicon yay -S --needed pkgconf freetype2 fontconfig libxcb xclip silicon redis管理工具 yay -S redis-desktop-manager\ngithub-cli 安装 yay -S github-cli-bin\nminicom串口工具 安装 yay -S minicom (设置参数 sudo minicom -s )\n串口助手 安装 yay -S serialtool\nserial-studio 串行数据可视化工具 安装 yay -S serial-studio-git\nnodejs 安装 yay -S nodejs npm （安装cnpm npm install -g cnpm --registry=https://registry.npm.taobao.org ）\n跨平台编译工具链 安装 yay -S arm-linux-gnueabihf-g++ arm-linux-gnueabihf-gcc\nc/c++开发 安装 yay -S make cmake gdb gcc\ngoland 安装 yay -S goland goland-jre\nuinityHub 安装 yay -S unityhub\ncommitizen-go 安装 yay -S commitizen-go 相似的程序gitcz\ndatagrip 安装 yay -S datagrip datagrip-jre\nAndroid Studio 安装 yay -S android-studio (安卓SDK yay -S android-sdk)\nclion 安装 yay -S clion clion-jre\npycharm 安装 yay -S pycharm pycharm-jre\nrider安装 yay -S rider\nwebstorm 安装 yay -S webstorm webstorm-jre\nvmware 安装 yay -S vmware-workstation\npostman 安装 yay -S postman 汉化文件（jetbrains新版自带的resful 测试工具，可以不用安装）\napifox 安装 yay -S apifox\nTypora markdown编辑器 安装 yay -S typora\ndnspy 安装 yay -S dnspy (需要使用blackarch源)\ntmux 终端工具 安装 yay -S tmux\npre-commit 安装 yay -S python-pre-commit (管理和维护 pre-commit hooks的工具. 官网 )\nbyobu 终端工具 安装 yay -S byobu\nAPI文档工具 zeal 安装 yay -S zeal\nwindterm 安装 yay -S windterm-bin bcompare 安装 yay -S bcompare tldr 简化版文档工具 yay -S tldr （rust版本 yay -S tealdeer ）\nvscode 安装 yay -S visual-studio-code-bin\n终端录屏幕asciinema 安装 yay -S asciinema\n证书生成工具 mkcert 安装 yay -S mkcert\nnetcat yay -S --noconfirm gnu-netcat 或者 yay -S --noconfirm openbsd-netcat 微信开发者工具 yay -S wechat-devtool Platform-Tools for Google Android SDK (adb and fastboot) 安装 yay -S android-sdk-platform-tools\n编译链工具xmake 安装 yay -S xmake\ngoreleaser 安装 yay -S goreleaser-bin\npercona-toolkit (mysql辅助分析工具) yay -S percona-toolkit\n注：\njetbrains系列软件，自带更新功能，但是我们一般使用非root用户进行登录，这时需要将安装目录授权给当前登录用户即可。以goland为例，只需要执行 chown -R $(whoami) /opt/goland 即可进行自动升级。\nstrace yay -S strace\ndtrace yay -S dtrace-utils (使用教程)\ncloudflare Argo tunnel yay -S cloudflared （使用教程）\nnmon yay -S nmon\nnload yay -S nload\ntcpflow yay -S tcpflow\npyroscope性能监测工具 yay -S pyroscope-bin (使用教程 官方教程)\ncrontab yay -S cronie\ncharles抓包工具 yay -S charles (注册码生成 汉化)\n参考\nvmware安装后报错的问题 https://blog.csdn.net/weixin_43968923/article/details/100184356\n科学技术大学blackarch源使用说明 https://lug.ustc.edu.cn/wiki/mirrors/help/blackarch\njetbrains系列软件markdown插件无预览标签 yay -S java-openjfx-bin ，参考链接\n安装charless证书。导出根证书保存为pem格式。转换为crt格式\nopenssl x509 -in charles.pem -inform PEM -out ca.crt\n信任证书sudo trust anchor ca.crt,done\n服务器组件 数据库 redis yay -S redis\npercona-Server yay -S percona-server\npostresql yay -S postgresql\nmongoDB yay -S mongodb 或者 yay -S mongodb-bin\npercona-mongoDB yay -S percona-server-mongodb-bin (mongosh yay -S mongosh-bin)\nMariadb yay -S mariadb\ntiup (可以快速启动tidb的playground) curl --proto '=https' --tlsv1.2 -sSf https://tiup-mirrors.pingcap.com/install.sh | sh\nclickhouse yay -S clickhouse (官方文档)\n其他 screenfetch (终端打印出你的系统信息) 安装 yay -S screenfetch\nneofetch yay -S neofetch\neasystroke 鼠标手势 yay -S easystroke\ncopyQ (类似ditto) 安装 yay -S copyq\nifconfig、netstat 安装 yay -S net-tools\n文件搜索albert（类似mac上的Spotlight） 安装 yay -S albert\nStow配置管理软件 安装 yay -S stow\nsnap 安装 yay -S --noconfirm --needed snapd\nfiglet 字符串logo生成工具 yay -S figlet\n软件包降级工具 downgrade yay -S downgrade\nthefuck输错命令更正工具 yay -S thefuck\nappimagelauncher 安装 yay -S appimagelauncher\n终端文件管理器ranger 安装 yay -S ranger\n硬盘自动休眠 hd-idle 安装 yay -S hd-idle （或者 hdparam ）\n宽带连接 rp-pppoe 安装 yay -S rp-pppoe （参考官方wiki）\n磁盘清理\nsudo pacman -Scc journalctl --disk-usage sudo journalctl --vacuum-size=50M sudo rm /var/lib/systemd/coredump/* 参考\n使用 Stow 管理多台机器配置https://blog.csdn.net/F8qG7f9YD02Pe/article/details/104046845 https://zhuanlan.zhihu.com/p/106593833?utm_source=wechat_session\u0026amp;utm_medium=social\u0026amp;utm_oi=33332939194368 在Arch Linux/Manjaro上安装Snap https://ywnz.com/linuxjc/4635.html 修改主目录为英文 原文 $ sudo pacman -S xdg-user-dirs-gtk $ export LANG=en_US $ xdg-user-dirs-gtk-update # 然后会有个窗口提示语言更改，更新名称即可 $ export LANG=zh_CN.UTF-8 $ sudo pacman -Rs xdg-user-dirs-gtk 品牌笔记本支持 thinkpad thinkfan 安装yay -S thinkfan\n获取温度传感器 find /sys/devices -type f -name \u0026quot;temp*_input\u0026quot;,Thinkpad T430 显示如下：\nsys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp6_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp3_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp7_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp4_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp8_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp1_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp5_input /sys/devices/platform/thinkpad_hwmon/hwmon/hwmon3/temp2_input /sys/devices/platform/coretemp.0/hwmon/hwmon4/temp3_input /sys/devices/platform/coretemp.0/hwmon/hwmon4/temp4_input /sys/devices/platform/coretemp.0/hwmon/hwmon4/temp1_input /sys/devices/platform/coretemp.0/hwmon/hwmon4/temp5_input /sys/devices/platform/coretemp.0/hwmon/hwmon4/temp2_input /sys/devices/virtual/thermal/thermal_zone0/hwmon1/temp1_input\nthinkpad 充电阀值软件 yay -S tlp tp_smapi acpi_call threshy threshy-gui （ 需要 systemctl enable tlp）\n参考\nhttps://wiki.archlinux.org/index.php/Laptop/Lenovo TLP https://wiki.archlinux.org/index.php/TLP_(简体中文) thinkfan 配置及启动参考 https://wiki.archlinux.org/index.php/Thinkpad_Fan_Control https://www.cnblogs.com/henryau/archive/2012/03/03/ubuntu_thinkfan.html GDM https://wiki.archlinux.org/index.php/GDM 强制登陆界面在主显示器上显示 https://askubuntu.com/questions/11738/force-gdm-login-screen-to-the-primary-monitor 指纹识别 https://wiki.archlinux.org/index.php/Fprint 网卡 8811cu yay -S rtl8821cu-dkms-git 参考链接\n系统参数调优 TRIM 如果你的manjaro根目录安装在固态硬盘上，那么建议你输入以下命令，TRIM会帮助清理SSD中的块，从而延长SSD的使用寿命：\nsudo systemctl enable fstrim.timer sudo systemctl start fstrim.timer SWAP设置 系统开机以后内存占用1.7g左右，通常有8-16g内存的电脑可以将swap使用率调低，这样可以提高电脑的性能。\n查看swap使用率，一般是60，意思是60%的概率将内存整理到swap：cat /proc/sys/vm/swappiness\n修改swap使用策略为10%，即10%的概率将内存整理到swap：sudo sysctl -w vm.swappiness=10\n修改配置文件：sudo xed /etc/sysctl.d/99-swappiness.conf 在文件末尾加上下面这行内容： vm.swappiness=10\n重启后可查看swappiness的值，是10即可：cat /proc/sys/vm/swappiness\n其他关于swap调整大小等等操作请参考“ArchWiki关于Swap”\nSystemd journal size limit 参考 https://wiki.archlinux.org/index.php/systemd#Journal_size_limit\n修改/etc/systemd/journald.conf 中的SystemMaxUse参数\nSystemMaxUse=50M 其他 https://averagelinuxuser.com/10-things-to-do-after-installing-manjaro/ 字体渲染 http://www.badwolfbay.cn/2020/03/17/manjaro-setting/ 常见问题 swappinessinvalid or corrupted package (PGP signature) sudo rm -R /etc/pacman.d/gnupg/ sudo pacman-key --init sudo pacman-key --populate archliswappinessnux sudo pacman-key --populate archlinuxcn 刷新dns参考\nsudo resolvectl flush-caches 参考连接 swappinessarchlinux 简明指南 How to Flush DNS Cache on Linux Manjaro 字体调优 ","permalink":"https://czyt.tech/post/arch-awesome-software/","summary":"更换软件源 使用中国的镜像排名\nsudo pacman-mirrors -i -c China -m rank //更新镜像排名 sudo pacman -Syy //更新数据源 sudo pacman-mirrors -g //排列数据源 添加archlinuxcn源编辑命令 sudo nano /etc/pacman.conf 添加下面的内容\n[archlinuxcn] SigLevel = Optional TrustedOnly #中科大源 Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch #清华源 # Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 163源 # Server = http://mirrors.163.com/archlinux-cn/$arch 然后再更新软件数据源\nsudo pacman -Syy sudo pacman -S archlinux-keyring archlinuxcn-keyring 因为本文的软件使用yay进行安装，故需要使用命令进行安装，命令为 sudo pacman -S yay 设置yay的mirror\nyay --aururl \u0026#34;https://aur.tuna.tsinghua.edu.cn\u0026#34; --save 可选安装 编译包 yay -S base-devel 注：类似的包管理器还可以用 paru\nSSH管理工具 Remmina 安装 yay -S remmina 可以选装这些插件","title":"Arch Linux 常用软件"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/favicon.ico\u0026#34;, favicon) http.HandleFunc(\u0026#34;/\u0026#34;, hello) fmt.Printf(\u0026#34;listening on http://localhost:8000/\\n\u0026#34;) http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil) } func favicon(w http.ResponseWriter, r *http.Request) { fmt.Printf(\u0026#34;%s\\n\u0026#34;, r.RequestURI) w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/x-icon\u0026#34;) w.Header().Set(\u0026#34;Cache-Control\u0026#34;, \u0026#34;public, max-age=7776000\u0026#34;) fmt.Fprintln(w, \u0026#34;data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=\\n\u0026#34;) } func hello(w http.ResponseWriter, r *http.Request) { fmt.Printf(\u0026#34;%s\\n\u0026#34;, r.RequestURI) fmt.Fprintln(w, \u0026#34;Hello, World!\u0026#34;) } ","permalink":"https://czyt.tech/post/golang-web-server-add-base64-favicon/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { http.HandleFunc(\u0026#34;/favicon.ico\u0026#34;, favicon) http.HandleFunc(\u0026#34;/\u0026#34;, hello) fmt.Printf(\u0026#34;listening on http://localhost:8000/\\n\u0026#34;) http.ListenAndServe(\u0026#34;localhost:8000\u0026#34;, nil) } func favicon(w http.ResponseWriter, r *http.Request) { fmt.Printf(\u0026#34;%s\\n\u0026#34;, r.RequestURI) w.Header().Set(\u0026#34;Content-Type\u0026#34;, \u0026#34;image/x-icon\u0026#34;) w.Header().Set(\u0026#34;Cache-Control\u0026#34;, \u0026#34;public, max-age=7776000\u0026#34;) fmt.Fprintln(w, \u0026#34;data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=\\n\u0026#34;) } func hello(w http.ResponseWriter, r *http.Request) { fmt.Printf(\u0026#34;%s\\n\u0026#34;, r.RequestURI) fmt.Fprintln(w, \u0026#34;Hello, World!\u0026#34;) } ","title":"golang webserver with genergic base64 /favicon.ico"},{"content":" reddit链接 On Linux it might be possible to use the memfd_create system call, but that\u0026rsquo;s not portable to other operating systems.\nneed go 1.16 +\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) //go:embed binary var embeddedBinary []byte func main() { fd, err := unix.MemfdCreate(\u0026#34;embedded_binary\u0026#34;, 0) if err != nil { log.Fatal(err) } path := \u0026#34;/proc/\u0026#34; + strconv.Itoa(os.Getpid()) + \u0026#34;/fd/\u0026#34; + strconv.Itoa(int(fd)) err = os.WriteFile(path, embeddedBinary, 0755) if err != nil { log.Fatal(err) } cmd := exec.Command(path) cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr err = cmd.Run() if err != nil { log.Fatal(err) } } You should be able to replace that os.WriteFile with f := os.NewFile(fd, \u0026ldquo;memfd\u0026rdquo;); _, err := f.Write(embeddedBinary) for a simpler end result.\nYou should be able to replace the /proc path with execveat(2) and AT_EMPTY_PATH\n一个可用的简短函数 来源链接\nconst ( mfdCloexec = 0x0001 memfdCreate = 319 ) func runFromMemory(displayName string, binaryBytes []byte) { fdName := \u0026#34;\u0026#34; // *string cannot be initialized fd, _, _ := syscall.Syscall(memfdCreate, uintptr(unsafe.Pointer(\u0026amp;fdName)), uintptr(mfdCloexec), 0) _, _ = syscall.Write(int(fd), binaryBytes) fdPath := fmt.Sprintf(\u0026#34;/proc/self/fd/%d\u0026#34;, fd) _ = syscall.Exec(fdPath, []string{displayName}, nil) } ","permalink":"https://czyt.tech/post/golang-embed-executable-file/","summary":"reddit链接 On Linux it might be possible to use the memfd_create system call, but that\u0026rsquo;s not portable to other operating systems.\nneed go 1.16 +\npackage main import ( _ \u0026#34;embed\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;golang.org/x/sys/unix\u0026#34; ) //go:embed binary var embeddedBinary []byte func main() { fd, err := unix.MemfdCreate(\u0026#34;embedded_binary\u0026#34;, 0) if err != nil { log.Fatal(err) } path := \u0026#34;/proc/\u0026#34; + strconv.Itoa(os.Getpid()) + \u0026#34;/fd/\u0026#34; + strconv.Itoa(int(fd)) err = os.WriteFile(path, embeddedBinary, 0755) if err !","title":"Golang嵌入可执行程序"},{"content":"Mysql Postgresql ","permalink":"https://czyt.tech/post/go-connect-db-via-ssh/","summary":"Mysql Postgresql ","title":"Golang通过ssh连接数据库"},{"content":"准备工作 golang正则需要引入包中的regexp包。\nimport ( \u0026#34;regexp\u0026#34; ) 如果需要复用正则表达式对象来提高性能，可以通过Compile() 或者 MustCompile()创建一个编译好的正则表达式对象。\n支持的表达式 单个匹配:\n. any character, possibly including newline (flag s=true)\r[xyz] character class\r[^xyz] negated character class\r\\d Perl character class\r\\D negated Perl character class\r[[:alpha:]] ASCII character class\r[[:^alpha:]] negated ASCII character class\r\\pN Unicode character class (one-letter name)\r\\p{Greek} Unicode character class\r\\PN negated Unicode character class (one-letter name)\r\\P{Greek} negated Unicode character class 组合匹配:\nxy x followed by y\rx|y x or y (prefer x) 多次匹配:\nx* zero or more x, prefer more\rx+ one or more x, prefer more\rx? zero or one x, prefer one\rx{n,m} n or n+1 or ... or m x, prefer more\rx{n,} n or more x, prefer more\rx{n} exactly n x\rx*? zero or more x, prefer fewer\rx+? one or more x, prefer fewer\rx?? zero or one x, prefer zero\rx{n,m}? n or n+1 or ... or m x, prefer fewer\rx{n,}? n or more x, prefer fewer\rx{n}? exactly n x 分组：\n(re) numbered capturing group (submatch)\r(?P\u0026lt;name\u0026gt;re) named \u0026amp; numbered capturing group (submatch)\r(?:re) non-capturing group\r(?flags) set flags within current group; non-capturing\r(?flags:re) set flags during re; non-capturing\rFlag syntax is xyz (set) or -xyz (clear) or xy-z (set xy, clear z). The flags are:\ri case-insensitive (default false)\rm multi-line mode: ^ and $ match begin/end line in addition to begin/end text (default false)\rs let . match \\n (default false)\rU ungreedy: swap meaning of x* and x*?, x+ and x+?, etc (default false) 锚位符，用来匹配位置，不消耗任何字符:\n^ at beginning of text or line (flag m=true)\r$ at end of text (like \\z not \\Z) or line (flag m=true)\r\\A at beginning of text\r\\b at ASCII word boundary (\\w on one side and \\W, \\A, or \\z on the other)\r\\B not at ASCII word boundary\r\\z at end of text 脱字符:\n\\a bell (== \\007)\r\\f form feed (== \\014)\r\\t horizontal tab (== \\011)\r\\n newline (== \\012)\r\\r carriage return (== \\015)\r\\v vertical tab character (== \\013)\r\\* literal *, for any punctuation character *\r\\123 octal character code (up to three digits)\r\\x7F hex character code (exactly two digits)\r\\x{10FFFF} hex character code\r\\Q...\\E literal text ... even if ... has punctuation 字符集类:\nx single character\rA-Z character range (inclusive)\r\\d Perl character class\r[:foo:] ASCII character class foo\r\\p{Foo} Unicode character class Foo\r\\pF Unicode character class F (one-letter name) 命名字符集类内嵌:\n[\\d] digits (== \\d)\r[^\\d] not digits (== \\D)\r[\\D] not digits (== \\D)\r[^\\D] not not digits (== \\d)\r[[:name:]] named ASCII class inside character class (== [:name:])\r[^[:name:]] named ASCII class inside negated character class (== [:^name:])\r[\\p{Name}] named Unicode property inside character class (== \\p{Name})\r[^\\p{Name}] named Unicode property inside negated character class (== \\P{Name}) 常用字符组缩写:\n\\d digits (== [0-9])\r\\D not digits (== [^0-9])\r\\s whitespace (== [\\t\\n\\f\\r ])\r\\S not whitespace (== [^\\t\\n\\f\\r ])\r\\w word characters (== [0-9A-Za-z_])\r\\W not word characters (== [^0-9A-Za-z_]) POSIX字符组:\n[[:alnum:]] alphanumeric (== [0-9A-Za-z])\r[[:alpha:]] alphabetic (== [A-Za-z])\r[[:ascii:]] ASCII (== [\\x00-\\x7F])\r[[:blank:]] blank (== [\\t ])\r[[:cntrl:]] control (== [\\x00-\\x1F\\x7F])\r[[:digit:]] digits (== [0-9])\r[[:graph:]] graphical (== [!-~] == [A-Za-z0-9!\u0026#34;#$%\u0026amp;\u0026#39;()*+,\\-./:;\u0026lt;=\u0026gt;?@[\\\\\\]^_`{|}~])\r[[:lower:]] lower case (== [a-z])\r[[:print:]] printable (== [ -~] == [ [:graph:]])\r[[:punct:]] punctuation (== [!-/:-@[-`{-~])\r[[:space:]] whitespace (== [\\t\\n\\v\\f\\r ])\r[[:upper:]] upper case (== [A-Z])\r[[:word:]] word characters (== [0-9A-Za-z_])\r[[:xdigit:]] hex digit (== [0-9A-Fa-f]) golang不支持零宽断言和反向引用等功能（具体列表参考 官方wiki）。如果需要这些功能，可以使用第三方库 https://github.com/dlclark/regexp2 的相关实现。\n参考 Go正则表达式示例 regexp 101 (正则测试网站，支持生成go语言代码) ","permalink":"https://czyt.tech/post/golang-regxp-notes/","summary":"准备工作 golang正则需要引入包中的regexp包。\nimport ( \u0026#34;regexp\u0026#34; ) 如果需要复用正则表达式对象来提高性能，可以通过Compile() 或者 MustCompile()创建一个编译好的正则表达式对象。\n支持的表达式 单个匹配:\n. any character, possibly including newline (flag s=true)\r[xyz] character class\r[^xyz] negated character class\r\\d Perl character class\r\\D negated Perl character class\r[[:alpha:]] ASCII character class\r[[:^alpha:]] negated ASCII character class\r\\pN Unicode character class (one-letter name)\r\\p{Greek} Unicode character class\r\\PN negated Unicode character class (one-letter name)\r\\P{Greek} negated Unicode character class 组合匹配:\nxy x followed by y\rx|y x or y (prefer x) 多次匹配:","title":"golang正则表达式小札"},{"content":"func UploadFromUrl(uploadUrl string, resUrl string,postFileName string, submitField string) error { method := \u0026#34;POST\u0026#34; payload := \u0026amp;bytes.Buffer{} writer := multipart.NewWriter(payload) if res, err := http.Get(resUrl); err != nil { return err } else { defer func() { if res != nil { _ = res.Body.Close() } }() part, _ := writer.CreateFormFile(submitField, postFileName) if _, copyErr := io.Copy(part, res.Body); copyErr != nil { return copyErr } if err := writer.Close(); err != nil { return err } } client := \u0026amp;http.Client{} req, err := http.NewRequest(method, uploadUrl, payload) if err != nil { return err } req.Header.Set(\u0026#34;Content-Type\u0026#34;, writer.FormDataContentType()) resp, err := client.Do(req) if err != nil { return err } defer func() { _ = resp.Body.Close() client = nil writer = nil }() return nil } ","permalink":"https://czyt.tech/post/golang-upload-network-file-with-no-tmp-file/","summary":"func UploadFromUrl(uploadUrl string, resUrl string,postFileName string, submitField string) error { method := \u0026#34;POST\u0026#34; payload := \u0026amp;bytes.Buffer{} writer := multipart.NewWriter(payload) if res, err := http.Get(resUrl); err != nil { return err } else { defer func() { if res != nil { _ = res.Body.Close() } }() part, _ := writer.CreateFormFile(submitField, postFileName) if _, copyErr := io.Copy(part, res.Body); copyErr != nil { return copyErr } if err := writer.Close(); err != nil { return err } } client := \u0026amp;http.","title":"golang不创建临时文件上传网络文件"},{"content":" _, err := conn.Read(make([]byte, 0)) if err!=io.EOF{ // this connection is invalid logger.W(\u0026#34;conn closed....\u0026#34;,err) }else{ byt, _:= ioutil.ReadAll(conn); } 注意：net: don\u0026rsquo;t return io.EOF from zero byte reads issue\n参考\nhttps://stackoverflow.com/questions/12741386/how-to-know-tcp-connection-is-closed-in-net-package\n","permalink":"https://czyt.tech/post/golang-check-netconnection/","summary":"_, err := conn.Read(make([]byte, 0)) if err!=io.EOF{ // this connection is invalid logger.W(\u0026#34;conn closed....\u0026#34;,err) }else{ byt, _:= ioutil.ReadAll(conn); } 注意：net: don\u0026rsquo;t return io.EOF from zero byte reads issue\n参考\nhttps://stackoverflow.com/questions/12741386/how-to-know-tcp-connection-is-closed-in-net-package","title":"golang检测网络连接是否关闭"},{"content":"示例 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/text/language\u0026#34; \u0026#34;golang.org/x/text/message\u0026#34; \u0026#34;golang.org/x/text/message/catalog\u0026#34; ) func main() { builder := catalog.NewBuilder() chTag:=language.Make(\u0026#34;zh_Hans\u0026#34;) engTag:=language.Make(\u0026#34;en\u0026#34;) builder.SetString(chTag,\u0026#34;hello\u0026#34;,\u0026#34;您好\u0026#34;) builder.SetString(engTag,\u0026#34;hello\u0026#34;,\u0026#34;Hello\u0026#34;) fmt.Println(builder.Languages()) option := message.Catalog(builder) p := message.NewPrinter(chTag,option) p.Printf(\u0026#34;hello\u0026#34;) p2 := message.NewPrinter(engTag,option) p2.Printf(\u0026#34;hello\u0026#34;) } 参考 https://zyfdegh.github.io/post/201805-translation-go-i18n https://www.alexedwards.net/blog/i18n-managing-translations https://phrase.com/blog/posts/internationalisation-in-go-with-go-i18n/ https://lokalise.com/blog/go-internationalization-using-go-i18n/ https://go.googlesource.com/proposal/+/master/design/12750-localization.md ","permalink":"https://czyt.tech/post/golang-impl-i18n-with-standard-lib/","summary":"示例 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/text/language\u0026#34; \u0026#34;golang.org/x/text/message\u0026#34; \u0026#34;golang.org/x/text/message/catalog\u0026#34; ) func main() { builder := catalog.NewBuilder() chTag:=language.Make(\u0026#34;zh_Hans\u0026#34;) engTag:=language.Make(\u0026#34;en\u0026#34;) builder.SetString(chTag,\u0026#34;hello\u0026#34;,\u0026#34;您好\u0026#34;) builder.SetString(engTag,\u0026#34;hello\u0026#34;,\u0026#34;Hello\u0026#34;) fmt.Println(builder.Languages()) option := message.Catalog(builder) p := message.NewPrinter(chTag,option) p.Printf(\u0026#34;hello\u0026#34;) p2 := message.NewPrinter(engTag,option) p2.Printf(\u0026#34;hello\u0026#34;) } 参考 https://zyfdegh.github.io/post/201805-translation-go-i18n https://www.alexedwards.net/blog/i18n-managing-translations https://phrase.com/blog/posts/internationalisation-in-go-with-go-i18n/ https://lokalise.com/blog/go-internationalization-using-go-i18n/ https://go.googlesource.com/proposal/+/master/design/12750-localization.md ","title":"golang使用官方库实现i18n"},{"content":"About Me I\u0026rsquo;m a Programmer in chengdu!\nyuque ys168 Current Using programming language\ngolang C# (WPF) welcome to discuss with me ! mail: x-gopher@qq.com or go-x@qq.com\nGithub Experience .Net Devlelop from year 2016 util now. Golang Develop from year 2018 until now. AutoIt usage from year 2011 until 2016. Tools on Cloudflare github Speedup libgen mirror ","permalink":"https://czyt.tech/about/","summary":"About Me I\u0026rsquo;m a Programmer in chengdu!\nyuque ys168 Current Using programming language\ngolang C# (WPF) welcome to discuss with me ! mail: x-gopher@qq.com or go-x@qq.com\nGithub Experience .Net Devlelop from year 2016 util now. Golang Develop from year 2018 until now. AutoIt usage from year 2011 until 2016. Tools on Cloudflare github Speedup libgen mirror ","title":"关于我"}]