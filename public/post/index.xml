<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 虫子樱桃</title>
    <link>https://czyt.tech/post/</link>
    <description>Recent content in Posts on 虫子樱桃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 01 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://czyt.tech/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C#扫码枪输入Hook</title>
      <link>https://czyt.tech/post/scanner-input-hook-via-csharp/</link>
      <pubDate>Tue, 01 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/scanner-input-hook-via-csharp/</guid>
      <description>摘自网络，测试可用
public class ScanerHook { public delegate void ScanerDelegate(ScanerCodes codes); public event ScanerDelegate ScanerEvent; //private const int WM_KEYDOWN = 0x100;//KEYDOWN //private const int WM_KEYUP = 0x101;//KEYUP //private const int WM_SYSKEYDOWN = 0x104;//SYSKEYDOWN //private const int WM_SYSKEYUP = 0x105;//SYSKEYUP //private static int HookProc(int nCode, Int32 wParam, IntPtr lParam); private int hKeyboardHook = 0;//声明键盘钩子处理的初始值 private ScanerCodes codes = new ScanerCodes();//13为键盘钩子 //定义成静态，这样不会抛出回收异常 private static HookProc hookproc; delegate int HookProc(int nCode, Int32 wParam, IntPtr lParam); [DllImport(&amp;#34;user32.</description>
    </item>
    
    <item>
      <title>使用protoc-gen-star编写protoc插件</title>
      <link>https://czyt.tech/post/writing-a-protoc-plugin-using-protoc-gen-star/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/writing-a-protoc-plugin-using-protoc-gen-star/</guid>
      <description>预备知识 需要安装的软件 protoc golang go 软件包 github.com/lyft/protoc-gen-star 插件调用步骤 protoc，PB编译器，使用一组标志（记录在protoc -h下）进行配置，并将一组文件作为参数交给它。在这种情况下，I标志可以被多次指定，是它在proto文件中用于导入依赖关系的查找路径。默认情况下，官方描述符protos已经被包含在内。
myplugin_out 告诉 protoc 使用 protoc-gen-myplugin protoc-plugin。这些插件会从系统的 PATH 环境变量中自动解析，或者可以用另一个标志明确指定。官方的protoc-plugins (例如，protoc-gen-python) 已经在protoc注册了。该标志的值是特定于特定插件的，但 :&amp;hellip;/generated 后缀除外。这个后缀表示protoc将把该包生成的文件放在哪个根目录下（相对于当前工作目录）。然而，这个生成的输出目录不会传播给 protoc-gen-myplugin，所以它需要在标志的左边重复。PG* 通过一个 output_path 参数支持这一点。
protoc 解析传入的 proto 文件，确保它们在语法上是正确的，并加载任何导入的依赖项。它将这些文件和依赖关系转换成描述符 (它们本身就是 PB 消息)，并创建一个 CodeGeneratorRequest (又是一个 PB)。protoc 将这个请求序列化，然后执行每个配置的 protoc-plugin，通过 stdin 发送有效载荷。
protoc-gen-myplugin 启动，接收请求的有效载荷，并将其解密。一个基于 PG* 的 protoc-plugin 有两个阶段。首先，PG* 对从 protoc 收到的 CodeGeneratorRequest 进行解密，并为每个文件和其包含的所有实体创建一个完全连接的抽象语法树 (AST)。为这个插件指定的任何参数也会被解析，以便以后使用。
当这一步完成后，PG*就会执行任何注册的模块，把构建的AST交给它。模块可以被写成生成人工制品（例如，文件），或者只是对所提供的图进行某种形式的验证而没有任何其他副作用。模块在针对PB的操作方面提供了极大的灵活性。
一旦所有的模块都被运行，PG*会将任何自定义的工件写入文件系统，或者将生成器特定的工件序列化为CodeGeneratorResponse并将数据发送到其stdout。这整个流程看起来像这样。
foo.proto → protoc → CodeGeneratorRequest → protoc-gen-myplugin → CodeGeneratorResponse → protoc → foo.pb.go 假设插件名称为diy,则需要编译程序为protoc-gen-diy，并将程序加入系统Path变量，通过下面的命令调用插件。
protoc -I .</description>
    </item>
    
    <item>
      <title>C# dllimport 备忘录</title>
      <link>https://czyt.tech/post/csharp-dll-import-memo/</link>
      <pubDate>Sun, 09 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/csharp-dll-import-memo/</guid>
      <description>dllImport的入口点问题 通过Dependencies查询Dll对应方法的EntryPoint
然后在dllimport的attribute中显式申明EntryPoint
[DllImport(&amp;#34;demo.dll&amp;#34;, SetLastError = true,EntryPoint =&amp;#34;??0DemoManager@EcgParser@Gfeit@@AEAA@XZ&amp;#34;)] public static extern IntPtr DemoManager(); 导入类方法的问题 最好的方式还是使用C++构造wrapper，然后通过windowsApi的方式调用Pinvoke
参考链接 swig nuget
swig
C++/C# interoperability
Working with C++ Interface Classes from C#
Call function in unmanaged DLL from C# and pass custom data types [Marshal]
SWIG and C#
Example for SWIG to wrap C++ library in .Net 6</description>
    </item>
    
    <item>
      <title>tailscale的泛型SingleFlight</title>
      <link>https://czyt.tech/post/generic-singleflight-by-tailscale/</link>
      <pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/generic-singleflight-by-tailscale/</guid>
      <description>源地址 tailscale仓库
完整代码如下
// Copyright (c) 2022 Tailscale Inc &amp;amp; AUTHORS All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package singleflight provides a duplicate function call suppression // mechanism.</description>
    </item>
    
    <item>
      <title>Rasp3b 安装Postgresql</title>
      <link>https://czyt.tech/post/install-postgresql-on-rasp3b/</link>
      <pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/install-postgresql-on-rasp3b/</guid>
      <description>安装 系统信息
使用命令安装 yay -S postgresql
初始化及配置 启用数据库服务 sudo systemctl enable --now postgresql
开启数据库服务 sudo systemctl start postgresql
初始化数据 su - postgres -c &amp;quot;initdb --locale en_US.UTF-8 -D &#39;/var/lib/postgres/data&#39;&amp;quot;
查询配置文件路径
su - postgres [postgres@homeserver ~]$ ls data [postgres@homeserver ~]$ psql psql (14.5) 输入 &amp;#34;help&amp;#34; 来获取帮助信息. postgres=# SHOW config_file; config_file ---------------------------------------- /var/lib/postgres/data/postgresql.conf (1 行记录) 修改监听 修改配置/var/lib/postgres/data/postgresql.conf 文件中的listen_addresses = &#39;*&#39;监听所有地址，重启服务sudo systemctl restart postgresql生效。
允许远程访问 修改配置文件同级目录下的pg_hba.conf,添加一行
# TYPE DATABASE USER CIDR-ADDRESS METHODhost all all 0.</description>
    </item>
    
    <item>
      <title>.NET6 从JSON获取配置</title>
      <link>https://czyt.tech/post/dotnet6-load-config-from-json/</link>
      <pubDate>Tue, 06 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/dotnet6-load-config-from-json/</guid>
      <description>环境准备 nuget包 Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Binder Microsoft.Extensions.Configuration.Json (当需要从Json文件添加记录时，安装此nuget包) Microsoft.Extensions.Configuration.EnvironmentVariables (当需要从环境变量添加记录时，安装此nuget包) C#开发环境 visual studio 2019 + visual Code 示例代码 // See https://aka.ms/new-console-template for more information using Microsoft.Extensions.Configuration; using Microsoft.Extensions.Configuration.Json; Console.WriteLine(&amp;#34;Hello, World!&amp;#34;); ConfigurationBuilder configurationBuilder = new ConfigurationBuilder(); IConfiguration c = configurationBuilder.AddJsonFile(&amp;#34;appsettings.json&amp;#34;).AddEnvironmentVariables().Build(); var k = c.GetRequiredSection(&amp;#34;Settings&amp;#34;).Get&amp;lt;Settings&amp;gt;().KeyOne; var n = 1; public class NestedSettings { public string Message { get; set; } = null!; } public class Settings { public int KeyOne { get; set; } public bool KeyTwo { get; set; } public NestedSettings KeyThree { get; set; } = null!</description>
    </item>
    
    <item>
      <title>浅谈windows默认Shell的替换</title>
      <link>https://czyt.tech/post/a-brief-talk-about-replace-windows-default-shell-with-wpf/</link>
      <pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/a-brief-talk-about-replace-windows-default-shell-with-wpf/</guid>
      <description>Windows XP时代 Xp时代提供的是通过注册表来自定义shell
设置所有用户的shell 注册表键HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell
设置当前用户的shell注册表键 HKEY_Current_User\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell
注册表键值类型 REG_SZ
值修改为你要自定义为shell的程序的完整路径。
在windows10下使用该技巧可能会出现黑屏的现象，参考stackoverflow的回答
Simply replacing the &amp;ldquo;explorer.exe&amp;rdquo; (HKLM\SOFTWARE\Microsoft\Window NT\Winlogon\Shell) with a custom app location provided a black screen.
A much simpler way, and it works great, was to create a BATCH script to call the custom app through elevated powershell&amp;hellip;
powershell -nologo -noprofile -executionpolicy bypass -command &amp;#34;start-process -verb &amp;#39;runas&amp;#39; -filepath &amp;lt;full path of custom app executable&amp;gt;&amp;#34; By replacing &amp;ldquo;explorer.exe&amp;rdquo; with this batch script I was able to successfully create a kiosk style lockdown under Windows 10 PRO with a non-UWP app.</description>
    </item>
    
    <item>
      <title>Golang 默认的CGO参数编译导致的GLIBC错误</title>
      <link>https://czyt.tech/post/golang-default-cgo-flags-caused-glibc-missing-error/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-default-cgo-flags-caused-glibc-missing-error/</guid>
      <description>问题描述 使用go正常编译了Linux下的程序，放到服务器上报错
./app: /lib64/libc.so.6: version `GLIBC_2.34&amp;#39; not found (required by ./app) 解决 Google了下，发现相同的Issue,于是通过go env检查本机golang运行环境，发现CGO默认启用而且程序也不涉及CGO相关的东西，于是设置CGO参数为关闭。然后编译程序
CGO_ENABLED=&amp;quot;0&amp;quot; go build -v
重新上传，运行OK.</description>
    </item>
    
    <item>
      <title>在Alibaba Cloud Linux上安装MongoDB</title>
      <link>https://czyt.tech/post/install-mongodb-on-alibaba-cloud-linux/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/install-mongodb-on-alibaba-cloud-linux/</guid>
      <description>安装步骤 查询系统版本 执行命令lsb_release -a返回下面的内容
LSB Version:	:core-4.1-amd64:core-4.1-noarchDistributor ID:	AlibabaCloudDescription:	Alibaba Cloud Linux release 3 (Soaring Falcon) Release:	3Codename:	SoaringFalcon 添加yum源 创建repo文件etc/yum.repos.d/mongodb.repo并输入下面的内容，这里安装的mongodb版本为6.0,其他版本请参考官网（配置偶数版本，奇数版不适合生产使用）。
官网的配置文件如下：
[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用这个配置文件是安装不了的，需要修改$releasever为相应的版本，Alibaba Cloud Linux 3修改为8 （设置一个releasever的环境变量也许也可以，没有验证。）即可。即下面的样子
[mongodb-org-6.0] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 使用命令 yum -y install mongodb-org 安装即可。另外阿里云也提供了国内的镜像源，上面的配置文件可以修改为下面的内容，也是等效的。
[mongodb-org-6.0] name=MongoDB Repository baseurl=http://mirrors.aliyun.com/mongodb/yum/redhat/8/mongodb-org/6.0/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-6.0.asc 参考链接 如何在Alibaba Cloud Linux 3上安装MongoDB 5.0 </description>
    </item>
    
    <item>
      <title>golang http客户端使用自定义dns</title>
      <link>https://czyt.tech/post/golang-http-use-custom-dns/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-http-use-custom-dns/</guid>
      <description>摘自互联网 原文
package main import ( &amp;#34;context&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) func main() { var ( dnsResolverIP = &amp;#34;8.8.8.8:53&amp;#34; // Google DNS resolver. dnsResolverProto = &amp;#34;udp&amp;#34; // Protocol to use for the DNS resolver dnsResolverTimeoutMs = 5000 // Timeout (ms) for the DNS resolver (optional) ) dialer := &amp;amp;net.Dialer{ Resolver: &amp;amp;net.Resolver{ PreferGo: true, Dial: func(ctx context.Context, network, address string) (net.Conn, error) { d := net.Dialer{ Timeout: time.Duration(dnsResolverTimeoutMs) * time.</description>
    </item>
    
    <item>
      <title>go-kratos使用备忘</title>
      <link>https://czyt.tech/post/go-kratos-usage-memo/</link>
      <pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-kratos-usage-memo/</guid>
      <description>自定义接口返回内容 正常的响应序列化逻辑通过Response Encoder实现。
错误的序列化逻辑通过ErrorEncoder实现。
注意：自定义Encoder后，可能会遇到零值字段被忽略的情况，可以参考这个issue。具体的解决办法是
proto定义返回内容，然后将生成的类型在encoder中使用。
简单代码大致如下：
proto定义
import &amp;#34;google/protobuf/any.proto&amp;#34;; // BaseResponse is the base response message BaseResponse{ int32 code = 1 [json_name = &amp;#34;code&amp;#34;]; google.protobuf.Any data = 2 [json_name = &amp;#34;data&amp;#34;]; } go代码
func CustomResponseEncoder() http.ServerOption { return http.ResponseEncoder(func(w http.ResponseWriter, r *http.Request, i interface{}) error { reply := &amp;amp;v1.BaseResponse{ Code: 0, } if m, ok := i.(proto.Message); ok { payload, err := anypb.New(m) if err != nil { return err } reply.</description>
    </item>
    
    <item>
      <title>Protobuf golang小札</title>
      <link>https://czyt.tech/post/protobuf-golang-litle-notes/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/protobuf-golang-litle-notes/</guid>
      <description>Oneof 如果您有许多字段的消息，并且最多可以同时设置一个字段，则可以使用Oneof功能来执行此行为并保存内存。一个字段就像常规字段一样，除了单一共享内存中的所有字段，最多可以同时设置一个字段。设置Oneof的任何成员都会自动清除所有其他成员。
​	Google protobuf 文档#Oneof
示例proto 创建protoOneof.proto 的proto文件
syntax = &amp;#34;proto3&amp;#34;; package oneof_test; option go_package =&amp;#39;.;oneof&amp;#39;; message WeiboUser{ string user_id = 1; string user_nick = 2; } message DouyinUser{ string auth_token = 1; string nick_name = 2; } message User{ oneof user_source{ string weibo_url = 1; string douyin_url = 2; } oneof user_info{ WeiboUser weibo_user_info = 3; DouyinUser douyin_user_info = 4; } } 使用命令生成go代码
protoc --proto_path=. --go_out=paths=source_relative:./oneof ./protoOneof.proto 生成的protoOneof.pb.go代码如下：</description>
    </item>
    
    <item>
      <title>使用gotests生成表驱动测试</title>
      <link>https://czyt.tech/post/use-gotests-to-generate-table-driven-tests/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/use-gotests-to-generate-table-driven-tests/</guid>
      <description>使用gotests可以很方便的生成表驱动测试代码，表驱动测试的具体内容，请参考go官方的wiki。下面是具体的使用方法。
安装 使用下面命令进行安装
go install github.com/cweill/gotests/gotests@latest 如果是go1.16之前的版本，可以使用命令 go get -u github.com/cweill/gotests/...来进行安装。
使用 gotests支持的参数如下：
Usage of C:\Users\czyt\go\bin\gotests.exe:-allgenerate tests for all functions and methods-excl stringregexp. generate tests for functions and methods that don&amp;#39;t match. Takes precedence over -only, -exported, and -all-exportedgenerate tests for exported functions and methods. Takes precedence over -only and -all-i print test inputs in error messages-nosubtestsdisable generating tests using the Go 1.</description>
    </item>
    
    <item>
      <title>ETCD一键安装脚本</title>
      <link>https://czyt.tech/post/etcd-install-script/</link>
      <pubDate>Thu, 21 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/etcd-install-script/</guid>
      <description>最近要使用ETCD，脚本根据官方GitHub脚本修改而来
#!/usr/bin/bash ETCD_VER=v3.5.4 # choose either URL GOOGLE_URL=https://storage.googleapis.com/etcd GITHUB_URL=https://fastgit.czyt.tech/https://github.com/etcd-io/etcd/releases/download ARCH=linux-arm64 DOWNLOAD_URL=${GITHUB_URL} INSTALL_DIR=/opt/etcd rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz rm -rf ${INSTALL_DIR} &amp;amp;&amp;amp; mkdir -p ${INSTALL_DIR} curl -L ${DOWNLOAD_URL}/${ETCD_VER}/etcd-${ETCD_VER}-${ARCH}.tar.gz -o /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz tar xzvf /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz -C ${INSTALL_DIR} --strip-components=1 rm -f /tmp/etcd-${ETCD_VER}-${ARCH}.tar.gz ${INSTALL_DIR}/etcd --version ${INSTALL_DIR}/etcdctl version ${INSTALL_DIR}/etcdutl version 其中的ARCH请根据实际情况修改。
参考 https://etcd.io/docs/v3.5/demo/ </description>
    </item>
    
    <item>
      <title>Golang Expr不完全指南</title>
      <link>https://czyt.tech/post/golang-expr-uncompleted-reference/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-expr-uncompleted-reference/</guid>
      <description>安装 库的说明
Expr package provides an engine that can compile and evaluate expressions. An expression is a one-liner that returns a value (mostly, but not limited to, booleans). It is designed for simplicity, speed and safety.
The purpose of the package is to allow users to use expressions inside configuration for more complex logic. It is a perfect candidate for the foundation of a business rule engine.
安装
go get -u /github.</description>
    </item>
    
    <item>
      <title>Golang DSL参考</title>
      <link>https://czyt.tech/post/golang-dsl-reference/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-dsl-reference/</guid>
      <description>ANTLR 4 图书 The definitive ANTLR 4 reference (2014) 英文版下载 中文版下载 文章 使用ANTLR和Go实现DSL入门 手把手教你使用ANTLR和Go实现一门DSL语言part1 part2part3part4part5 Parsing with ANTLR 4 and Go 实例代码 bilibili gengine link go-zero link grule-rule-engine Others 图书 Writing A Compiler In Go Writing an Interpreter in Go µGo语言实现——从头开发一个迷你Go语言编译器 文章 Build your own DSL with Go &amp;amp; HCL
How to Write Syntax Tree-Based Domain-Specific Languages in Go
Handwritten Parsers &amp;amp; Lexers in Go
goyacc实战
TiDB SQL Parser 的实现</description>
    </item>
    
    <item>
      <title>Vue 相关资源</title>
      <link>https://czyt.tech/post/vue-related-resource/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/vue-related-resource/</guid>
      <description> Vue - The Complete Guide (incl. Router &amp;amp; Composition API) The Vue.js 3 Masterclass TypeScript Friendly Vue 3 Vue.js Fundamentals </description>
    </item>
    
    <item>
      <title>Golang io.Pipe 使用</title>
      <link>https://czyt.tech/post/golang-io-pipe-usage/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-io-pipe-usage/</guid>
      <description>介绍 // Pipe creates a synchronous in-memory pipe. // It can be used to connect code expecting an io.Reader // with code expecting an io.Writer. // // Reads and Writes on the pipe are matched one to one // except when multiple Reads are needed to consume a single Write. // That is, each Write to the PipeWriter blocks until it has satisfied // one or more Reads from the PipeReader that fully consume // the written data.</description>
    </item>
    
    <item>
      <title>go embed 使用小记</title>
      <link>https://czyt.tech/post/go-embed-usage-note/</link>
      <pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-embed-usage-note/</guid>
      <description>​ go embed 是go 1.16 开始添加的特性，允许嵌入文件及文件夹，在Go程序中进行使用。官方还为此添加了embed.FS的对象。下面将常用的使用场景进行简单列举：
嵌入单个文件 官方的例子
嵌入文件并绑定到字符串变量 import _ &amp;#34;embed&amp;#34; //go:embed hello.txt var s string print(s) 嵌入文件并绑定到字节变量 import _ &amp;#34;embed&amp;#34; //go:embed hello.txt var b []byte print(string(b)) 嵌入文件并绑定到文件对象 import &amp;#34;embed&amp;#34; //go:embed hello.txt var f embed.FS data, _ := f.ReadFile(&amp;#34;hello.txt&amp;#34;) print(string(data)) 嵌入目录 嵌入时，可以在多行或者一行输入要嵌入的文件和文件夹。
package server import &amp;#34;embed&amp;#34; // content holds our static web server content. //go:embed image/* template/* //go:embed html/index.html var content embed.FS 在匹配文件夹时，embed会嵌入包括子目录下的所有除.和_开头的文件（递归），所以上面的代码大致等价于下面的代码：
// content is our static web server content.</description>
    </item>
    
    <item>
      <title>Git小技巧</title>
      <link>https://czyt.tech/post/git-tricks/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/git-tricks/</guid>
      <description>Windows下GIT的几个小技巧 记住git密码 使用下面命令可以设置记住git密码，但推荐使用ssh进行操作。
git config credential.helper store 设置换行符转换 在windows下开发时，迁出的代码是CRLF会导致编译的sh脚本不能正确执行:
git config --global core.autocrlf false Git推送到多个服务器 要实现一次push到多个远程仓库 本机git仓库A https://aaaaa.git 要同步push的远程git仓库B https://bbbbb.git
通过git remote add添加 先使用git remote -v查看远程仓库的情况 ,然后添加一个git仓库
git remote add b https://bbbbb.git 再次查看远程仓库情况，如果需要push，则需要push两次
通过git remote set-url 添加 如果按上面添加过remote分支，需要先git remote rm b,使用下面命令添加即可。
git remote set-url --add a https://bbbbb.git 查看远程仓库情况，看看是否已经是两个push地址了 。这个只需push一次就行了
修改配置文件 打开 .git/config 找到 [remote &amp;ldquo;github&amp;rdquo;]，添加对应的 url 即可，效果如下。这种方法其实和方法二是一样的。
[remote &amp;#34;a&amp;#34;] url = https://aaaaa.git fetch = +refs/heads/*:refs/remotes/a/* url = https://bbbbb.git 参考链接
● 一个项目push到多个远程Git仓库 https://segmentfault.</description>
    </item>
    
    <item>
      <title>Golang nocopy check</title>
      <link>https://czyt.tech/post/golang-nocopy-check/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-nocopy-check/</guid>
      <description>目的 实现nocopy的目的在于，golang在进行参数传递时，都是传递副本的方式。但是某些情况，我们是需要进行传递对象的引用的（特别是一些指针对象，可能会导致多个指针的副本的操作造成程序陷入恐慌），为了杜绝调用者的复制，只能指针传递全局唯一对象。那么就可以通过添加nocopy来实现对go vet参数支持的no copy 检查。
实现 golang里面最常用的sync.WaitGroup就是通过nocopy实现的。参考定义
// A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema.</description>
    </item>
    
    <item>
      <title>golang正则校验支付宝微信支付授权码</title>
      <link>https://czyt.tech/post/golang-check-wechat-alipay-authcode-via-regxp/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-check-wechat-alipay-authcode-via-regxp/</guid>
      <description>参考sdk定义
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;regexp&amp;#34; ) // wechat pay 用户付款码条形码规则：18位纯数字，以10、11、12、13、14、15开头 // alipay 支付授权码，25~30开头的长度为16~24位的数字，实际字符串长度以开发者获取的付款码长度为准 func main() { // wechat regwechat:=regexp.MustCompile(&amp;#34;^(1[0-5])\\d{16}$&amp;#34;) matchwechat := regwechat.MatchString(&amp;#34;154658833119096245&amp;#34;) fmt.Println(matchwechat) // alipay regalipay:=regexp.MustCompile(&amp;#34;^(2[5-9]|30)\\d{14,22}$&amp;#34;) matchalipay := regalipay.MatchString(&amp;#34;307573774583867517336&amp;#34;) fmt.Println(matchalipay) } 参考
微信
支付宝</description>
    </item>
    
    <item>
      <title>Linux环境下Perl提权</title>
      <link>https://czyt.tech/post/perl-privilege-escalation-in-linux/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/perl-privilege-escalation-in-linux/</guid>
      <description>事故起因 我们公司的应用程序部署目录有个bin目录，手误，删除的时候输入的是/bin
事故现象 ● SSH 不能登陆进来了 ● ls、chmod等常用命令都不能使用了 ● wget 还能用
事故解决 通过查找谷歌，发现有个perl带有提权的功能,简单来说就是
perl -e &amp;#34;chmod 0777, &amp;#39;/bin/ls&amp;#39;&amp;#34; 通过这个方式可以对指定的文件进行权限的修改。于是从另外的机器上打包了一个/bin目录，放到网上，wget 下载到本地wget bin.tar.gz
​ 本机开外网ssh转发，scp 拷贝tar文件到目录，执行
perl -e &amp;#34;chmod 0777, &amp;#39;./tar&amp;#39;&amp;#34; ,再使用tar进行文件解压./tar xvzf bin.tar.gz -C /,然后再给chmod执行文件赋予执行权限
perl -e &amp;#34;chmod 0777, &amp;#39;/bin/chmod&amp;#39;&amp;#34; 然后再通过chmod 执行 chmod -R +x /bin/给/bin目录下的可执行程序文件授予执行权限。至此，完成事故修复。
参考连接 ● https://perldoc.perl.org/functions/chmod.html</description>
    </item>
    
    <item>
      <title>ebpf Golang参考</title>
      <link>https://czyt.tech/post/ebpf-golang-reference/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/ebpf-golang-reference/</guid>
      <description>整理一个列表，持续更新。
理论 ebf官网 B站视频 eBPF 和 Go，超能力组合 实践 Tracing Go Functions with eBPF part1 part2 Getting Started with eBPF and Go Linux中基于eBPF的恶意利用与检测机制 如何用eBPF分析Golang应用 使用BPF, 将Go网络程序的吞吐提升8倍 使用ebpf跟踪rpcx微服务 BPF MAP机制 一种通用数据结构，可以存储不同类型数据的通用数据结构 Andrii Nakryiko 抽象数据容器(abstract data container) bpf系统调用的说明 《使用C语言从头开发一个Hello World级别的eBPF程序》 《Linux Observability with BPF》 《揭秘BPF map前生今世》 bpf系统调用说明 官方bpf map参考手册 bpftool参考手册 《Building BPF applications with libbpf-bootstrap》 https://github.com/DavadDi/bpf_study golang 包 https://github.com/cilium/ebpf </description>
    </item>
    
    <item>
      <title>Go性能优化参考</title>
      <link>https://czyt.tech/post/golang-perf-reference/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-perf-reference/</guid>
      <description>电子书 编写和优化Go代码 Go Optimizations 101 https://github.com/dgryski/go-perfbook https://github.com/DataDog/go-profiler-notes https://github.com/bobstrecansky/HighPerformanceWithGo/ Go package https://github.com/aclements/go-perf 文章 官方博客 Profiling Go Programs
https://sumercip.com/posts/inside-the-go-cpu-profiler/
How to Write Benchmarks in Go : https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
Debugging performance issues in Go programs : https://github.com/golang/go/wiki/Performance
Go execution tracer : https://blog.gopheracademy.com/advent-2017/go-execution-tracer/ (see also the The tracer design doc link)
A whirlwind tour of Go’s runtime environment variables (see godebug) : https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables
benchstat : https://godoc.org/golang.org/x/perf/cmd/benchstat
pyroscope: 一个简单易用的持续剖析平台
VSCODE可视化调试Go程序
Jetbrains官方Goland代码调试文档
https://github.com/cch123/perf_workshop_2021
GO高性能编程精华
Go 语言中各式各样的优化手段
Go 中简单的内存节省技巧</description>
    </item>
    
    <item>
      <title>Cap&#39;n Proto Windows环境设置</title>
      <link>https://czyt.tech/post/capn-proto-setup-in-windows/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/capn-proto-setup-in-windows/</guid>
      <description>Cap&amp;rsquo;n proto 号称是比protobuff更快的proto语言。官网截图
Cap’n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think Protocol Buffers, except faster. In fact, in benchmarks, Cap’n Proto is INFINITY TIMES faster than Protocol Buffers.
协议特性
Cap’n Proto’s RPC protocol has the following notable features. Since the protocol is complicated, the feature set has been divided into numbered “levels”, so that implementations may declare which features they have covered by advertising a level number.</description>
    </item>
    
    <item>
      <title>Golang反射使用指南</title>
      <link>https://czyt.tech/post/golang-reflect-reference/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-reflect-reference/</guid>
      <description>Go是一门强类型的语言，在大多数情况下，申明一个变量、函数、struct都是直截了当的。在大多数情况下，这些都是够用的，但有时你想在程序运行中来动态扩展程序的信息，也许你想把文件或网络请求中的数据映射到一个变量中;也许你想建立一个能处理不同类型的工具(虽然Go1.18有了泛型)。在这些情况下，你需要使用反射。反射使你有能力在运行时检查、修改和创建变量、函数和结构的能力。
反射的核心 图片转自 Go 语言设计与实现
反射的三大核心是*Types, Kinds, Values,下面将围绕这三个方面来进行讲解。
我们先定义一个struct对象。
type User struct { Name	string Age int } 类型Types 通过反射获取类型
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Name()) // 打印 User log.Println(otptr.Name()) // 打印 空 通过调用Name()方法返回类型的名称，某些类型，如切片或指针，没有名称，此方法返回一个空字符串。
种类Kinds Kind通过调用Kind()得来。
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Kind()) // 输出 struct log.Println(otptr.Kind()) // 输出 ptr Kind() 返回的是kind类型的枚举。</description>
    </item>
    
    <item>
      <title>Golang MongoDB ODM mgm使用</title>
      <link>https://czyt.tech/post/golang-mongodb-mgm-odm-usage/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-mongodb-mgm-odm-usage/</guid>
      <description>(本文大部分内容根据官方文档翻译而来)
环境准备 golang 1.10+ mongodb mgm 模型定义 定义 定义模型
type Book struct { // DefaultModel adds _id, created_at and updated_at fields to the Model mgm.DefaultModel `bson:&amp;#34;,inline&amp;#34;` Name string `json:&amp;#34;name&amp;#34; bson:&amp;#34;name&amp;#34;` Pages int `json:&amp;#34;pages&amp;#34; bson:&amp;#34;pages&amp;#34;` } func NewBook(name string, pages int) *Book { return &amp;amp;Book{ Name: name, Pages: pages, } } mgm 在创建表时会自动检测Model生成的Collection名称
book:=Book{} // Print your model collection name. collName := mgm.CollName(&amp;amp;book) fmt.Println(collName) // 打印: books 如果要自定义生成Collection的名称。需要实现CollectionNameGetter接口。
func (model *Book) CollectionName() string { return &amp;#34;my_books&amp;#34; } // mgm return &amp;#34;my_books&amp;#34; collection coll:=mgm.</description>
    </item>
    
    <item>
      <title>Flutter开发Maven配置</title>
      <link>https://czyt.tech/post/maven-setting-for-flutter-dev/</link>
      <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/maven-setting-for-flutter-dev/</guid>
      <description>在Flutter开发时，可能因为网络等原因导致maven不能正常工作，造成Flutter项目卡住的情况。下面是解决办法。原文链接 https://flutter.cn/community/china
如果你在国内使用 Flutter，那么你可能需要找一个与官方同步的可信的镜像站点，帮助你的 Flutter 命令行工具到该镜像站点下载其所需的资源。你需要为此设置两个环境变量：PUB_HOSTED_URL 和 FLUTTER_STORAGE_BASE_URL，然后再运行 Flutter 命令行工具。
以 macOS 或者与 Linux 相近的系统为例，这里有以下步骤帮助你设定镜像。在系统终端里执行如下命令设定环境变量，并通过 GitHub 检出 Flutter SDK：
content_copy
$ export PUB_HOSTED_URL=https://pub.flutter-io.cn$ export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn$ git clone -b dev https://github.com/flutter/flutter.git$ export PATH=&amp;#34;$PWD/flutter/bin:$PATH&amp;#34;$ cd ./flutter$ flutter doctor Flutter SDK配置修改 flutter的maven设置在&amp;lt;安装目录&amp;gt;\packages\flutter_tools\gradle\flutter.gradle
打包配置 buildscript {repositories {maven { url &amp;#39;https://maven.aliyun.com/repository/google&amp;#39; }maven { url &amp;#39;https://maven.aliyun.com/repository/public&amp;#39; }maven { url &amp;#39;https://maven.aliyun.com/repository/central&amp;#39; }maven { url &amp;#39;https://maven.aliyun.com/repository/jcenter&amp;#39; }// google()// jcenter()}dependencies {/* When bumping, also update ndkVersion above.</description>
    </item>
    
    <item>
      <title>MongoDB操作指北</title>
      <link>https://czyt.tech/post/operate-mongodb-tutorial/</link>
      <pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/operate-mongodb-tutorial/</guid>
      <description>TL;DR
环境准备 mongoDB 预备知识 MongoDB常见的数据类型
数据类型 示例 说明 Null {&amp;quot;x&amp;quot; : null} Boolean {&amp;quot;x&amp;quot; : true} Number {&amp;quot;x&amp;quot; : 3.14} {&amp;quot;x&amp;quot; : 3} {&amp;quot;x&amp;quot; : NumberInt(&amp;quot;3&amp;quot;)} {&amp;quot;x&amp;quot; : NumberLong(&amp;quot;3&amp;quot;)} 默认64位浮点数，整数需要使用NumberInt和NumberLong String {&amp;quot;x&amp;quot; : &amp;quot;foobar&amp;quot;} 编码格式为UTF-8 Date {&amp;quot;x&amp;quot; : new Date()} 64位时间戳(从January 1, 1970)，不存时区。通过new Date()进行调用。 Regular expression {&amp;quot;x&amp;quot; : /foobar/i} javascript 正则 Array {&amp;quot;x&amp;quot; : [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]} Embedded document {&amp;quot;x&amp;quot; : {&amp;quot;foo&amp;quot; : &amp;quot;bar&amp;quot;}} Object ID {&amp;quot;x&amp;quot; : ObjectId()} 文档12字节的ID Binary data 一个任意字节的字符串。是保存非UTF-8字符串到数据库的唯一方法。 Code {&amp;quot;x&amp;quot; : function() { /* .</description>
    </item>
    
    <item>
      <title>通过注册表禁用windows10自动更新</title>
      <link>https://czyt.tech/post/block-windows10-update-via-registry/</link>
      <pubDate>Thu, 19 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/block-windows10-update-via-registry/</guid>
      <description>缘起 近期项目上设备会自动更新windows10为windows11，通过搜索，搜索到第三方工具windows-update-blocker ，因为改工具支持命令行参数，故也很方便于集成。批处理大致如下
@echo off pushd %~dp0 echo 开始禁用windows更新服务 %~dp0Wub_x64.exe /D /P timeout 3 背后的操作 作为技术人，还是需要知道软件做了什么背后的操作，通过TotalUninstaller监控，获取到软件写入的注册表如下,实现的手段就是镜像劫持windows更新的进程，并且更新windows的组策略选项：
Windows Registry Editor Version 5.00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer] &amp;#34;NoWindowsUpdate&amp;#34;=dword:00000001 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options] &amp;#34;WubBlockLists&amp;#34;=hex(7):57,00,61,00,61,00,53,00,4D,00,65,00,64,00,69,00,63,00,\ 2E,00,65,00,78,00,65,00,00,00,57,00,61,00,61,00,73,00,4D,00,65,00,64,00,69,\ 00,63,00,41,00,67,00,65,00,6E,00,74,00,2E,00,65,00,78,00,65,00,00,00,57,00,\ 69,00,6E,00,64,00,6F,00,77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,\ 00,64,00,65,00,2E,00,65,00,78,00,65,00,00,00,57,00,69,00,6E,00,64,00,6F,00,\ 77,00,73,00,31,00,30,00,55,00,70,00,67,00,72,00,61,00,64,00,65,00,72,00,41,\ 00,70,00,70,00,2E,00,65,00,78,00,65,00,00,00,55,00,70,00,64,00,61,00,74,00,\ 65,00,41,00,73,00,73,00,69,00,73,00,74,00,61,00,6E,00,74,00,2E,00,65,00,78,\ 00,65,00,00,00,55,00,73,00,6F,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,00,\ 65,00,78,00,65,00,00,00,72,00,65,00,6D,00,73,00,68,00,2E,00,65,00,78,00,65,\ 00,00,00,45,00,4F,00,53,00,6E,00,6F,00,74,00,69,00,66,00,79,00,2E,00,65,00,\ 78,00,65,00,00,00,53,00,69,00,68,00,43,00,6C,00,69,00,65,00,6E,00,74,00,2E,\ 00,65,00,78,00,65,00,00,00,75,00,70,00,66,00,63,00,2E,00,65,00,78,00,65,00,\ 00,00,49,00,6E,00,73,00,74,00,61,00,6C,00,6C,00,41,00,67,00,65,00,6E,00,74,\ 00,2E,00,65,00,78,00,65,00,00,00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,\ 66,00,69,00,63,00,61,00,74,00,69,00,6F,00,6E,00,2E,00,65,00,78,00,65,00,00,\ 00,4D,00,75,00,73,00,4E,00,6F,00,74,00,69,00,66,00,69,00,63,00,61,00,74,00,\ 69,00,6F,00,6E,00,55,00,78,00,2E,00,65,00,78,00,65,00,00,00,00,00,00,00 [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\EOSnotify.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;/&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\InstallAgent.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;/&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\MusNotification.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;/&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\MusNotificationUx.exe] &amp;#34;Debugger&amp;#34;=&amp;#34;/&amp;#34; [HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\remsh.</description>
    </item>
    
    <item>
      <title>Golang监测Linux网络事件</title>
      <link>https://czyt.tech/post/golang-monitor-linux-network-events/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-monitor-linux-network-events/</guid>
      <description>代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;syscall&amp;#34; ) func main() { l, _ := ListenNetlink() for { msgs, err := l.ReadMsgs() if err != nil { fmt.Println(&amp;#34;Could not read netlink: %s&amp;#34;, err) } for _, m := range msgs { if IsNewAddr(&amp;amp;m) { fmt.Println(&amp;#34;New Addr&amp;#34;) } if IsDelAddr(&amp;amp;m) { fmt.Println(&amp;#34;Del Addr&amp;#34;) } } } } type NetlinkListener struct { fd int sa *syscall.SockaddrNetlink } func ListenNetlink() (*NetlinkListener, error) { groups := (1 &amp;lt;&amp;lt; (syscall.</description>
    </item>
    
    <item>
      <title>Golang False sharing</title>
      <link>https://czyt.tech/post/golang-false-sharing/</link>
      <pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-false-sharing/</guid>
      <description>缘起 来自于一段prometheus代码
type stripeLock struct { sync.RWMutex // Padding to avoid multiple locks being on the same cache line. _ [40]byte } 简单地讲就是因为CPU读取数据的缓存机制问题，可能导致性能上的不同差异。参考资料见后文。
常见类型的内存占用大小（Go101）：
Kinds of Types Value Size Required by Go Specification bool 1 byte not specified int8, uint8 (byte) 1 byte 1 byte int16, uint16 2 bytes 2 bytes int32 (rune), uint32, float32 4 bytes 4 bytes int64, uint64, float64, complex64 8 bytes 8 bytes complex128 16 bytes 16 bytes int, uint 1 word architecture dependent, 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures uintptr 1 word large enough to store the uninterpreted bits of a pointer value string 2 words not specified pointer (safe or unsafe) 1 word not specified slice 3 words not specified map 1 word not specified channel 1 word not specified function 1 word not specified interface 2 words not specified struct (the sum of sizes of all fields) + (the number of padding bytes) the size of a struct type is zero if it contains no fields that have a size greater than zero array (element value size) * (array length) the size of an array type is zero if its element type has zero size 参考 https://medium.</description>
    </item>
    
    <item>
      <title>WPF与虚拟键盘的那些事</title>
      <link>https://czyt.tech/post/wpf-virtual-keyboard-related/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/wpf-virtual-keyboard-related/</guid>
      <description>缘起 近期项目使用到相关技术，故整理文章一篇。
获取可用输入设备 软件的本质无非是输入和输出，那么WPF如何获取电脑是否有可用输入设备呢？查询了Google,在StackOverflow上找到一个提问，原帖地址，代码如下：
KeyboardCapabilities keyboardCapabilities = new Windows.Devices.Input.KeyboardCapabilities(); return keyboardCapabilities.KeyboardPresent != 0 ? true : false; 如果没有可用输入设备，那么就该虚拟键盘上场了。windows里面有两个虚拟键盘的程序，一个是TabTip.exe一个是osk.exe,可以直接调用进程，也可以使用 WPF的第三方组件https://github.com/maximcus/WPFTabTip 详细实现可以参考后面的链接。
平板模式 下面代码将当前系统的运行模式改为平板模式
public static readonly Guid CLSID_ImmersiveShell = new Guid(&amp;#34;C2F03A33-21F5-47FA-B4BB-156362A2F239&amp;#34;); [ComImport()] [Guid(&amp;#34;4FDA780A-ACD2-41F7-B4F2-EBE674C9BF2A&amp;#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] public interface ITabletModeController { int GetMode(ref int mode); int SetMode(int mode, int modeTrigger); } [ComImport] [Guid(&amp;#34;6D5140C1-7436-11CE-8034-00AA006009FA&amp;#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] internal interface IServiceProvider { [return: MarshalAs(UnmanagedType.IUnknown)] object QueryService(ref Guid service, ref Guid riid); } 调用
var pSP = (IServiceProvider)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_ImmersiveShell)); var pTMC = (ITabletModeController)pSP.</description>
    </item>
    
    <item>
      <title>Keep运动接口</title>
      <link>https://czyt.tech/post/keep-api-collect/</link>
      <pubDate>Thu, 21 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/keep-api-collect/</guid>
      <description>基础接口 授权 curl --location --request POST &amp;#39;https://api.gotokeep.com/v1.1/users/login&amp;#39; \ --header &amp;#39;Content-Type: application/json&amp;#39; \ --data-raw &amp;#39;{&amp;#34;mobile&amp;#34;: 18888888888, &amp;#34;password&amp;#34;: &amp;#34;aa&amp;#34;}&amp;#39; 返回token内容需要作为后续请求的header传递，返回示例：
{ &amp;#34;ok&amp;#34;: true, &amp;#34;data&amp;#34;: { &amp;#34;userId&amp;#34;: &amp;#34;011981111e131&amp;#34;, &amp;#34;level&amp;#34;: 0, &amp;#34;goal&amp;#34;: 0, &amp;#34;gender&amp;#34;: &amp;#34;M&amp;#34;, &amp;#34;token&amp;#34;: &amp;#34;xxxxxxxxxxxx&amp;#34;, &amp;#34;userRegisterInfo&amp;#34;: null }, &amp;#34;errorCode&amp;#34;: &amp;#34;0&amp;#34;, &amp;#34;now&amp;#34;: &amp;#34;2022-04-21T05:02:57Z&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0.0&amp;#34;, &amp;#34;text&amp;#34;: null, &amp;#34;more&amp;#34;: {} } 动作库 获取动作分类
curl --location --request GET &amp;#39;https://api.gotokeep.com/training/v2/trainingpoints/exerciselib&amp;#39; \ --header &amp;#39;Authorization: Bearer xxxxxxxxx&amp;#39; 返回
{ &amp;#34;ok&amp;#34;: true, &amp;#34;data&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;胸部&amp;#34;, &amp;#34;_id&amp;#34;: &amp;#34;54826e417fb786000069ad82&amp;#34;, &amp;#34;url&amp;#34;: &amp;#34;http://static1.</description>
    </item>
    
    <item>
      <title>为Kratos prtobuf文件添加多种编译输出</title>
      <link>https://czyt.tech/post/add-muti-kinds-output-for-kratos/</link>
      <pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/add-muti-kinds-output-for-kratos/</guid>
      <description>Csharp 安装Grpc.tools https://www.nuget.org/packages/Grpc.Tools/
下载解压 nupkg文件（改扩展名为zip），也可以使用附件的7z包
解压 找到tools中对应系统架构的软件，设置下环境变量，让系统可以找到就行。
Linux 需要创建一个符号链接
ln -s `which grpc_csharp_plugin` /usr/bin/protoc-gen-grpc-csharp 修改Kratos项目的Make文件 在api这个make任务中添加下面内容
--csharp_out=./api/pipe/v1 \ --grpc-csharp_out=./api/pipe/v1 \ 完整内容为
.PHONY: api # generate api proto api: protoc --proto_path=./api \ --proto_path=./third_party \ --go_out=paths=source_relative:./api \ --go-http_out=paths=source_relative:./api \ --go-grpc_out=paths=source_relative:./api \ --csharp_out=./api/pipe/v1 \ --grpc-csharp_out=./api/pipe/v1 \ --openapi_out==paths=source_relative:. \ 参考
https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md
📎tools.7z
Python 安装必要包 pip install grpclib protobuf 查询路径 which protoc-gen-grpclib_python 或者 which protoc-gen-python_grpc我这里返回信息如下： ➜ czyt which protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpclib_python 如法炮制，创建软链接 ln -s /usr/sbin/protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpc_python 修改Makefile 添加下面的内容,再执行make api生成api即可。 --python_out=.</description>
    </item>
    
    <item>
      <title>个人Golang环境安装快速设置</title>
      <link>https://czyt.tech/post/personal-golang-env-quick-set/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/personal-golang-env-quick-set/</guid>
      <description>下载 官方下载 https://go.dev/dl/
Google 香港镜像
Golang Downloads Mirrors
更多请参考 Thanks Mirror
环境设置 设置proxy
go env -w GOPROXY=https://goproxy.io,https://goproxy.cn,direct 安装相关工具 框架Cli kratos go install github.com/go-kratos/kratos/cmd/kratos/v2@latest
wire go install github.com/google/wire/cmd/wire@latest
ent go install entgo.io/ent/cmd/ent@latest
entimport go install ariga.io/entimport/cmd/entimport@latest
entproto go install entgo.io/contrib/entproto/cmd/entproto@latest
代码Lint golangci-lint go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
gofumpt go install mvdan.cc/gofumpt@latest goland设置
GoLand doesn&amp;rsquo;t use gopls so it should be configured to use gofumpt directly. Once gofumpt is installed, follow the steps below:</description>
    </item>
    
    <item>
      <title>Rasp3b 安装MongoDB</title>
      <link>https://czyt.tech/post/install-mongodb-on-rasp3b/</link>
      <pubDate>Wed, 23 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/install-mongodb-on-rasp3b/</guid>
      <description>安装 机器安装的是Manjaro,所以本文介绍的是Manjaro的树莓派3安装方式
➜ ~ screenfetch czyt@** OS: Manjaro-ARM 22.01 Kernel: aarch64 Linux 5.15.24-1-MANJARO-ARM-RPI ##### Uptime: 21d 21h 58m ####### Packages: Unknown ##O#O## Shell: zsh 5.8.1 ####### Disk: 11G / 118G (9%) ########### CPU: BCM2835 @ 4x 1.2GHz ############# GPU: ############### RAM: 248MiB / 919MiB ################ ################# ##################### ##################### ################# 使用命令 yay -S mongodb44-bin进行安装，安装完毕后
启用服务 systemctl enable mongodb
检查服务状态 systemctl status mongodb
● mongodb.service - MongoDB Database Server Loaded: loaded (/usr/lib/systemd/system/mongodb.service; enabled; vendor preset: disabled) Active: active (running) since Wed 2022-03-23 13:11:08 CST; 11s ago Docs: https://docs.</description>
    </item>
    
    <item>
      <title>WPF Prism 8如何注册Logging</title>
      <link>https://czyt.tech/post/how-to-register-logging-in-prism8/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/how-to-register-logging-in-prism8/</guid>
      <description>Nuget包 基础包 Microsoft Logging Abstractions Microsoft Extensions DependencyInjection 可选日志包 可以按实际需求进行选择，如NLog等,我们这里采用的是 Serilog 这个Nuget包Serilog Extensions Logging
根据日志输出的目标不同，可以选择不同的扩展方法包
目标 包名 说明 文件 Serilog.Sinks.File WiteTo可以使用File方法详细说明 命令行 Serilog.Sinks.Console 调试输出 Serilog.Sinks.Debug WiteTo可以使用Debug方法 其他扩展，请搜索 点击
日志容器注册 我们使用的是 DryIoc 进行注册，需要安装Nuget包 DryIoc.Microsoft.DependencyInjection 具体代码如下：
protected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =&amp;gt; loggingBuilder.AddSerilog(dispose: true)); return new DryIocContainerExtension(new Container(CreateContainerRules()) .WithDependencyInjectionAdapter(serviceCollection)); } 如果是Unity 则需要安装包 Unity.Microsoft.DependencyInjection 具体代码如下：
protected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =&amp;gt; loggingBuilder.</description>
    </item>
    
    <item>
      <title>grpc-golang windows环境搭建说明</title>
      <link>https://czyt.tech/post/grpc-golang-setup-in-windows/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/grpc-golang-setup-in-windows/</guid>
      <description>下载protoc，打开链接 下载后将对应的文件解压到gopath的bin目录。 下载protoc的golang插件。下载地址 链接 下载后放在protoc的同级目录（需要改扩展名为exe） 测试，定义一个Proto syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;.;hello&amp;#34;; package main; message String { string value = 1; } 然后执行命令 protoc hello.proto --go_out=. ,大功告成，生成的文件内容如下：
// Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.24.0-devel // protoc v3.12.3 // source: hello.proto package hello import ( proto &amp;#34;github.com/golang/protobuf/proto&amp;#34; protoreflect &amp;#34;google.golang.org/protobuf/reflect/protoreflect&amp;#34; protoimpl &amp;#34;google.golang.org/protobuf/runtime/protoimpl&amp;#34; reflect &amp;#34;reflect&amp;#34; sync &amp;#34;sync&amp;#34; ) const ( // Verify that this generated code is sufficiently up-to-date.</description>
    </item>
    
    <item>
      <title>Rust安装及配置</title>
      <link>https://czyt.tech/post/rust-setup-and-config/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/rust-setup-and-config/</guid>
      <description>下载rustup 从此处下载
设置rustup镜像 字节提供的镜像 https://rsproxy.cn
export RUSTUP_DIST_SERVER=&amp;#34;https://rsproxy.cn&amp;#34; export RUSTUP_UPDATE_ROOT=&amp;#34;https://rsproxy.cn/rustup&amp;#34; 设置两个环境变量即可 设置环境变量 RUSTUP_DIST_SERVER (用于更新 toolchain)
export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static 以及 RUSTUP_UPDATE_ROOT (用于更新 rustup)
export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup crates.io 镜像 编辑 ~/.cargo/config [source.crates-io]replace-with = &amp;#39;rsproxy&amp;#39;[source.rsproxy]registry = &amp;#34;https://rsproxy.cn/crates.io-index&amp;#34;[registries.rsproxy]index = &amp;#34;https://rsproxy.cn/crates.io-index&amp;#34;[net]git-fetch-with-cli = true 安装Rust 安装rust即可。可以参考我的步骤
Current installation options: default host triple: x86_64-pc-windows-msvc default toolchain: stable (default) profile: default modify PATH variable: yes 1) Proceed with installation (default) 2) Customize installation 3) Cancel installation &amp;gt;2 I&amp;#39;m going to ask you the value of each of these installation options.</description>
    </item>
    
    <item>
      <title>一个免费的TTS接口</title>
      <link>https://czyt.tech/post/a-free-tts-api/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/a-free-tts-api/</guid>
      <description>示例：
https://dds.dui.ai/runtime/v1/synthesize?voiceId=ppangf_csn&amp;amp;text=您好世界&amp;amp;speed=1&amp;amp;volume=50&amp;amp;audioType=wav 使用步骤
graph LR;选择声音 --&gt; 输入要转语音文本 --&gt; 拼接URL --&gt; 使用语音参数说明：
text 要转音频的文本内容 （200字以内） speed 语速 volume 声音大小 voiceId 发音类型可以取下面的值： VoiceId 名称 说明 qiumum_0gushi 精品秋木 活泼开朗适合有声读物等场景 kaolam_diantai 精品考拉 电台男声温柔的电台男声 juan1f 小美 客服女声声音甜美热情，客服、营销场景均适用 xmguof 婷婷 营销女声音色亲切大方，适用于电话销售、调研回访等场景 xmamif 小咪 营销女声活力甜美，适用于电话营销、邀约等场景 lunaif_ctn 晓健 标准粤语女声偏正式的标准粤语，适用于新闻播报等场景 hchunf_ctn 何春 自然粤语女声音色偏甜美自然，适用于家居播报等场景 dayaof_csd 大瑶 山东话女声音色偏甜美自然，适用于家居播报等场景 wqingf_csn 文卿 四川话女声音色偏甜美自然，适用于车载导航等场景 ppangf_csn 胖胖 四川话女声音色偏甜美自然，适用于家居播报等场景 yezi1f_csh 叶子 上海话女声音色偏甜美自然，适用于家居播报等场景 madoufp_yubo 麻豆 娱播女声甜美欢快的女声，适合做娱乐新闻的播报 madoufp_wenrou 麻豆 甜美温柔客服、营销、阅读听书的场景均可使用 xjingfp 小静 甜美女声音色甜美知性，可用于娱乐新闻等播报 xjingf_gushi 小静 自然音色甜美知性，可用于娱乐新闻等播报 xjingf 小静 商务知性音色甜美知性，可用于娱乐新闻等播报 zhilingfp 小玲 甜美女神音色亲切、欢快、自然，适合用于各种场景 zhilingfp_huankuai 小玲 欢快自然音色亲切、欢快、自然，适合用于各种场景 zhilingfa 小玲 标准小玲的音色亲切，甜美，自然，适合用于各种场景 zhilingf 传统小玲 甜美性感音色甜美、自然、性感，适合用于各种场景 anonyf 小佚 平和沉稳音色沉稳严肃，适合用于新闻播报等 xbekef 贝壳 可爱女童童真可爱，适合讲幼儿故事 xijunma 精品小军 新闻播报适合新闻播报等场景 xijunm 传统小军 标准正式标准发音，适合新闻播报等场景 geyou 葛爷 淡定风趣模仿葛优音色 gdgm 纲叔 沉稳幽默模仿郭德纲音色 zxcm 星哥 风趣幽默模仿周星驰音色 qianranf 传统然然 天真俏皮成人女声模仿女童音色 hyanif 小妮 温柔亲切适合情感电台播报等场景 gqlanf 标准小兰 邻家女声温柔的邻家女声，适合做客服音色 gqlanfp 精品小兰 温柔甜美温柔的邻家女声，适合做客服音色 qianranfa 标准然然 天真俏皮语速1.</description>
    </item>
    
    <item>
      <title>Arch Linux 常用软件</title>
      <link>https://czyt.tech/post/arch-awesome-software/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/arch-awesome-software/</guid>
      <description>更换软件源 使用中国的镜像排名
sudo pacman-mirrors -i -c China -m rank //更新镜像排名 sudo pacman -Syy //更新数据源 sudo pacman-mirrors -g //排列数据源 添加archlinuxcn源编辑命令 sudo nano /etc/pacman.conf 添加下面的内容
[archlinuxcn] SigLevel = Optional TrustedOnly #中科大源 Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch #清华源 # Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 163源 # Server = http://mirrors.163.com/archlinux-cn/$arch 然后再更新软件数据源
sudo pacman -Syy sudo pacman -S archlinux-keyring archlinuxcn-keyring 因为本文的软件使用yay进行安装，故需要使用命令进行安装，命令为 sudo pacman -S yay 设置yay的mirror
yay --aururl &amp;#34;https://aur.tuna.tsinghua.edu.cn&amp;#34; --save 可选安装 编译包 yay -S base-devel 注：类似的包管理器还可以用 paru
SSH管理工具 Remmina 安装 yay -S remmina 可以选装这些插件</description>
    </item>
    
    <item>
      <title>golang webserver with genergic base64 /favicon.ico</title>
      <link>https://czyt.tech/post/golang-web-server-add-base64-favicon/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-web-server-add-base64-favicon/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/favicon.ico&amp;#34;, favicon) http.HandleFunc(&amp;#34;/&amp;#34;, hello) fmt.Printf(&amp;#34;listening on http://localhost:8000/\n&amp;#34;) http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, nil) } func favicon(w http.ResponseWriter, r *http.Request) { fmt.Printf(&amp;#34;%s\n&amp;#34;, r.RequestURI) w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;image/x-icon&amp;#34;) w.Header().Set(&amp;#34;Cache-Control&amp;#34;, &amp;#34;public, max-age=7776000&amp;#34;) fmt.Fprintln(w, &amp;#34;data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=\n&amp;#34;) } func hello(w http.ResponseWriter, r *http.Request) { fmt.Printf(&amp;#34;%s\n&amp;#34;, r.RequestURI) fmt.Fprintln(w, &amp;#34;Hello, World!&amp;#34;) } </description>
    </item>
    
    <item>
      <title>Golang嵌入可执行程序</title>
      <link>https://czyt.tech/post/golang-embed-executable-file/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-embed-executable-file/</guid>
      <description>reddit链接 On Linux it might be possible to use the memfd_create system call, but that&amp;rsquo;s not portable to other operating systems.
need go 1.16 +
package main import ( _ &amp;#34;embed&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;golang.org/x/sys/unix&amp;#34; ) //go:embed binary var embeddedBinary []byte func main() { fd, err := unix.MemfdCreate(&amp;#34;embedded_binary&amp;#34;, 0) if err != nil { log.Fatal(err) } path := &amp;#34;/proc/&amp;#34; + strconv.Itoa(os.Getpid()) + &amp;#34;/fd/&amp;#34; + strconv.Itoa(int(fd)) err = os.WriteFile(path, embeddedBinary, 0755) if err !</description>
    </item>
    
    <item>
      <title>Golang通过ssh连接数据库</title>
      <link>https://czyt.tech/post/go-connect-db-via-ssh/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-connect-db-via-ssh/</guid>
      <description>Mysql Postgresql </description>
    </item>
    
    <item>
      <title>golang正则表达式小札</title>
      <link>https://czyt.tech/post/golang-regxp-notes/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-regxp-notes/</guid>
      <description>准备工作 golang正则需要引入包中的regexp包。
import ( &amp;#34;regexp&amp;#34; ) 如果需要复用正则表达式对象来提高性能，可以通过Compile() 或者 MustCompile()创建一个编译好的正则表达式对象。
支持的表达式 单个匹配:
. any character, possibly including newline (flag s=true)[xyz] character class[^xyz] negated character class\d Perl character class\D negated Perl character class[[:alpha:]] ASCII character class[[:^alpha:]] negated ASCII character class\pN Unicode character class (one-letter name)\p{Greek} Unicode character class\PN negated Unicode character class (one-letter name)\P{Greek} negated Unicode character class 组合匹配:
xy x followed by yx|y x or y (prefer x) 多次匹配:</description>
    </item>
    
    <item>
      <title>golang不创建临时文件上传网络文件</title>
      <link>https://czyt.tech/post/golang-upload-network-file-with-no-tmp-file/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-upload-network-file-with-no-tmp-file/</guid>
      <description>func UploadFromUrl(uploadUrl string, resUrl string,postFileName string, submitField string) error { method := &amp;#34;POST&amp;#34; payload := &amp;amp;bytes.Buffer{} writer := multipart.NewWriter(payload) if res, err := http.Get(resUrl); err != nil { return err } else { defer func() { if res != nil { _ = res.Body.Close() } }() part, _ := writer.CreateFormFile(submitField, postFileName) if _, copyErr := io.Copy(part, res.Body); copyErr != nil { return copyErr } if err := writer.Close(); err != nil { return err } } client := &amp;amp;http.</description>
    </item>
    
    <item>
      <title>golang检测网络连接是否关闭</title>
      <link>https://czyt.tech/post/golang-check-netconnection/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-check-netconnection/</guid>
      <description>_, err := conn.Read(make([]byte, 0)) if err!=io.EOF{ // this connection is invalid logger.W(&amp;#34;conn closed....&amp;#34;,err) }else{ byt, _:= ioutil.ReadAll(conn); } 注意：net: don&amp;rsquo;t return io.EOF from zero byte reads issue
参考
https://stackoverflow.com/questions/12741386/how-to-know-tcp-connection-is-closed-in-net-package</description>
    </item>
    
    <item>
      <title>golang使用官方库实现i18n</title>
      <link>https://czyt.tech/post/golang-impl-i18n-with-standard-lib/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-impl-i18n-with-standard-lib/</guid>
      <description>示例 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;golang.org/x/text/language&amp;#34; &amp;#34;golang.org/x/text/message&amp;#34; &amp;#34;golang.org/x/text/message/catalog&amp;#34; ) func main() { builder := catalog.NewBuilder() chTag:=language.Make(&amp;#34;zh_Hans&amp;#34;) engTag:=language.Make(&amp;#34;en&amp;#34;) builder.SetString(chTag,&amp;#34;hello&amp;#34;,&amp;#34;您好&amp;#34;) builder.SetString(engTag,&amp;#34;hello&amp;#34;,&amp;#34;Hello&amp;#34;) fmt.Println(builder.Languages()) option := message.Catalog(builder) p := message.NewPrinter(chTag,option) p.Printf(&amp;#34;hello&amp;#34;) p2 := message.NewPrinter(engTag,option) p2.Printf(&amp;#34;hello&amp;#34;) } 参考 https://zyfdegh.github.io/post/201805-translation-go-i18n https://www.alexedwards.net/blog/i18n-managing-translations https://phrase.com/blog/posts/internationalisation-in-go-with-go-i18n/ https://lokalise.com/blog/go-internationalization-using-go-i18n/ https://go.googlesource.com/proposal/+/master/design/12750-localization.md </description>
    </item>
    
  </channel>
</rss>
