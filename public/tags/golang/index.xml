<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>golang on 虫子樱桃</title>
    <link>https://czyt.tech/tags/golang/</link>
    <description>Recent content in golang on 虫子樱桃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 29 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://czyt.tech/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用protoc-gen-star编写protoc插件</title>
      <link>https://czyt.tech/post/writing-a-protoc-plugin-using-protoc-gen-star/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/writing-a-protoc-plugin-using-protoc-gen-star/</guid>
      <description>预备知识 需要安装的软件 protoc golang go 软件包 github.com/lyft/protoc-gen-star 插件调用步骤 protoc，PB编译器，使用一组标志（记录在protoc -h下）进行配置，并将一组文件作为参数交给它。在这种情况下，I标志可以被多次指定，是它在proto文件中用于导入依赖关系的查找路径。默认情况下，官方描述符protos已经被包含在内。
myplugin_out 告诉 protoc 使用 protoc-gen-myplugin protoc-plugin。这些插件会从系统的 PATH 环境变量中自动解析，或者可以用另一个标志明确指定。官方的protoc-plugins (例如，protoc-gen-python) 已经在protoc注册了。该标志的值是特定于特定插件的，但 :&amp;hellip;/generated 后缀除外。这个后缀表示protoc将把该包生成的文件放在哪个根目录下（相对于当前工作目录）。然而，这个生成的输出目录不会传播给 protoc-gen-myplugin，所以它需要在标志的左边重复。PG* 通过一个 output_path 参数支持这一点。
protoc 解析传入的 proto 文件，确保它们在语法上是正确的，并加载任何导入的依赖项。它将这些文件和依赖关系转换成描述符 (它们本身就是 PB 消息)，并创建一个 CodeGeneratorRequest (又是一个 PB)。protoc 将这个请求序列化，然后执行每个配置的 protoc-plugin，通过 stdin 发送有效载荷。
protoc-gen-myplugin 启动，接收请求的有效载荷，并将其解密。一个基于 PG* 的 protoc-plugin 有两个阶段。首先，PG* 对从 protoc 收到的 CodeGeneratorRequest 进行解密，并为每个文件和其包含的所有实体创建一个完全连接的抽象语法树 (AST)。为这个插件指定的任何参数也会被解析，以便以后使用。
当这一步完成后，PG*就会执行任何注册的模块，把构建的AST交给它。模块可以被写成生成人工制品（例如，文件），或者只是对所提供的图进行某种形式的验证而没有任何其他副作用。模块在针对PB的操作方面提供了极大的灵活性。
一旦所有的模块都被运行，PG*会将任何自定义的工件写入文件系统，或者将生成器特定的工件序列化为CodeGeneratorResponse并将数据发送到其stdout。这整个流程看起来像这样。
foo.proto → protoc → CodeGeneratorRequest → protoc-gen-myplugin → CodeGeneratorResponse → protoc → foo.pb.go 假设插件名称为diy,则需要编译程序为protoc-gen-diy，并将程序加入系统Path变量，通过下面的命令调用插件。
protoc -I .</description>
    </item>
    
    <item>
      <title>tailscale的泛型SingleFlight</title>
      <link>https://czyt.tech/post/generic-singleflight-by-tailscale/</link>
      <pubDate>Fri, 23 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/generic-singleflight-by-tailscale/</guid>
      <description>源地址 tailscale仓库
完整代码如下
// Copyright (c) 2022 Tailscale Inc &amp;amp; AUTHORS All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // Package singleflight provides a duplicate function call suppression // mechanism.</description>
    </item>
    
    <item>
      <title>Golang 默认的CGO参数编译导致的GLIBC错误</title>
      <link>https://czyt.tech/post/golang-default-cgo-flags-caused-glibc-missing-error/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-default-cgo-flags-caused-glibc-missing-error/</guid>
      <description>问题描述 使用go正常编译了Linux下的程序，放到服务器上报错
./app: /lib64/libc.so.6: version `GLIBC_2.34&amp;#39; not found (required by ./app) 解决 Google了下，发现相同的Issue,于是通过go env检查本机golang运行环境，发现CGO默认启用而且程序也不涉及CGO相关的东西，于是设置CGO参数为关闭。然后编译程序
CGO_ENABLED=&amp;quot;0&amp;quot; go build -v
重新上传，运行OK.</description>
    </item>
    
    <item>
      <title>golang http客户端使用自定义dns</title>
      <link>https://czyt.tech/post/golang-http-use-custom-dns/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-http-use-custom-dns/</guid>
      <description>摘自互联网 原文
package main import ( &amp;#34;context&amp;#34; &amp;#34;io/ioutil&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) func main() { var ( dnsResolverIP = &amp;#34;8.8.8.8:53&amp;#34; // Google DNS resolver. dnsResolverProto = &amp;#34;udp&amp;#34; // Protocol to use for the DNS resolver dnsResolverTimeoutMs = 5000 // Timeout (ms) for the DNS resolver (optional) ) dialer := &amp;amp;net.Dialer{ Resolver: &amp;amp;net.Resolver{ PreferGo: true, Dial: func(ctx context.Context, network, address string) (net.Conn, error) { d := net.Dialer{ Timeout: time.Duration(dnsResolverTimeoutMs) * time.</description>
    </item>
    
    <item>
      <title>go-kratos使用备忘</title>
      <link>https://czyt.tech/post/go-kratos-usage-memo/</link>
      <pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-kratos-usage-memo/</guid>
      <description>自定义接口返回内容 正常的响应序列化逻辑通过Response Encoder实现。
错误的序列化逻辑通过ErrorEncoder实现。
注意：自定义Encoder后，可能会遇到零值字段被忽略的情况，可以参考这个issue。具体的解决办法是
proto定义返回内容，然后将生成的类型在encoder中使用。
简单代码大致如下：
proto定义
import &amp;#34;google/protobuf/any.proto&amp;#34;; // BaseResponse is the base response message BaseResponse{ int32 code = 1 [json_name = &amp;#34;code&amp;#34;]; google.protobuf.Any data = 2 [json_name = &amp;#34;data&amp;#34;]; } go代码
func CustomResponseEncoder() http.ServerOption { return http.ResponseEncoder(func(w http.ResponseWriter, r *http.Request, i interface{}) error { reply := &amp;amp;v1.BaseResponse{ Code: 0, } if m, ok := i.(proto.Message); ok { payload, err := anypb.New(m) if err != nil { return err } reply.</description>
    </item>
    
    <item>
      <title>Protobuf golang小札</title>
      <link>https://czyt.tech/post/protobuf-golang-litle-notes/</link>
      <pubDate>Mon, 25 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/protobuf-golang-litle-notes/</guid>
      <description>Oneof 如果您有许多字段的消息，并且最多可以同时设置一个字段，则可以使用Oneof功能来执行此行为并保存内存。一个字段就像常规字段一样，除了单一共享内存中的所有字段，最多可以同时设置一个字段。设置Oneof的任何成员都会自动清除所有其他成员。
​	Google protobuf 文档#Oneof
示例proto 创建protoOneof.proto 的proto文件
syntax = &amp;#34;proto3&amp;#34;; package oneof_test; option go_package =&amp;#39;.;oneof&amp;#39;; message WeiboUser{ string user_id = 1; string user_nick = 2; } message DouyinUser{ string auth_token = 1; string nick_name = 2; } message User{ oneof user_source{ string weibo_url = 1; string douyin_url = 2; } oneof user_info{ WeiboUser weibo_user_info = 3; DouyinUser douyin_user_info = 4; } } 使用命令生成go代码
protoc --proto_path=. --go_out=paths=source_relative:./oneof ./protoOneof.proto 生成的protoOneof.pb.go代码如下：</description>
    </item>
    
    <item>
      <title>使用gotests生成表驱动测试</title>
      <link>https://czyt.tech/post/use-gotests-to-generate-table-driven-tests/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/use-gotests-to-generate-table-driven-tests/</guid>
      <description>使用gotests可以很方便的生成表驱动测试代码，表驱动测试的具体内容，请参考go官方的wiki。下面是具体的使用方法。
安装 使用下面命令进行安装
go install github.com/cweill/gotests/gotests@latest 如果是go1.16之前的版本，可以使用命令 go get -u github.com/cweill/gotests/...来进行安装。
使用 gotests支持的参数如下：
Usage of C:\Users\czyt\go\bin\gotests.exe:-allgenerate tests for all functions and methods-excl stringregexp. generate tests for functions and methods that don&amp;#39;t match. Takes precedence over -only, -exported, and -all-exportedgenerate tests for exported functions and methods. Takes precedence over -only and -all-i print test inputs in error messages-nosubtestsdisable generating tests using the Go 1.</description>
    </item>
    
    <item>
      <title>Golang Expr不完全指南</title>
      <link>https://czyt.tech/post/golang-expr-uncompleted-reference/</link>
      <pubDate>Wed, 13 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-expr-uncompleted-reference/</guid>
      <description>安装 库的说明
Expr package provides an engine that can compile and evaluate expressions. An expression is a one-liner that returns a value (mostly, but not limited to, booleans). It is designed for simplicity, speed and safety.
The purpose of the package is to allow users to use expressions inside configuration for more complex logic. It is a perfect candidate for the foundation of a business rule engine.
安装
go get -u /github.</description>
    </item>
    
    <item>
      <title>Golang DSL参考</title>
      <link>https://czyt.tech/post/golang-dsl-reference/</link>
      <pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-dsl-reference/</guid>
      <description>ANTLR 4 图书 The definitive ANTLR 4 reference (2014) 英文版下载 中文版下载 文章 使用ANTLR和Go实现DSL入门 手把手教你使用ANTLR和Go实现一门DSL语言part1 part2part3part4part5 Parsing with ANTLR 4 and Go 实例代码 bilibili gengine link go-zero link grule-rule-engine Others 图书 Writing A Compiler In Go Writing an Interpreter in Go µGo语言实现——从头开发一个迷你Go语言编译器 文章 Build your own DSL with Go &amp;amp; HCL
How to Write Syntax Tree-Based Domain-Specific Languages in Go
Handwritten Parsers &amp;amp; Lexers in Go
goyacc实战
TiDB SQL Parser 的实现</description>
    </item>
    
    <item>
      <title>Golang io.Pipe 使用</title>
      <link>https://czyt.tech/post/golang-io-pipe-usage/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-io-pipe-usage/</guid>
      <description>介绍 // Pipe creates a synchronous in-memory pipe. // It can be used to connect code expecting an io.Reader // with code expecting an io.Writer. // // Reads and Writes on the pipe are matched one to one // except when multiple Reads are needed to consume a single Write. // That is, each Write to the PipeWriter blocks until it has satisfied // one or more Reads from the PipeReader that fully consume // the written data.</description>
    </item>
    
    <item>
      <title>go embed 使用小记</title>
      <link>https://czyt.tech/post/go-embed-usage-note/</link>
      <pubDate>Thu, 23 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-embed-usage-note/</guid>
      <description>​ go embed 是go 1.16 开始添加的特性，允许嵌入文件及文件夹，在Go程序中进行使用。官方还为此添加了embed.FS的对象。下面将常用的使用场景进行简单列举：
嵌入单个文件 官方的例子
嵌入文件并绑定到字符串变量 import _ &amp;#34;embed&amp;#34; //go:embed hello.txt var s string print(s) 嵌入文件并绑定到字节变量 import _ &amp;#34;embed&amp;#34; //go:embed hello.txt var b []byte print(string(b)) 嵌入文件并绑定到文件对象 import &amp;#34;embed&amp;#34; //go:embed hello.txt var f embed.FS data, _ := f.ReadFile(&amp;#34;hello.txt&amp;#34;) print(string(data)) 嵌入目录 嵌入时，可以在多行或者一行输入要嵌入的文件和文件夹。
package server import &amp;#34;embed&amp;#34; // content holds our static web server content. //go:embed image/* template/* //go:embed html/index.html var content embed.FS 在匹配文件夹时，embed会嵌入包括子目录下的所有除.和_开头的文件（递归），所以上面的代码大致等价于下面的代码：
// content is our static web server content.</description>
    </item>
    
    <item>
      <title>Golang nocopy check</title>
      <link>https://czyt.tech/post/golang-nocopy-check/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-nocopy-check/</guid>
      <description>目的 实现nocopy的目的在于，golang在进行参数传递时，都是传递副本的方式。但是某些情况，我们是需要进行传递对象的引用的（特别是一些指针对象，可能会导致多个指针的副本的操作造成程序陷入恐慌），为了杜绝调用者的复制，只能指针传递全局唯一对象。那么就可以通过添加nocopy来实现对go vet参数支持的no copy 检查。
实现 golang里面最常用的sync.WaitGroup就是通过nocopy实现的。参考定义
// A WaitGroup must not be copied after first use. type WaitGroup struct { noCopy noCopy // 64-bit value: high 32 bits are counter, low 32 bits are waiter count. // 64-bit atomic operations require 64-bit alignment, but 32-bit // compilers do not ensure it. So we allocate 12 bytes and then use // the aligned 8 bytes in them as state, and the other 4 as storage // for the sema.</description>
    </item>
    
    <item>
      <title>golang正则校验支付宝微信支付授权码</title>
      <link>https://czyt.tech/post/golang-check-wechat-alipay-authcode-via-regxp/</link>
      <pubDate>Fri, 17 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-check-wechat-alipay-authcode-via-regxp/</guid>
      <description>参考sdk定义
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;regexp&amp;#34; ) // wechat pay 用户付款码条形码规则：18位纯数字，以10、11、12、13、14、15开头 // alipay 支付授权码，25~30开头的长度为16~24位的数字，实际字符串长度以开发者获取的付款码长度为准 func main() { // wechat regwechat:=regexp.MustCompile(&amp;#34;^(1[0-5])\\d{16}$&amp;#34;) matchwechat := regwechat.MatchString(&amp;#34;154658833119096245&amp;#34;) fmt.Println(matchwechat) // alipay regalipay:=regexp.MustCompile(&amp;#34;^(2[5-9]|30)\\d{14,22}$&amp;#34;) matchalipay := regalipay.MatchString(&amp;#34;307573774583867517336&amp;#34;) fmt.Println(matchalipay) } 参考
微信
支付宝</description>
    </item>
    
    <item>
      <title>ebpf Golang参考</title>
      <link>https://czyt.tech/post/ebpf-golang-reference/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/ebpf-golang-reference/</guid>
      <description>整理一个列表，持续更新。
理论 ebf官网 B站视频 eBPF 和 Go，超能力组合 实践 Tracing Go Functions with eBPF part1 part2 Getting Started with eBPF and Go Linux中基于eBPF的恶意利用与检测机制 如何用eBPF分析Golang应用 使用BPF, 将Go网络程序的吞吐提升8倍 使用ebpf跟踪rpcx微服务 BPF MAP机制 一种通用数据结构，可以存储不同类型数据的通用数据结构 Andrii Nakryiko 抽象数据容器(abstract data container) bpf系统调用的说明 《使用C语言从头开发一个Hello World级别的eBPF程序》 《Linux Observability with BPF》 《揭秘BPF map前生今世》 bpf系统调用说明 官方bpf map参考手册 bpftool参考手册 《Building BPF applications with libbpf-bootstrap》 https://github.com/DavadDi/bpf_study golang 包 https://github.com/cilium/ebpf </description>
    </item>
    
    <item>
      <title>Go性能优化参考</title>
      <link>https://czyt.tech/post/golang-perf-reference/</link>
      <pubDate>Sat, 11 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-perf-reference/</guid>
      <description>电子书 编写和优化Go代码 Go Optimizations 101 https://github.com/dgryski/go-perfbook https://github.com/DataDog/go-profiler-notes https://github.com/bobstrecansky/HighPerformanceWithGo/ Go package https://github.com/aclements/go-perf 文章 官方博客 Profiling Go Programs
https://sumercip.com/posts/inside-the-go-cpu-profiler/
How to Write Benchmarks in Go : https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
Debugging performance issues in Go programs : https://github.com/golang/go/wiki/Performance
Go execution tracer : https://blog.gopheracademy.com/advent-2017/go-execution-tracer/ (see also the The tracer design doc link)
A whirlwind tour of Go’s runtime environment variables (see godebug) : https://dave.cheney.net/2015/11/29/a-whirlwind-tour-of-gos-runtime-environment-variables
benchstat : https://godoc.org/golang.org/x/perf/cmd/benchstat
pyroscope: 一个简单易用的持续剖析平台
VSCODE可视化调试Go程序
Jetbrains官方Goland代码调试文档
https://github.com/cch123/perf_workshop_2021
GO高性能编程精华
Go 语言中各式各样的优化手段
Go 中简单的内存节省技巧</description>
    </item>
    
    <item>
      <title>Cap&#39;n Proto Windows环境设置</title>
      <link>https://czyt.tech/post/capn-proto-setup-in-windows/</link>
      <pubDate>Fri, 10 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/capn-proto-setup-in-windows/</guid>
      <description>Cap&amp;rsquo;n proto 号称是比protobuff更快的proto语言。官网截图
Cap’n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think Protocol Buffers, except faster. In fact, in benchmarks, Cap’n Proto is INFINITY TIMES faster than Protocol Buffers.
协议特性
Cap’n Proto’s RPC protocol has the following notable features. Since the protocol is complicated, the feature set has been divided into numbered “levels”, so that implementations may declare which features they have covered by advertising a level number.</description>
    </item>
    
    <item>
      <title>Golang反射使用指南</title>
      <link>https://czyt.tech/post/golang-reflect-reference/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-reflect-reference/</guid>
      <description>Go是一门强类型的语言，在大多数情况下，申明一个变量、函数、struct都是直截了当的。在大多数情况下，这些都是够用的，但有时你想在程序运行中来动态扩展程序的信息，也许你想把文件或网络请求中的数据映射到一个变量中;也许你想建立一个能处理不同类型的工具(虽然Go1.18有了泛型)。在这些情况下，你需要使用反射。反射使你有能力在运行时检查、修改和创建变量、函数和结构的能力。
反射的核心 图片转自 Go 语言设计与实现
反射的三大核心是*Types, Kinds, Values,下面将围绕这三个方面来进行讲解。
我们先定义一个struct对象。
type User struct { Name	string Age int } 类型Types 通过反射获取类型
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Name()) // 打印 User log.Println(otptr.Name()) // 打印 空 通过调用Name()方法返回类型的名称，某些类型，如切片或指针，没有名称，此方法返回一个空字符串。
种类Kinds Kind通过调用Kind()得来。
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Kind()) // 输出 struct log.Println(otptr.Kind()) // 输出 ptr Kind() 返回的是kind类型的枚举。</description>
    </item>
    
    <item>
      <title>Golang MongoDB ODM mgm使用</title>
      <link>https://czyt.tech/post/golang-mongodb-mgm-odm-usage/</link>
      <pubDate>Tue, 31 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-mongodb-mgm-odm-usage/</guid>
      <description>(本文大部分内容根据官方文档翻译而来)
环境准备 golang 1.10+ mongodb mgm 模型定义 定义 定义模型
type Book struct { // DefaultModel adds _id, created_at and updated_at fields to the Model mgm.DefaultModel `bson:&amp;#34;,inline&amp;#34;` Name string `json:&amp;#34;name&amp;#34; bson:&amp;#34;name&amp;#34;` Pages int `json:&amp;#34;pages&amp;#34; bson:&amp;#34;pages&amp;#34;` } func NewBook(name string, pages int) *Book { return &amp;amp;Book{ Name: name, Pages: pages, } } mgm 在创建表时会自动检测Model生成的Collection名称
book:=Book{} // Print your model collection name. collName := mgm.CollName(&amp;amp;book) fmt.Println(collName) // 打印: books 如果要自定义生成Collection的名称。需要实现CollectionNameGetter接口。
func (model *Book) CollectionName() string { return &amp;#34;my_books&amp;#34; } // mgm return &amp;#34;my_books&amp;#34; collection coll:=mgm.</description>
    </item>
    
    <item>
      <title>MongoDB操作指北</title>
      <link>https://czyt.tech/post/operate-mongodb-tutorial/</link>
      <pubDate>Thu, 26 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/operate-mongodb-tutorial/</guid>
      <description>TL;DR
环境准备 mongoDB 预备知识 MongoDB常见的数据类型
数据类型 示例 说明 Null {&amp;quot;x&amp;quot; : null} Boolean {&amp;quot;x&amp;quot; : true} Number {&amp;quot;x&amp;quot; : 3.14} {&amp;quot;x&amp;quot; : 3} {&amp;quot;x&amp;quot; : NumberInt(&amp;quot;3&amp;quot;)} {&amp;quot;x&amp;quot; : NumberLong(&amp;quot;3&amp;quot;)} 默认64位浮点数，整数需要使用NumberInt和NumberLong String {&amp;quot;x&amp;quot; : &amp;quot;foobar&amp;quot;} 编码格式为UTF-8 Date {&amp;quot;x&amp;quot; : new Date()} 64位时间戳(从January 1, 1970)，不存时区。通过new Date()进行调用。 Regular expression {&amp;quot;x&amp;quot; : /foobar/i} javascript 正则 Array {&amp;quot;x&amp;quot; : [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]} Embedded document {&amp;quot;x&amp;quot; : {&amp;quot;foo&amp;quot; : &amp;quot;bar&amp;quot;}} Object ID {&amp;quot;x&amp;quot; : ObjectId()} 文档12字节的ID Binary data 一个任意字节的字符串。是保存非UTF-8字符串到数据库的唯一方法。 Code {&amp;quot;x&amp;quot; : function() { /* .</description>
    </item>
    
    <item>
      <title>Golang监测Linux网络事件</title>
      <link>https://czyt.tech/post/golang-monitor-linux-network-events/</link>
      <pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-monitor-linux-network-events/</guid>
      <description>代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;syscall&amp;#34; ) func main() { l, _ := ListenNetlink() for { msgs, err := l.ReadMsgs() if err != nil { fmt.Println(&amp;#34;Could not read netlink: %s&amp;#34;, err) } for _, m := range msgs { if IsNewAddr(&amp;amp;m) { fmt.Println(&amp;#34;New Addr&amp;#34;) } if IsDelAddr(&amp;amp;m) { fmt.Println(&amp;#34;Del Addr&amp;#34;) } } } } type NetlinkListener struct { fd int sa *syscall.SockaddrNetlink } func ListenNetlink() (*NetlinkListener, error) { groups := (1 &amp;lt;&amp;lt; (syscall.</description>
    </item>
    
    <item>
      <title>Golang False sharing</title>
      <link>https://czyt.tech/post/golang-false-sharing/</link>
      <pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-false-sharing/</guid>
      <description>缘起 来自于一段prometheus代码
type stripeLock struct { sync.RWMutex // Padding to avoid multiple locks being on the same cache line. _ [40]byte } 简单地讲就是因为CPU读取数据的缓存机制问题，可能导致性能上的不同差异。参考资料见后文。
常见类型的内存占用大小（Go101）：
Kinds of Types Value Size Required by Go Specification bool 1 byte not specified int8, uint8 (byte) 1 byte 1 byte int16, uint16 2 bytes 2 bytes int32 (rune), uint32, float32 4 bytes 4 bytes int64, uint64, float64, complex64 8 bytes 8 bytes complex128 16 bytes 16 bytes int, uint 1 word architecture dependent, 4 bytes on 32-bit architectures and 8 bytes on 64-bit architectures uintptr 1 word large enough to store the uninterpreted bits of a pointer value string 2 words not specified pointer (safe or unsafe) 1 word not specified slice 3 words not specified map 1 word not specified channel 1 word not specified function 1 word not specified interface 2 words not specified struct (the sum of sizes of all fields) + (the number of padding bytes) the size of a struct type is zero if it contains no fields that have a size greater than zero array (element value size) * (array length) the size of an array type is zero if its element type has zero size 参考 https://medium.</description>
    </item>
    
    <item>
      <title>为Kratos prtobuf文件添加多种编译输出</title>
      <link>https://czyt.tech/post/add-muti-kinds-output-for-kratos/</link>
      <pubDate>Fri, 08 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/add-muti-kinds-output-for-kratos/</guid>
      <description>Csharp 安装Grpc.tools https://www.nuget.org/packages/Grpc.Tools/
下载解压 nupkg文件（改扩展名为zip），也可以使用附件的7z包
解压 找到tools中对应系统架构的软件，设置下环境变量，让系统可以找到就行。
Linux 需要创建一个符号链接
ln -s `which grpc_csharp_plugin` /usr/bin/protoc-gen-grpc-csharp 修改Kratos项目的Make文件 在api这个make任务中添加下面内容
--csharp_out=./api/pipe/v1 \ --grpc-csharp_out=./api/pipe/v1 \ 完整内容为
.PHONY: api # generate api proto api: protoc --proto_path=./api \ --proto_path=./third_party \ --go_out=paths=source_relative:./api \ --go-http_out=paths=source_relative:./api \ --go-grpc_out=paths=source_relative:./api \ --csharp_out=./api/pipe/v1 \ --grpc-csharp_out=./api/pipe/v1 \ --openapi_out==paths=source_relative:. \ 参考
https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md
📎tools.7z
Python 安装必要包 pip install grpclib protobuf 查询路径 which protoc-gen-grpclib_python 或者 which protoc-gen-python_grpc我这里返回信息如下： ➜ czyt which protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpclib_python 如法炮制，创建软链接 ln -s /usr/sbin/protoc-gen-grpclib_python /usr/sbin/protoc-gen-grpc_python 修改Makefile 添加下面的内容,再执行make api生成api即可。 --python_out=.</description>
    </item>
    
    <item>
      <title>个人Golang环境安装快速设置</title>
      <link>https://czyt.tech/post/personal-golang-env-quick-set/</link>
      <pubDate>Thu, 24 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/personal-golang-env-quick-set/</guid>
      <description>下载 官方下载 https://go.dev/dl/
Google 香港镜像
Golang Downloads Mirrors
更多请参考 Thanks Mirror
环境设置 设置proxy
go env -w GOPROXY=https://goproxy.io,https://goproxy.cn,direct 安装相关工具 框架Cli kratos go install github.com/go-kratos/kratos/cmd/kratos/v2@latest
wire go install github.com/google/wire/cmd/wire@latest
ent go install entgo.io/ent/cmd/ent@latest
entimport go install ariga.io/entimport/cmd/entimport@latest
entproto go install entgo.io/contrib/entproto/cmd/entproto@latest
代码Lint golangci-lint go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
gofumpt go install mvdan.cc/gofumpt@latest goland设置
GoLand doesn&amp;rsquo;t use gopls so it should be configured to use gofumpt directly. Once gofumpt is installed, follow the steps below:</description>
    </item>
    
    <item>
      <title>grpc-golang windows环境搭建说明</title>
      <link>https://czyt.tech/post/grpc-golang-setup-in-windows/</link>
      <pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/grpc-golang-setup-in-windows/</guid>
      <description>下载protoc，打开链接 下载后将对应的文件解压到gopath的bin目录。 下载protoc的golang插件。下载地址 链接 下载后放在protoc的同级目录（需要改扩展名为exe） 测试，定义一个Proto syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;.;hello&amp;#34;; package main; message String { string value = 1; } 然后执行命令 protoc hello.proto --go_out=. ,大功告成，生成的文件内容如下：
// Code generated by protoc-gen-go. DO NOT EDIT. // versions: // protoc-gen-go v1.24.0-devel // protoc v3.12.3 // source: hello.proto package hello import ( proto &amp;#34;github.com/golang/protobuf/proto&amp;#34; protoreflect &amp;#34;google.golang.org/protobuf/reflect/protoreflect&amp;#34; protoimpl &amp;#34;google.golang.org/protobuf/runtime/protoimpl&amp;#34; reflect &amp;#34;reflect&amp;#34; sync &amp;#34;sync&amp;#34; ) const ( // Verify that this generated code is sufficiently up-to-date.</description>
    </item>
    
    <item>
      <title>golang webserver with genergic base64 /favicon.ico</title>
      <link>https://czyt.tech/post/golang-web-server-add-base64-favicon/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-web-server-add-base64-favicon/</guid>
      <description>package main import ( &amp;#34;fmt&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { http.HandleFunc(&amp;#34;/favicon.ico&amp;#34;, favicon) http.HandleFunc(&amp;#34;/&amp;#34;, hello) fmt.Printf(&amp;#34;listening on http://localhost:8000/\n&amp;#34;) http.ListenAndServe(&amp;#34;localhost:8000&amp;#34;, nil) } func favicon(w http.ResponseWriter, r *http.Request) { fmt.Printf(&amp;#34;%s\n&amp;#34;, r.RequestURI) w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;image/x-icon&amp;#34;) w.Header().Set(&amp;#34;Cache-Control&amp;#34;, &amp;#34;public, max-age=7776000&amp;#34;) fmt.Fprintln(w, &amp;#34;data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=\n&amp;#34;) } func hello(w http.ResponseWriter, r *http.Request) { fmt.Printf(&amp;#34;%s\n&amp;#34;, r.RequestURI) fmt.Fprintln(w, &amp;#34;Hello, World!&amp;#34;) } </description>
    </item>
    
    <item>
      <title>Golang嵌入可执行程序</title>
      <link>https://czyt.tech/post/golang-embed-executable-file/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-embed-executable-file/</guid>
      <description>reddit链接 On Linux it might be possible to use the memfd_create system call, but that&amp;rsquo;s not portable to other operating systems.
need go 1.16 +
package main import ( _ &amp;#34;embed&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;os/exec&amp;#34; &amp;#34;strconv&amp;#34; &amp;#34;golang.org/x/sys/unix&amp;#34; ) //go:embed binary var embeddedBinary []byte func main() { fd, err := unix.MemfdCreate(&amp;#34;embedded_binary&amp;#34;, 0) if err != nil { log.Fatal(err) } path := &amp;#34;/proc/&amp;#34; + strconv.Itoa(os.Getpid()) + &amp;#34;/fd/&amp;#34; + strconv.Itoa(int(fd)) err = os.WriteFile(path, embeddedBinary, 0755) if err !</description>
    </item>
    
    <item>
      <title>Golang通过ssh连接数据库</title>
      <link>https://czyt.tech/post/go-connect-db-via-ssh/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/go-connect-db-via-ssh/</guid>
      <description>Mysql Postgresql </description>
    </item>
    
    <item>
      <title>golang正则表达式小札</title>
      <link>https://czyt.tech/post/golang-regxp-notes/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-regxp-notes/</guid>
      <description>准备工作 golang正则需要引入包中的regexp包。
import ( &amp;#34;regexp&amp;#34; ) 如果需要复用正则表达式对象来提高性能，可以通过Compile() 或者 MustCompile()创建一个编译好的正则表达式对象。
支持的表达式 单个匹配:
. any character, possibly including newline (flag s=true)[xyz] character class[^xyz] negated character class\d Perl character class\D negated Perl character class[[:alpha:]] ASCII character class[[:^alpha:]] negated ASCII character class\pN Unicode character class (one-letter name)\p{Greek} Unicode character class\PN negated Unicode character class (one-letter name)\P{Greek} negated Unicode character class 组合匹配:
xy x followed by yx|y x or y (prefer x) 多次匹配:</description>
    </item>
    
    <item>
      <title>golang不创建临时文件上传网络文件</title>
      <link>https://czyt.tech/post/golang-upload-network-file-with-no-tmp-file/</link>
      <pubDate>Fri, 21 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-upload-network-file-with-no-tmp-file/</guid>
      <description>func UploadFromUrl(uploadUrl string, resUrl string,postFileName string, submitField string) error { method := &amp;#34;POST&amp;#34; payload := &amp;amp;bytes.Buffer{} writer := multipart.NewWriter(payload) if res, err := http.Get(resUrl); err != nil { return err } else { defer func() { if res != nil { _ = res.Body.Close() } }() part, _ := writer.CreateFormFile(submitField, postFileName) if _, copyErr := io.Copy(part, res.Body); copyErr != nil { return copyErr } if err := writer.Close(); err != nil { return err } } client := &amp;amp;http.</description>
    </item>
    
    <item>
      <title>golang检测网络连接是否关闭</title>
      <link>https://czyt.tech/post/golang-check-netconnection/</link>
      <pubDate>Thu, 11 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-check-netconnection/</guid>
      <description>_, err := conn.Read(make([]byte, 0)) if err!=io.EOF{ // this connection is invalid logger.W(&amp;#34;conn closed....&amp;#34;,err) }else{ byt, _:= ioutil.ReadAll(conn); } 注意：net: don&amp;rsquo;t return io.EOF from zero byte reads issue
参考
https://stackoverflow.com/questions/12741386/how-to-know-tcp-connection-is-closed-in-net-package</description>
    </item>
    
    <item>
      <title>golang使用官方库实现i18n</title>
      <link>https://czyt.tech/post/golang-impl-i18n-with-standard-lib/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-impl-i18n-with-standard-lib/</guid>
      <description>示例 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;golang.org/x/text/language&amp;#34; &amp;#34;golang.org/x/text/message&amp;#34; &amp;#34;golang.org/x/text/message/catalog&amp;#34; ) func main() { builder := catalog.NewBuilder() chTag:=language.Make(&amp;#34;zh_Hans&amp;#34;) engTag:=language.Make(&amp;#34;en&amp;#34;) builder.SetString(chTag,&amp;#34;hello&amp;#34;,&amp;#34;您好&amp;#34;) builder.SetString(engTag,&amp;#34;hello&amp;#34;,&amp;#34;Hello&amp;#34;) fmt.Println(builder.Languages()) option := message.Catalog(builder) p := message.NewPrinter(chTag,option) p.Printf(&amp;#34;hello&amp;#34;) p2 := message.NewPrinter(engTag,option) p2.Printf(&amp;#34;hello&amp;#34;) } 参考 https://zyfdegh.github.io/post/201805-translation-go-i18n https://www.alexedwards.net/blog/i18n-managing-translations https://phrase.com/blog/posts/internationalisation-in-go-with-go-i18n/ https://lokalise.com/blog/go-internationalization-using-go-i18n/ https://go.googlesource.com/proposal/+/master/design/12750-localization.md </description>
    </item>
    
  </channel>
</rss>
