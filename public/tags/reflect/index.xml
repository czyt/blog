<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>reflect on 虫子樱桃</title>
    <link>https://czyt.tech/tags/reflect/</link>
    <description>Recent content in reflect on 虫子樱桃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Thu, 02 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://czyt.tech/tags/reflect/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang反射使用指南</title>
      <link>https://czyt.tech/post/golang-reflect-reference/</link>
      <pubDate>Thu, 02 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/golang-reflect-reference/</guid>
      <description>Go是一门强类型的语言，在大多数情况下，申明一个变量、函数、struct都是直截了当的。在大多数情况下，这些都是够用的，但有时你想在程序运行中来动态扩展程序的信息，也许你想把文件或网络请求中的数据映射到一个变量中;也许你想建立一个能处理不同类型的工具(虽然Go1.18有了泛型)。在这些情况下，你需要使用反射。反射使你有能力在运行时检查、修改和创建变量、函数和结构的能力。
反射的核心 图片转自 Go 语言设计与实现
反射的三大核心是*Types, Kinds, Values,下面将围绕这三个方面来进行讲解。
我们先定义一个struct对象。
type User struct { Name	string Age int } 类型Types 通过反射获取类型
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Name()) // 打印 User log.Println(otptr.Name()) // 打印 空 通过调用Name()方法返回类型的名称，某些类型，如切片或指针，没有名称，此方法返回一个空字符串。
种类Kinds Kind通过调用Kind()得来。
u := User{ Name: &amp;#34;czyt&amp;#34;, Age: 18, } uptr := &amp;amp;u ot := reflect.TypeOf(u) otptr := reflect.TypeOf(uptr) log.Println(ot.Kind()) // 输出 struct log.Println(otptr.Kind()) // 输出 ptr Kind() 返回的是kind类型的枚举。</description>
    </item>
    
  </channel>
</rss>
