<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>WPF on 虫子樱桃</title>
    <link>https://czyt.tech/tags/wpf/</link>
    <description>Recent content in WPF on 虫子樱桃</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 25 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://czyt.tech/tags/wpf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>WPF与虚拟键盘的那些事</title>
      <link>https://czyt.tech/post/wpf-virtual-keyboard-related/</link>
      <pubDate>Mon, 25 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/wpf-virtual-keyboard-related/</guid>
      <description>缘起 近期项目使用到相关技术，故整理文章一篇。
获取可用输入设备 软件的本质无非是输入和输出，那么WPF如何获取电脑是否有可用输入设备呢？查询了Google,在StackOverflow上找到一个提问，原帖地址，代码如下：
KeyboardCapabilities keyboardCapabilities = new Windows.Devices.Input.KeyboardCapabilities(); return keyboardCapabilities.KeyboardPresent != 0 ? true : false; 如果没有可用输入设备，那么就该虚拟键盘上场了。windows里面有两个虚拟键盘的程序，一个是TabTip.exe一个是osk.exe,可以直接调用进程，也可以使用 WPF的第三方组件https://github.com/maximcus/WPFTabTip 详细实现可以参考后面的链接。
平板模式 下面代码将当前系统的运行模式改为平板模式
public static readonly Guid CLSID_ImmersiveShell = new Guid(&amp;#34;C2F03A33-21F5-47FA-B4BB-156362A2F239&amp;#34;); [ComImport()] [Guid(&amp;#34;4FDA780A-ACD2-41F7-B4F2-EBE674C9BF2A&amp;#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] public interface ITabletModeController { int GetMode(ref int mode); int SetMode(int mode, int modeTrigger); } [ComImport] [Guid(&amp;#34;6D5140C1-7436-11CE-8034-00AA006009FA&amp;#34;)] [InterfaceType(ComInterfaceType.InterfaceIsIUnknown)] internal interface IServiceProvider { [return: MarshalAs(UnmanagedType.IUnknown)] object QueryService(ref Guid service, ref Guid riid); } 调用
var pSP = (IServiceProvider)Activator.CreateInstance(Type.GetTypeFromCLSID(CLSID_ImmersiveShell)); var pTMC = (ITabletModeController)pSP.</description>
    </item>
    
    <item>
      <title>WPF Prism 8如何注册Logging</title>
      <link>https://czyt.tech/post/how-to-register-logging-in-prism8/</link>
      <pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://czyt.tech/post/how-to-register-logging-in-prism8/</guid>
      <description>Nuget包 基础包 Microsoft Logging Abstractions Microsoft Extensions DependencyInjection 可选日志包 可以按实际需求进行选择，如NLog等,我们这里采用的是 Serilog 这个Nuget包Serilog Extensions Logging
根据日志输出的目标不同，可以选择不同的扩展方法包
目标 包名 说明 文件 Serilog.Sinks.File WiteTo可以使用File方法详细说明 命令行 Serilog.Sinks.Console 调试输出 Serilog.Sinks.Debug WiteTo可以使用Debug方法 其他扩展，请搜索 点击
日志容器注册 我们使用的是 DryIoc 进行注册，需要安装Nuget包 DryIoc.Microsoft.DependencyInjection 具体代码如下：
protected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =&amp;gt; loggingBuilder.AddSerilog(dispose: true)); return new DryIocContainerExtension(new Container(CreateContainerRules()) .WithDependencyInjectionAdapter(serviceCollection)); } 如果是Unity 则需要安装包 Unity.Microsoft.DependencyInjection 具体代码如下：
protected override IContainerExtension CreateContainerExtension() { var serviceCollection = new ServiceCollection(); serviceCollection.AddLogging(loggingBuilder =&amp;gt; loggingBuilder.</description>
    </item>
    
  </channel>
</rss>
